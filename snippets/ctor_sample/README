Пример для демонстрации работы с функциями-конструкторами для модулей ядра.

Вообще, эти конструкторы и деструкторы предназначены, скорее, для DSO 
(dynamic shared objects), чем для модулей ядра - см. статью Drepper'а о DSO 
(How to Write Shared Libraries).

Тем не менее, судя по коду sys_init_module (module.c), конструкторы всё же 
вызываются при загрузке модуля: после уведомления всех, кого надо, но перед 
вызовом init-функции модуля. 

Если параметр ядра CONFIG_CONSTRUCTORS не определён (эквив. - 'N'), 
конструкторы не вызываются.

Деструкторы не вызываются никогда, хотя в файле модуля и в памяти 
присутствуют.

В С-коде конструкторы указываются с помощью __attribute__((constructor)), 
деструкторы - __attribute__((destructor)).

GCC помещает конструкторы в ELF-файле в секцию ".ctors", деструкторы - в 
".dtors". Эти секции и в загруженном в памяти модуле остаются, их адреса 
доступны, например, через /sys/module/sections.

Порядок вызова конструкторов может отличаться от того порядка, в котором 
они расположены в source файле.

Конструкторы можно вызывать и явно из функций драйвера (даже из init и 
cleanup) - как обычные функции. Деструкторы тоже можно, но т.к. 
автоматически они всё равно не вызываются, не видно особого смысла их как 
деструкторы отмечать.

Всё, указанное здесь, проверялось на: 
1) OpenSuSE 11.2 x86 (ядро: 2.6.32.8 с kernel.org, GCC: 4.4.1);
2) SLES 11 x86_64 (ядро: 2.6.27.21 "родное", GCC: 4.3.2).

В случае (1) конструкторы вызывались, в случае (2) - нет (видимо, из-за 
того, что CONFIG_CONSTRUCTORS не задан для ядра: нету его в .config вообще).

Судя по исходникам ядра 2.6.33 (kernel.org), похоже, конструкторы никто там 
не использует. 
