<section id="getting_started">
<title>Getting Started</title>

<para>
This section shows how to install KEDR framework and how to use it to analyze a simple kernel module.
</para>

<warning>
    <para>
KEDR framework can do much harm if it gets out of control. USE IT ONLY IF YOU 
KNOW WHAT YOU ARE DOING. There is no warranty. If you use KEDR, you do so at
your own risk.
    </para>
    <para>
Main components of KEDR framework operate in the kernel space. The system 
instruments the modules under analysis and allows custom kernel modules to 
alter the behaviour of these modules. This creates both a security hole 
and a potential for system instability, especially if the kernel modules under 
analysis are faulty.
    </para>
    <para>
It is not recommended to use KEDR on the machines holding important data or 
providing important services.
    </para>
</warning>
<!-- ================================================================ -->

<section id="getting_started.install">
<title>Installation</title>

<para>
It is recommended to build KEDR from source. This allows to avoid a lot of issues concerning the differences between many versions and variants of the Linux kernel. For the present, there is no official binary distribution of KEDR. 
</para>

<para>
The source code of the framework can be downloaded from the <ulink url="&kedr-url;">project site</ulink> at BerliOS Developer.
</para>

<itemizedlist>
<para>
To be able to build KEDR, you need the following:
</para>

<listitem><para>
Your Linux system should have kernel version 2.6.31 or newer. <command>uname -r</command> command should tell you what kernel version you are currently using. x86 and x86-64 architectures are currently supported.
</para></listitem>

<listitem><para>
CMake build system (<ulink url="http://cmake.org/">http://cmake.org/</ulink>) version 2.6 or newer (version 2.8 or newer is preferable)
</para></listitem>

<listitem><para>
GNU C and C++ compilers version 4.0 or newer
</para></listitem>

<listitem><para>
GNU Make
</para></listitem>

<listitem><para>
Other tools and packages necessary to build kernel modules: on some systems it can be <quote>kernel-*-devel</quote>, <quote>kernel-*-source</quote>, <quote>kernel-*-syms</quote>, <quote>linux-headers-*</quote> or other packages. On some systems you may also need to install <quote>DKMS</quote> package or something like that.
</para></listitem>
</itemizedlist>

<para>
After all the prerequisites have been met, unpack the archive with the sources (<filename>kedr-&rel-version;.tar.bz2</filename>) and create another directory, say, <filename class='directory'>kedr-build</filename> where KEDR will be built.
</para>

<note><para>
It is highly recommended to use an out-of-source build, i.e. not to build KEDR from the directory containing its sources. With an out-of-source build, you leave the source tree of KEDR unchanged, which can be convenient. The source tree can even be read-only in this case. You can also configure and build the framework from different build directories with different options if you want to. An in-source build would make this impossible.
</para></note>

<para>
Change current directory to <filename class='directory'>kedr-build</filename> and configure the package using the following command:
</para>

<programlisting><![CDATA[
cmake ../kedr-0.3/
]]></programlisting>

<para>
During configuration phase, the information about the environment is analyzed and appropriate settings are prepared for KEDR to tune it properly to your system. This is done automatically.
</para>

<para>
By default, KEDR will be installed to <filename class='directory'>/usr/local/</filename>. If you would like to install KEDR to some other location, configure the package as follows:
</para>

<programlisting><![CDATA[
cmake -DCMAKE_INSTALL_PREFIX=<install_directory> <path-to-kedr-sources>
]]></programlisting>

<para>
Example:
</para>

<programlisting><![CDATA[
cmake -DCMAKE_INSTALL_PREFIX=/opt/kedr/ ../kedr-0.3/
]]></programlisting>

<para>
The package will be configured to be installed to <filename class='directory'>/opt/kedr/</filename>.
</para>

<para>
If the configuration stage completes successfully, you can type <command>make</command> to build the package and <command>make install</command> - to install it. You may need to execute <command>make install</command> as a root user.
</para>

<para>
To remove the files installed with <command>make install</command>, you can use <command>make uninstall</command> command.
</para>

<note><para>
Currently, <command>make uninstall</command> does not remove directories, only files.
</para></note>

<para>
KEDR package also contains a set of tests for KEDR framework. You may want to run these tests after KEDR is built but before it is installed to see if the tools provided by the framework correctly operate on your system. To do so, just execute <command>make check</command> (as root user).
</para>

</section> <!-- "getting_started.install" -->
<!-- ================================================================ -->

<section id="getting_started.example">
<title>A Simple Example</title>

<para>
Let us consider an example of how to analyze a simple kernel module with KEDR. We assume here that KEDR has been installed to <filename class="directory">/usr/local</filename>. Unless specifically stated, the control and helper tools mentioned below should be executed by a user with root privileges.
</para>

<para>
You can use <quote>sample_target</quote> module as a kernel module to be analyzed. It can be found among the examples installed with KEDR (see <filename class="directory">/usr/local/share/kedr/examples/</filename>). Copy the contents of <filename class="directory">sample_target</filename> directory to a place of your choice and run <command>make</command> there. You should get <filename>kedr_sample_target.ko</filename> file as a result. It is a kernel module we will use to demonstrate the abilities of KEDR.
</para>

<para>
Run the control script (as root):
<programlisting>
/usr/local/bin/kedr start kedr_sample_target
</programlisting>
This will start the core components of KEDR and instruct them to process the kernel module with the specified name (<quote>kedr_sample_target</quote>). Note that <quote>kedr_sample_target</quote> itself is not loading at this stage. But as soon as this module is loaded, KEDR core will detect it and will connect to it automatically.
</para>

<para>
Now load our module to be analyzed (<firstterm>target module</firstterm>). The easiest way to do this is to execute a helper script provided with that module:
<programlisting>
./kedr_sample_target load
</programlisting>
When the module is loaded, it creates two character devices, <filename>/dev/cfake0</filename> and <filename>/dev/cfake1</filename>.
</para>

<para>
Now that KEDR core is up and running and the target module is loaded, we can perform the anaysis. What can actually be done depends on the additional steps in the process of loading KEDR and the target module. This will be described in the following sections.
</para>

<para>
When you are done with KEDR, it can be stopped. Please unload the target module first. To do this, execute the helper script as follows:
<programlisting>
./kedr_sample_target unload
</programlisting>
</para>

<para>Now stop KEDR (and actually unload its components):
<programlisting>
/usr/local/bin/kedr stop
</programlisting>
</para>
</section> <!-- "getting_started.example" -->
<!-- ================================================================ -->


<section id="getting_started.call_monitoring">
<title>Call Monitoring (Call Tracing)</title>

<para>
In this section, we will show how to use KEDR for call monitoring, that is, for gathering information
about function calls made by the target module. This will be demonstrated on <quote>kedr_sample_target</quote> module.
</para>

<para>
Actually, the command
<programlisting>
/usr/local/bin/kedr start kedr_sample_target
</programlisting>
called without additional arguments also loads the necessary modules to perform call monitoring (in addition to loading the KEDR core).
</para>

<para>
Information about kernel function calls is temporarily stored in a file in debugfs filesystem. So, to see this information, you need to have this filesystem mounted. Usually, it mounted by default to <filename class='directory'>/sys/kernel/debug</filename>. If it is not the case for your system, you can mount it manually by executing
<programlisting>
mount debugfs -t debugfs /sys/kernel/debug
</programlisting>
</para>
<para>
You can instruct KEDR to output the information about the calls to kernel functions. To do this, open another terminal and execute
<programlisting>
/usr/local/bin/kedr_capture_trace -b
</programlisting>
From this moment, all tracing information will be output to that terminal. Leave it for a time, and switch to the terminal, in which you have started KEDR.
</para>
<para>
Everything is now ready to load the target kernel module:
<programlisting>
./kedr_sample_target load
</programlisting>
</para>
<para>
Now you can do something with the character device created by the module. E.g., write zeroes to it:
<programlisting>
dd if=/dev/zero of=/dev/cfake0 bs=1 count=10
</programlisting>
</para>
<para>
Switch to the terminal, in which you have run <command>kedr_capture_trace</command> tool. You can find the records like the following ones there:
</para>

<programlisting><![CDATA[
insmod-6416 [001] 805.997300: target_session_begins: 
    target_name: "kedr_sample_target", payload_name: "kedr_cm_cmm"
...
insmod-6416 [001] 805.997320: target_session_begins: 
    target_name: "kedr_sample_target", payload_name: "kedr_cm_vmm"
insmod-6416 [001] 805.997615: called___kmalloc: ([<ffffffffa00e70b9>] init+0xb9) 
    arguments: (320, d0), result: ffff8800165a8000
dd-6438     [000] 858.641942: called___kmalloc: ([<ffffffffa01d661e>] core+0x61e) 
    arguments: (4000, d0), result: ffff88001659e000
dd-6438     [000] 858.642074: called_copy_from_user: ([<ffffffffa01d642a>] core+0x42a) 
    arguments: (ffff88001659e000, 000000000137d000, 1), result: 0
...
]]></programlisting>

<para>
The first record says that KEDR payload with name <quote>kedr_cm_cmm</quote> has detected the loading of the target module and has prepared to monitor function calls in it. The next several lines state the same but for other payloads, ending with <quote>kedr_cm_vmm</quote>.
</para>

<para>
The next (4th line in the listing above) line contains information about the first detected call to a kernel function, <code>__kmalloc</code>. It shows the values of the parameters passed to the function (size=320, flags=0xd0) and its return value (address 0xffff8800165a8000). The operation was performed in the context of <quote>insmod</quote> process (its PID was 6416).
</para>

<note><para>
<code>([&lt;ffffffffa00e70b9&gt;] init+0xb9)</code> specifies the memory address of that call to <code>__kmalloc</code> (0xffffffffa00e70b9). To be exact, it is technically the address of the next instruction after that call. <code>init+0xb9</code> indicates that the call instruction is located in <quote>init</quote> area of the module (in a function marked with <code>__init</code> in the source code) right before the offset <code>0xb9</code>. If the target module has debug information, this allows to determine the place in the source code of the module where the call is made. This may significantly simplify the analysis of the trace. The detailed explanation of how to analyze the trace and find the fragments of the source code corresponding to the trace records is given in <xref linkend="analyze_trace"/>.
</para></note>

<para>
The fifth record shows another detected call to <code>__kmalloc</code>. It was made when we were writing zeroes to <filename>/dev/cfake0</filename> (it follows from the fact that the call was made in the context of <quote>dd</quote> process that we had launched).
</para>
<para>
The sixth record shows a detected call to another kernel function, <code>copy_from_user</code>, which was also made when we were writing data to <filename>/dev/cfake0</filename> with <command>dd</command>.
</para>

<para>
The remaining records in the trace are similar to those we have just described.
</para>

<para>
Unload the target module using the following command (from the terminal in which the target module was loaded):
<programlisting>
./kedr_sample_target unload
</programlisting>
After that, the lines like the following ones should appear in the trace:
</para>

<programlisting><![CDATA[
rmmod-6441 [001] 869.438875: called_kfree: ([<ffffffffa01d60d8>] core+0xd8) 
    arguments: (ffff88001659e000)
rmmod-6441 [001] 869.438879: called_kfree: ([<ffffffffa01d60d8>] core+0xd8) 
    arguments: ((null))
rmmod-6441 [001] 869.438881: called_kfree: ([<ffffffffa01d6108>] core+0x108) 
    arguments: (ffff8800165a8000)
rmmod-6441 [001] 869.438885: target_session_ends: 
    target_name: "kedr_sample_target", payload_name: "kedr_cm_cmm"
...
rmmod-6441 [001] 869.438895: target_session_ends: 
    target_name: "kedr_sample_target", payload_name: "kedr_cm_vmm"
]]></programlisting>

<para>
There will be no new records in the trace file until the target module is loaded again. You can stop capturing the trace by pressing Ctrl+C in the terminal where <command>kedr_capture_trace</command> runs.
</para>
<para>
The last step is stopping KEDR and unloading its components:
<programlisting>
/usr/local/bin/kedr stop
</programlisting>
</para>

</section> <!-- "getting_started.call_monitoring" -->

<!-- ================================================================ -->

<section id="getting_started.fault_simulation">
<title>Fault Simulation</title>

<para>
This section shows how to use KEDR for <link linkend="fault_simulation">fault simulation</link>. This way, we can, for example, model a situation when the system has low resources or put the target module in some other conditions that relatively seldom take place. 
</para>

<para>
In general, it can be useful to see how a kernel module behaves on the code paths it rarely executes. The errors in the corresponding parts of the target module can remain hidden for a long time. The ability of KEDR to put the target module in such rare conditions without affecting the rest of the system is demonstrated here. <quote>kedr_sample_target</quote> is used again as the target module.
</para>

<para>
KEDR provides a special configuration file for fault simulation. To use this configuration instead of the default one, pass additional option to the KEDR control script (<filename>fsim.conf</filename> is installed with KEDR, so it is not necessary to specify the full path to this file):
<programlisting>
/usr/local/bin/kedr start kedr_sample_target -f fsim.conf
</programlisting>
</para>
<para>
Now KEDR is loaded and prepared to simulate, e.g., the conditions when memory allocation (e.g., via <function>__kmalloc</function>) fails. Note that this simulation will be performed only with respect to the target module, other parts of the kernel will not be affected.
</para>
<para>
You can choose a scenario according to which KEDR will make calls to <function>__kmalloc</function> fail. A number of possible scenarios is already provided by KEDR and custom scenarios can also be developed. In this example, we will show how to configure and use a pre-defined scenario. To make it available, you should load the corresponding module:
<programlisting><![CDATA[
insmod /usr/local/lib/modules/`uname -r`/misc/kedr_fsim_indicator_kmalloc.ko
]]></programlisting>
This module implements a scenario named <quote>kmalloc</quote>. Inform KEDR that it should use this scenario for <code>__kmalloc</code> function:
<programlisting><![CDATA[
echo "kmalloc" > /sys/kernel/debug/kedr_fault_simulation/points/kmalloc/current_indicator
]]></programlisting>
Here we assume that debugfs is mounted to <filename class='directory'>/sys/kernel/debug</filename>.
</para>

<para>
<quote>kmalloc</quote> is actually a name of a whole set of scenarios, so choose one of them:
<programlisting><![CDATA[
echo "1" > /sys/kernel/debug/kedr_fault_simulation/points/kmalloc/expression
]]></programlisting>
The meaning of this scenario is <quote>fail always</quote>. That is, the answer to the question whether to make a call fail or not is always <quote>1</quote> (<quote>yes</quote>) in this scenario.
</para>

<para>
As you have seen in the <link linkend="getting_started.call_monitoring">section about call monitoring</link>, <filename>kedr_sample_target</filename> module calls <code>__kmalloc</code> during initialization. So we can predict that loading of the entire module should fail, because it will not be able to allocate memory for its own use. Let us check if it is the case.
</para>

<programlisting><![CDATA[
./kedr_sample_target load
]]></programlisting>

<programlisting><![CDATA[
insmod: error inserting 'kedr_sample_target.ko': -1 Cannot allocate memory
]]></programlisting>

<para>
As it was expected, the loading has failed.
</para>

<para>
Let us now consider a slightly more complex scenario.
</para>

<programlisting><![CDATA[
echo "size > 2000" > /sys/kernel/debug/kedr_fault_simulation/points/kmalloc/expression
]]></programlisting>

<para>
This means that only the allocation requests for memory blocks bigger than 2000 bytes will fail.
</para>

<programlisting><![CDATA[
./kedr_sample_target load
]]></programlisting>

<para>
This time loading of the target module should succeed. But the attempts to write to it or read from it will fail because the target module needs to allocate a 4000-byte buffer the first time the device is opened. Try this:
</para>

<programlisting><![CDATA[
dd if=/dev/zero of=/dev/cfake0 bs=1 count=10
]]></programlisting>

<para>
You should see an error message similar to the following as a result:
</para>

<programlisting><![CDATA[
dd: opening '/dev/cfake0': Cannot allocate memory
]]></programlisting>

<para>
To turn off fault simulation, just set the scenario to <quote>0</quote> (that means, <quote>never make the calls fail</quote>):
</para>

<programlisting><![CDATA[
echo "0" > /sys/kernel/debug/kedr_fault_simulation/points/kmalloc/expression
]]></programlisting>

<para>
When you are done with fault simulation, unload the scenario module:
</para>

<programlisting>
rmmod kedr_fsim_indicator_kmalloc
</programlisting>

<para>
The scenario for <function>__kmalloc</function> will be cleared automatically, that is no fault simulation will be performed for the function since that moment until a new scenario is loaded and configured.
</para>

<para>
Finally, you can unload the target module
<programlisting>
./kedr_sample_target unload
</programlisting>
and then stop KEDR
<programlisting>
/usr/local/bin/kedr stop
</programlisting>
</para>

</section> <!-- "getting_started.fault_simulation" -->
<!-- ================================================================ -->

<section id="getting_started.leak_check">
<title>Detecting Memory Leaks</title>

<para>
To demonstrate how memory leaks can be detected with KEDR, let us intentionally create a memory leak in <filename>kedr_sample_target</filename> module. What is needed is just to comment out one or more calls to <code>kfree()</code>, for example, in <code>cfake_destroy_device()</code>:
</para>

<programlisting><![CDATA[
/* Destroy the device and free its buffer */
static void
cfake_destroy_device(struct cfake_dev *dev, int minor,
    struct class *class)
{
    BUG_ON(dev == NULL || class == NULL);
    device_destroy(class, MKDEV(cfake_major, minor));
    cdev_del(&dev->cdev);
    /* kfree(dev->data); */ /* Memory leak */
    return;
}
]]></programlisting>

<para>
Now rebuild <filename>kedr_sample_target</filename> and we are all set. 
</para>

<para>
Load KEDR with a special configuration profile (<filename>leak_check.conf</filename>):
</para>

<programlisting><![CDATA[
/usr/local/bin/kedr start kedr_sample_target -f leak_check.conf
]]></programlisting>

<para>
Then load the target module and work with it as usual, for example, do something with the character devices that it creates:
</para>

<programlisting><![CDATA[
./kedr_sample_target load
dd if=/dev/zero of=/dev/cfake0 bs=1 count=10
echo 0123456789ABCDEF > /dev/cfake1
]]></programlisting>

<para>
Unload the target module:
</para>

<programlisting><![CDATA[
./kedr_sample_target unload
]]></programlisting>

<para>
By this moment, KEDR should have prepared a report about memory leaks it has detected. It should be available in <filename class="directory">kedr_leak_check</filename> directory in debugfs. 
</para>

<para>
The file named <filename>info</filename> presents the summary:
</para>

<programlisting><![CDATA[
Target module: "kedr_sample_target", 
    init area at 0xffffffffa0730000, core area at 0xffffffffa072d000
Memory allocations: 3
Possible leaks: 2
Unallocated frees: 0
]]></programlisting>

<para>
<filename>possible_leaks</filename> provides information about the detected memory leaks, namely, address and size for each memory block that was not freed and the call stack of the allocation:
</para>

<programlisting><![CDATA[
Block at 0xffff880024285000, size: 4000; stack trace of the allocation:
[<ffffffffa072d35e>] cfake_open+0x6e/0xb8 [kedr_sample_target]
[<ffffffff81156e3a>] chrdev_open+0x10a/0x200
[<ffffffff81151295>] __dentry_open+0xe5/0x330
[<ffffffff811515f4>] nameidata_to_filp+0x54/0x70
[<ffffffff8115e358>] finish_open+0xe8/0x1d0
[<ffffffff8115f7b6>] do_last+0x86/0x460
[<ffffffff81161aeb>] do_filp_open+0x21b/0x660
[<ffffffff81151039>] do_sys_open+0x69/0x170
[<ffffffff81151180>] sys_open+0x20/0x30
[<ffffffff8100a0f2>] system_call_fastpath+0x16/0x1b
[<ffffffffffffffff>] 0xffffffffffffffff
+1 more allocation(s) with the same call stack.
]]></programlisting>

<para>
The line we have commented out in the sources of the module was to be executed twice (once for each device), so we have got two memory leaks. The call stack shows where the memory blocks were allocated. You can use, for example, <command>objdump</command>, <command>addr2line</command> or <command>gdb</command> to find out where in the source code of the module this call stack corresponds to (see <xref linkend="analyze_trace"/> for details). 
</para>

<para>
According to the stack trace, those memory blocks were allocated by the calls made from <code>cfake_open()</code> function in the target module. The corresponding call instruction is just before the offset of 0x6e from the beginning of the function in the binary file of the module. Let us find that place with <command>objdump</command> (in fact, it is not really needed in this example as it is already obvious where in the source code are the necessary lines, but still). This will disassemble the target module and store the listing in <filename>module.disasm</filename> file:
</para>

<programlisting><![CDATA[
objdump -dSlr kedr_sample_target.ko > module.disasm
]]></programlisting>

<para>
Look for <code>cfake_open()</code> in the disassembled code and you will find a fragment like this:
</para>

<programlisting><![CDATA[
00000000000002f0 <cfake_open>:
cfake_open():
/home/tester/temp/sample_target/cfake.c:57
static struct class *cfake_class = NULL;
/* ============== */

int 
cfake_open(struct inode *inode, struct file *filp)
{
 2f0:	55                   	push   %rbp
 2f1:	48 89 e5             	mov    %rsp,%rbp
 ...
]]></programlisting>

<para>
As you can see, the offset of <code>cfake_open()</code> in the .text section of the binary file is 0x2f0. The call we look for should be before the offset 0x2f0+0x6e=0x35e, so scroll down to that offset:
</para>

<programlisting><![CDATA[
 350:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
 354:	be d0 80 00 00       	mov    $0x80d0,%esi
 359:	e8 00 00 00 00       	callq  35e <cfake_open+0x6e>
			35a: R_X86_64_PC32	__kmalloc-0x4
cfake_open():
/home/tester/temp/sample_target/cfake.c:85
	
	/* if opened the 1st time, allocate the buffer */
	if (dev->data == NULL)
	{
		dev->data = (unsigned char*)kzalloc(dev->buffer_size, GFP_KERNEL);
		if (dev->data == NULL)
 35e:	48 85 c0             	test   %rax,%rax
]]></programlisting>

<para>
So the <quote>leaked</quote> memory blocks were allocated by the calls to <code>kzalloc()</code> at line 84 of <filename>cfake.c</filename>.
</para>

<para>
When you are done with the reports, you can stop KEDR as usual:
</para>

<programlisting><![CDATA[
/usr/local/bin/kedr stop
]]></programlisting>

</section> <!-- "getting_started.leak_check" -->
<!-- ================================================================ -->


<section id="getting_started.all_at_once">
<title>Doing It All at Once</title>

<para>
Starting from KEDR 0.3, you can perform several kinds of data collection and analysis at once for a given target module. For example, it can be useful to subject the module to fault simulation and use memory leak detection at the same time. Problems in the <quote>error paths</quote> of the kernel modules could not always lead to visible consequences like kernel oopses. Such problems may result in memory leaks as well, which could be harder to detect. KEDR might help in this case too.
</para>

<para>
To enable several kinds of analysis, just specify the appropriate configuration files when starting KEDR. For example, the following command starts KEDR for <filename>kedr_sample_target</filename> as a target with fault simulation and memory leak detection turned on:
</para>

<programlisting><![CDATA[
/usr/local/bin/kedr start kedr_sample_target \
   -f leak_check.conf \
   -f fsim.conf
]]></programlisting>

<para>
It is easy to add call tracing as well if you need it:
</para>

<programlisting><![CDATA[
/usr/local/bin/kedr start kedr_sample_target \
   -f leak_check.conf \
   -f fsim.conf \
   -f callm.conf
]]></programlisting>

</section> <!-- "getting_started.all_at_once" -->
<!-- ================================================================ -->

</section>
