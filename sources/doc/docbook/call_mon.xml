<section id="call_mon">
<title>Call Monitoring (Call Tracing)</title>
    <para>
Call monitoring facilities provided by KEDR allow to collect data about the calls to the functions of interest (target functions) made by a kernel module. In this case, <link linkend="post_handler">post handlers</link> are registered for some set of kernel functions. Each post handler simply output <link linkend="target_function">target function</link>'s arguments and return value to a trace.
    </para>
<note><para>
For some functions <link linkend="post_handler">pre handlers</link> are used instead of the post handlers. This helps to produce correct trace in case of multi-threaded execution (see <xref linkend="happens_before_parameter"/>).
</para></note>
    <para>
This is similar to what <ulink url="http://sourceforge.net/projects/strace/">strace</ulink> 
utility does for user-space applications.
    </para>
    <para>
KEDR contains a set of payload modules intended to perform call monitoring. They collect information about which kernel functions were called by the target module and in what order, about the parameters passed to these functions and about the return values. This information is output to a trace and can then be used by user-space applications in runtime with the help of <link linkend="capture_trace">kedr_capture_trace</link> tool.
    </para>

<para>
The standard payloads modules for call monitoring are built and installed with KEDR by default. If you would like to disable this, set CMake variable <code>KEDR_STANDARD_CALLM_PAYLOADS</code> to <code>OFF</code> when executing CMake before building KEDR:
</para>

<programlisting><![CDATA[
cmake -DKEDR_STANDARD_CALLM_PAYLOADS=OFF <other_options> <path_to_kedr_sources>
]]></programlisting>

    <para>
The format of the output data is similar to the trace format of the <command>ftrace</command> system.
Here is an example of such trace (the header line is shown only for the purpose of description):
    </para>
<programlisting><![CDATA[
  TASK-PID  CPU#  TIMESTAMP   FUNCTION
--------------------------------------------------------------------
insmod-6416 [001] 805.997320: target_session_begins: target module: "kedr_sample_target"
insmod-6416 [001] 805.997615: called___kmalloc: ([<ffffffffa00e70b9>] init+0xb9) 
    arguments: (320, d0), result: ffff8800165a8000
dd-6438     [000] 858.641942: called___kmalloc: ([<ffffffffa01d661e>] core+0x61e) 
    arguments: (4000, d0), result: ffff88001659e000
dd-6438     [000] 858.642074: called_copy_from_user: ([<ffffffffa01d642a>] core+0x42a) 
    arguments: (ffff88001659e000, 000000000137d000, 1), result: 0
...
rmmod-6441  [001] 869.438875: called_kfree: ([<ffffffffa01d60d8>] core+0xd8) 
    arguments: (ffff88001659e000)
rmmod-6441  [001] 869.438879: called_kfree: ([<ffffffffa01d60d8>] core+0xd8) 
    arguments: ((null))
rmmod-6441  [001] 869.438881: called_kfree: ([<ffffffffa01d6108>] core+0x108) 
    arguments: (ffff8800165a8000)
rmmod-6441  [001] 869.438885: target_session_ends: target module: "kedr_sample_target"
]]></programlisting>

    <para>
<code>FUNCTION</code> field has the following format for the records corresponding to the detected function calls:
    </para>

<synopsis>
called_&lt;function-name&gt;: (&lt;call_address&gt;) arguments(&lt;arguments-list&gt;), result:&lt;value-returned&gt;
</synopsis> 

<para>
<code>&lt;call_address&gt;</code> specifies the address of the next instruction after the call to the target function. This field has the following format:
</para>

<synopsis>
[&lt;absolute_address&gt;] &lt;area&gt;+&lt;offset&gt;
</synopsis> 

<para>
<code>&lt;absolute_address&gt;</code> is the absolute address of the instruction immediately following the call in the memory image of the target module. <code>&lt;area&gt;</code> can be <quote>init</quote> or <quote>core</quote>. It is the name of the area containing the executable code of the module (these terms are used by module loader in the Linux kernel). An area may contain one or more sections (ELF sections) of the module. <code>&lt;offset&gt;</code> is the offset of the instruction from the beginning of the area. 
</para>

<para>
If you would like to find the lines in the source code of the target module corresponding to the addresses given in the trace records, see <xref linkend="analyze_trace"/> for details.
</para>

<!--
<note><para>
On some systems, you can see the address fields in the trace records with the contents similar to the following: <code>([&lt;(null)&gt;] not_supported+0x0)</code>. This means that KEDR was unable to obtain the address of the call. This can happen, for example, if the kernel has been built without <code>CONFIG_STACKTRACE</code> or <code>CONFIG_FRAME_POINTER</code> defined. To make debugging of kernel modules (and the kernel proper) easier, it is recommended to rebuild the kernel with these parameters set to <quote>y</quote>.
</para></note>
-->
<para>
A different format is used for marker records indicating loading and unloading of the target module:
</para>

<synopsis>
target_session_&lt;begins|ends&gt;: target_module: "&lt;target-module-name&gt;"
</synopsis> 

    <para>
Only calls to the subset of all kernel functions are detected. This subset however can be easy extended by implementing your own modules (see <xref linkend="custom_callm_payloads"/>). Full list of the payload modules that currently may be used for call monitoring, and the lists of the functions detected by each module are provided in <xref linkend="standard_callm_payloads.functions"></xref>.
    </para>
</section>
