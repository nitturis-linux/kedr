<section id="capture_trace">
<title>Capturing the Trace</title>

<section id="capture_trace.general">
<title>General</title>
<para>
    <command>kedr_capture_trace</command> - a service-like tool to capture the data sent by payload modules to the trace (a special file in debugfs) and store the data in the file specified by the user.
</para>
<para>
    <command>kedr_capture_trace_until_done.sh</command> - a helper script that captures the trace and stores it in the specified file until a message about unloading of the current target module appears in the trace.
</para>
</section>

<section id="capture_trace.syntax">
<title>Usage</title>

<cmdsynopsis>
    <command>kedr_capture_trace start</command>
    <arg choice='plain'><replaceable>file</replaceable></arg>
    <arg><replaceable>debugfs_mount_point</replaceable></arg>
</cmdsynopsis>
<cmdsynopsis>
    <command>kedr_capture_trace stop</command>
</cmdsynopsis>
<cmdsynopsis>
    <command>kedr_capture_trace status</command>
</cmdsynopsis>
<cmdsynopsis>
    <command>kedr_capture_trace_until_done.sh</command>
    <arg choice='plain'><replaceable>file</replaceable></arg>
    <arg><replaceable>debugfs_mount_point</replaceable></arg>
</cmdsynopsis>

</section>
<section id="kedr_capture_trace.options">
<title>Options</title>

<variablelist>
    <varlistentry>
        <term><replaceable>file</replaceable></term>
        <listitem>
            <para>
Path to the file where to store the captured trace. If the file exists, the contents of the trace will be appended to its previous content.
            </para>
        </listitem>
    </varlistentry>
    <varlistentry>
        <term><replaceable>debugfs_mount_point</replaceable></term>
        <listitem>
            <para>
Directory where debugfs filesystem is currently mounted. This filesystem contains the trace file from which the trace will be captured. If this argument is not supplied, it is assumed that the mount point of debugfs filesystem is <filename class="directory">/sys/kernel/debug</filename>.
            </para>
        </listitem>
    </varlistentry>
</variablelist>
</section>
<section id="capture_trace.description">
<title>Description</title>
    <section id="capture_trace.description.start">
    <title>kedr_capture_trace start</title>
        <para>
<command>kedr_capture_trace start</command> starts capturing the output of payload modules and storing it in the file <replaceable>file</replaceable>. Note that all the records captured from the trace and stored in <replaceable>file</replaceable> are deleted from the trace file in debugfs.
        </para>
        <para>
If capturing has already started, <command>kedr_capture_trace start</command> does nothing and returns 1.
        </para>
    </section>

    <section id="capture_trace.description.stop">
    <title>kedr_capture_trace stop</title>
        <para>
<command>kedr_capture_trace stop</command> stops capturing the trace. When this command returns, all trace records will be stored in the specified file.
        </para>
        <para>
If capturing has not started yet, <command>kedr_capture_trace stop</command> does nothing and returns 1.
        </para>
        <note><para>
<command>kedr_capture_trace start</command> should not be called while <command>kedr_capture_trace_until_done.sh</command> is running.
        </para></note>
    </section>
    <section id="capture_trace.description.status">
    <title>kedr_capture_trace status</title>
        <para>
<command>kedr_capture_trace status</command> reports whether capturing is in progress or not. In the future, it will probably also report the path to the file the captured trace is stored in.
        </para>
    </section>
    <section id="capture_trace.description.until_done">
    <title>kedr_capture_trace_until_done.sh</title>
        <para>
<command>kedr_capture_trace_until_done.sh</command> first checks whether <replaceable>file</replaceable> exists. If it is the case and the file already contains the <quote>marker record</quote> indicating that the target module has unloaded followed by no marker record for the loading of the target module, the script ends immidiately. That is, the script does nothing if the target module has already unloaded and has not been loaded again after that.
        </para>
        <para>
If <replaceable>file</replaceable> does not exist, or contains no marker record at all, or the last marker record is not for the unloading of the target, the script starts capturing the trace records and storing them in <replaceable>file</replaceable> (appending to this file). The process that has called this script is blocked until the target module is unloaded (to be exact, until the marker record indicating that the target has unloaded appears in the trace). After that, the script stops capturing and returns.
        </para>
    </section>
</section>
<section id="capture_trace.caveats">
<title>Caveats</title>
    <para>
Because both <command>kedr_capture_trace</command> and <command>kedr_capture_trace_until_done.sh</command> programs actually operate on the same trace file in debugfs, they should not be used simultaneously. That is, do not call <command>kedr_capture_trace_until_done.sh</command> while <command>kedr_capture_trace</command> is in capturing state and do not call <command>kedr_capture_trace start</command> while <command>kedr_capture_trace_until_done.sh</command> is running.
    </para>
</section>
<section id="capture_trace.examples">
<title>Examples</title>
    <para>
See <xref linkend="getting_started.call_monitoring"/>.
    </para>
</section>
</section>