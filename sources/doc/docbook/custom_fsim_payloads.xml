<section id="custom_fsim_payloads">
<title>Writing Custom Payloads for Fault Simulation</title>
    <para>
This section describes how to write a new payload module for fault simulation using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <xref linkend="using_gen"/>.
    </para>
    <para>
The whole infrastructure necessary for building the payload module from the <quote>definition file</quote> is located in <filename class='directory'>custom_payload_fsim</filename> subdirectory in the directory where the examples provided with KEDR are installed. Here are its contents:
<variablelist>
    <varlistentry><term><filename>payload.data</filename></term>
        <listitem>'definition' file to create the payload module</listitem>
    </varlistentry>
    <varlistentry><term><filename>makefile</filename></term>
        <listitem>file for common build infrastructure for <command>make</command> utility</listitem>
    </varlistentry>
    <varlistentry><term><filename>Kbuild</filename></term>
        <listitem>file for building kernel module from C sources</listitem>
    </varlistentry>
    <varlistentry><term><filename class='directory'>templates</filename></term>
        <listitem>directory containing the templates used for generating sources from the 'definition' file</listitem>
    </varlistentry>
</variablelist>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </para>
    <para>
The first and the main step is to rewrite <filename>payload.data</filename> to reflect definitions of your payload module.
    </para>
    <para>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
<variablelist>
    <varlistentry><term>module.name</term>
        <listitem>string, which will be used as module name inside its source files</listitem>
    </varlistentry>
    <varlistentry><term>module.author</term>
        <listitem>author of the module</listitem>
    </varlistentry>
    <varlistentry><term>module.license</term>
        <listitem>license for the module</listitem>
    </varlistentry>
</variablelist>
In addition, the following parameters may be defined at the global level:
<variablelist>
    <varlistentry><term>header</term>
        <listitem>the code (may be multiline) to be inserted before the definition of replacement functions. This code usually contains &apos;#include&apos; directives for header files which define target functions and types of its parameters.</listitem>
    </varlistentry>
</variablelist>
Example of global section of the <filename>payload.data</filename> file:
<programlisting>
# This module processes the calls to kstrdup function.

module.name = payload_fsim_kstrdup
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/string.h&gt;
&lt;&lt;
</programlisting>
    </para>
    <para>
For each <link linkend="target_function">target function</link> the calls to which should be processed, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
<variablelist>
    <varlistentry><term>function.name</term>
        <listitem>name of the target function</listitem>
    </varlistentry>
    <varlistentry><term>returnType</term>
        <listitem>return type of the target function if it is not void, otherwise shouldn't be defined at all</listitem>
    </varlistentry>
    <varlistentry><term>returnsVoid</term>
        <listitem>any non-empty value, if the target function returns void, otherwise should't be defined at all. In the future, this parameter will, probably, not be used, but currently its usage is mandatory for the functions that return void.</listitem>
    </varlistentry>
    <varlistentry><term>arg.type</term>
        <listitem>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</listitem>
    </varlistentry>
    <varlistentry><term>arg.name</term>
        <listitem>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.name</term>
        <listitem>(multi-valued) variable names, which values will be output to the trace. This variables should be accessible in replacement function (see below). At least, one value should be output (otherwise this replacement function is meaningless).</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.type</term>
        <listitem>(multi-valued) types of the values, which will be output into the trace. This types will be used for casting the values of the corresponding variables before they will be output (so, these types may differ from the real types of variables).</listitem>
    </varlistentry>
    <varlistentry><term>trace.formatString</term>
        <listitem>format string which is used for printf-like output values from replacement function (see parameters <quote>trace.param.name</quote> and <quote>trace.param.type</quote>)</listitem>
    </varlistentry>
</variablelist>
    </para>
    <para>
Until this moment, only parameters which are also used for the payload modules for call monitoring have been described (see <xref linkend="custom_callm_payloads"/>). These parameters have almost the same meaning for the payload modules for fault simulation (these modules extend the functionality of call monitoring payloads). Listed below are the parameters that are meaningful only for fault simulation:
    </para>
    <para>
<variablelist>
    <varlistentry><term>fpoint.error_code</term>
        <listitem>code (may be multiline) which should be executed instead the call to the target function to simulate failure of the latter. Usually, this code simply sets <varname>returnValue</varname> variable which will be returned to the caller to indicate that a failure has occured.</listitem>
    </varlistentry>
    <varlistentry><term>fpoint.param.name</term>
        <listitem>(multi-valued) names of the variables which values will be passed to the indicator function and may be used to specify the scenario of fault simulation in it. The order of these variables is important, because they will be passed sequentially to the indicator function. Usually, only the parameters of the target function are passed to the indicator.</listitem>
    </varlistentry>
    <varlistentry><term>fpoint.param.type</term>
        <listitem>(multi-valued) types of the values that will be passed to the indicator function. These types will be used to properly cast the values before passing to the indicator (so these types may differ from the real types of the variables).</listitem>
    </varlistentry>
</variablelist>

    </para>
    <para>
Additionally, the following parameters can be defined at the group level. They are similar to the ones used in the payload modules for call monitoring. The differences concerning fault simulation are also described below.
<variablelist>
    <varlistentry><term>prologue</term>
        <listitem>code (may be multiline) which will be inserted at the start of replacement function (before the call to the indicator function which should decide whether need to simulate a failure or not). Usually, this code declares variables that will be used in the output, will be passed to the indicator function or used by the following code sections (see below).</listitem>
    </varlistentry>
    <varlistentry><term>middleCode</term>
        <listitem>code (may be multiline) which may calculate data for output. Variables can not be declared there. Note, that this code is placed after the call to the indicator function and after the possible call to the target function (or the error-path). Therefore, <code>middleCode</code> cannot affect the behaviour of these parts of the replacement function. Its intended usage it to prepare the data to the output to the trace: calculate the necessary values, etc.</listitem>
    </varlistentry>
    <varlistentry><term>epilogue</term>
        <listitem>code (may be multiline) which will be inserted at the end of the replacement function (after the values are output to the trace). If <code>prologue</code> or <code>middleCode</code> request some resources from the kernel, this code can be used to release these resources.</listitem>
    </varlistentry>
</variablelist>
Visibility of variables in different parts of code of the replacement function may be described in pseudocode as follows:
<programlisting>
<symbol>returnType</symbol> replacement_function(<symbol>arg.name</symbol>...)
{
    <symbol>prologue</symbol>
    {
        <symbol>returnType</symbol> <varname>returnValue</varname>;
        if(indicator_function(<symbol>fpoint.param.name</symbol>...) == 0)
        {
            <varname>returnValue</varname> = target_function(<symbol>arg.name</symbol>...);
        }
        else
        {
            <symbol>fpoint.error_code</symbol>;
        }
        <symbol>middleCode</symbol>
        output(<symbol>trace.formatString</symbol>, <symbol>trace.param.name</symbol>...);
    }
    <symbol>epilogue</symbol>
}
</programlisting>
If the target function does not return void, variable <varname>returnValue</varname> can be used as name of variable to output (<symbol>arg.name</symbol>) and in the <symbol>middleCode</symbol>. Also, this variable should be assigned in the <symbol>fpoint.error_code</symbol> (otherwise it will not be initialized if the failure of the target function is simulated).
    </para>
    <para>
Here is an example of the group section for __kmalloc target function. Note the definition of <code>fpoint.fault_code</code> parameter. Its value is <quote><code>returnValue = NULL;</code></quote> because '=' characters after the leftmost one have no special meaning and are treated as the part of the value.
    </para>
    
<programlisting>
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for __kmalloc().
</programlisting>

<para>
Example of the group section for kstrdup() target function:
<programlisting>
[group]
    # Name and return type of the target function
    function.name = kstrdup
    returnType = char*

    # Names and types of the arguments of the target function
    arg.type = const char*
    arg.name = str
    
    arg.type = gfp_t
    arg.name = flags

    # Calculate length of the string
    prologue = size_t len = strlen(str);

    # The parameters to be output to the trace.
    trace.param.type = size_t
    trace.param.name = len

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (strlen=%zu, flags=%x), result: %p"

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = len

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for kstrdup().
</programlisting>
    </para>
    <para>
Note the usage of <varname>len</varname> variable for fault simulation in the example above. This value is calculated in the prologue based on the target function parameter <varname>str</varname> and is then used as one of the parameters to be passed to the fault simulation indicator.
    </para>
    <para>
It is possible for different replacement functions to share the same indicator function (and, therefore, share the scenario). This is more than simply using the same indicator functions, this is using a single instance of an indicator. These functions may use some data private for each indicator instance. In case if sharing, this data will be also shared.
    </para>
    <para>
Sharing of the indicator functions can be useful, for example, for the target functions that are known to use a common mechanism internally (e.g. memory allocator), and you want to simulate a failure of this mechanism.
    </para>
    <para>
If, say, function <function>g</function> should share the fault simulation scenario with <function>f</function>, you should define parameter <symbol>fpoint.reuse_point</symbol> in the group of function <function>g</function> with value <code>f</code>. In this case, the group for function <function>f</function> should precede the group for function <function>g</function>. Example of sharing a fault simulation scenario for <function>__kmalloc</function> and <function>krealloc</function>:
<programlisting>
    ...
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    ...
    
    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;
    
# End of the group of definitions for __kmalloc().

[group]
    # Name and return type of the target function
    function.name = krealloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = const void*
    arg.name = p

    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    ... 

    # Fault Simulation
    <emphasis>fpoint.reuse_point = __kmalloc</emphasis>

    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for krealloc().
</programlisting>
Note that in the group for <function>krealloc</function> function, we use the same names and types of the variables intended to be passed to the indicator function, as for <function>__kmalloc</function>.
    </para>
    <para>
After writing <filename>payload.data</filename> file, you can change the value of module_name variable in the <filename>makefile</filename> and <filename>Kbuild</filename> according to the one you use as value of <quote>module.name</quote> parameter. In the future, this step may be implemented in the <filename>makefile</filename> itself.
    </para>
    <para>
The last step is to run <command>make</command> utility. This will invoke the code generator tool (<command>kedr_gen</command>) to create the sources for your payload module, then the module will be built.
    </para>

</section>
