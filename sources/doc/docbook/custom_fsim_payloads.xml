<section id="custom_fsim_payloads">
<title>Writing Custom Payloads for Fault Simulation</title>

    <para>
This is a description, how to write new payload module for fault simulation, using KEDR tool for generation files from templates. Common abilities of this tool are detailed descibed in <xref linkend="using_gen"/> ...
    </para>
    <para>
Whole infrastructure, which is needed for building payload module from 'definition' file is located in <filename class='directory'>custom_payload_fsim</filename> directory under installed expamples. Here is its content:
<variablelist>
    <varlistentry><term><filename>payload.data</filename></term>
        <listitem>'definition' file for creating payload</listitem>
    </varlistentry>
    <varlistentry><term><filename>makefile</filename></term>
        <listitem>file for common build infrastructure for <command>make</command> utility</listitem>
    </varlistentry>
    <varlistentry><term><filename>Kbuild</filename></term>
        <listitem>file for building kernel module from c-sources</listitem>
    </varlistentry>
    <varlistentry><term><filename class='directory'>templates</filename></term>
        <listitem>directory which contatin templates files, used for generating sources from 'definition' file</listitem>
    </varlistentry>
</variablelist>
Copy contents of this directory into you own place.
    </para>
    <para>
The first, and the main step - rewrite <filename>payload.data</filename> for reflecting definitions of you own payload module.
    </para>
    <para>
At global level (not inside groups) this file should contain definitions for next parameters:
<variablelist>
    <varlistentry><term>module.name</term>
        <listitem>string, which will be used as module name inside its source files</listitem>
    </varlistentry>
    <varlistentry><term>module.author</term>
        <listitem>author of the module</listitem>
    </varlistentry>
    <varlistentry><term>module.licence</term>
        <listitem>licence for the module</listitem>
    </varlistentry>
</variablelist>
Additionally, next parameters may be defined at global level:
<variablelist>
    <varlistentry><term>header</term>
        <listitem>code (may be multi lined), which will be inserted before definition of replacement functions. Usually, this code contains '#include' directives, for header files which define target functions and types of its parameters.</listitem>
    </varlistentry>
</variablelist>
Example of global section of the <filename>payload.data</filename>:
<programlisting>
# This module processes the calls to kstrdup function.

module.name = payload_fsim_kstrdup
module.author = Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/string.h&gt;
&lt;&lt;
</programlisting>
    </para>
    <para>
For each target function, which is intended to replace, group should be defined.
Each group should contain definitions for next parameters:
<variablelist>
    <varlistentry><term>function.name</term>
        <listitem>name of the target function, which should replaced</listitem>
    </varlistentry>
    <varlistentry><term>returnType</term>
        <listitem>returning type of the target function, if it returns non-void, otherwise shouldn't be assigned at all</listitem>
    </varlistentry>
    <varlistentry><term>returnsVoid</term>
        <listitem>any non-empty value, if the target function returns void, otherwise should't be assigned at all. In the future, probably, this parameter will not be used, but currently its usage is mandatory for void functions.</listitem>
    </varlistentry>
    <varlistentry><term>arg.type</term>
        <listitem>types (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all.</listitem>
    </varlistentry>
    <varlistentry><term>arg.name</term>
        <listitem>names (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.name</term>
        <listitem>variable names (multi-value), which values will be output into the trace. This variables should be accessible in replacement function(see below). At least, one value should be output (otherwise this replacement function is meaningless).</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.type</term>
        <listitem>types (multi-value) of the values, which will be output into the trace. This types will be used in casting values before they will be output(so, these types may differ from real type of variables, which values are used to output).</listitem>
    </varlistentry>
    <varlistentry><term>trace.formatString</term>
        <listitem>format string which is used for printf-like output values from replacement function (see parameters <quote>trace.param.name</quote> and <quote>trace.param.type</quote>)</listitem>
    </varlistentry>
</variablelist>
Until that moment, only parameters which are also used for call monitor payload has described (see <xref linkend="custom_callm_payloads"/>). And these parameters have almost the same meaning for fault simulation payload, because it extend functionality of call monitor payload. Next, parameters which has meaning only for fault simulation:
<variablelist>
    <varlistentry><term>fpoint.error_code</term>
        <listitem>code (may be multi line), which should be executed instead call of the target function for simulate target function failure. Usually, this code simply set <varname>returnValue</varname> variable, which will be returned to the caller, for signal that failure occures.</listitem>
    </varlistentry>
    <varlistentry><term>fpoint.param.name</term>
        <listitem>variable names (multi-value), which values will be passed to the indicator function, and may be used for determine scenario of fault simulation in it. Order of these variables make a sence, because them will be passed sequentially to the indicator function. Usually, only parameters of the target function are passed to the indicator.</listitem>
    </varlistentry>
    <varlistentry><term>fpoint.param.type</term>
        <listitem>types (multi-value) of the values, which values will be passed to the indicator function. This types will be used for casting variables' values before passing (so, these types may differ from real type of variables).</listitem>
    </varlistentry>
</variablelist>

Additionally, next parameters may be defined at group level. Them similar to the ones for call monitor payload, but may have additional work load for fault simulation facility.
<variablelist>
    <varlistentry><term>prologue</term>
        <listitem>code (may be multi lined) which will be inserted to the start of replacement function (before call indicator function, which should decide, whether need to simulate or not). May use variable declarations. Usually, this code declare variables, which will be used in output, passed to the indicator function or used by the next code sections (see below).</listitem>
    </varlistentry>
    <varlistentry><term>middleCode</term>
        <listitem>code (may be multi lined) which may calculate data for output. May not use variable declarations. Note, that this code will be executed after indicator function and possible target function call or executing error-path, and so cannot change their behaviour.</listitem>
    </varlistentry>
    <varlistentry><term>epilogue</term>
        <listitem>code (may be multi lined) which will be inserted at the end of replacement function (after output values). If <code>prologue</code> or <code>middleCode</code> requests some resources from the kernel, this code may be used for returning this resources back.</listitem>
    </varlistentry>
</variablelist>
Visibility of variables in different parts of code of the replacement function may be described as pseudocode:
<programlisting>
<symbol>returnType</symbol> replacement_function(<symbol>arg.name</symbol>...)
{
    <symbol>prologue</symbol>
    {
        <symbol>returnType</symbol> <varname>returnValue</varname>;
        if(indicator_function(<symbol>fpoint.param.name</symbol>...) == 0)
        {
            <varname>returnValue</varname> = target_function(<symbol>arg.name</symbol>...);
        }
        else
        {
            <symbol>fpoint.error_code</symbol>;
        }
        <symbol>middleCode</symbol>
        output(<symbol>trace.formatString</symbol>, <symbol>trace.param.name</symbol>...);
    }
    <symbol>epilogue</symbol>
}
</programlisting>
If target function return non-void value, variable <varname>returnValue</varname> may be used as name of variable to output (<symbol>arg.name</symbol>) and in the <symbol>middleCode</symbol>. Also, this variable should be assigned in the <symbol>fpoint.error_code</symbol>.
    </para>
    <para>
Example of the group section for __kmalloc target function:
<programlisting>
[group]
	# Name and return type of the target function
	function.name = __kmalloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
	# The parameters to be output to the trace. 
	trace.param.type = size_t
	trace.param.name = size

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (%zu, %x), result: %p"

	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code =	returnValue = NULL;

# End of the group of definitions for __kmalloc().
</programlisting>
Example of the group section for kstrdup() target function (note using <varname>len</varname> variable for fault simulation as derived parameter from target function parameter <varname>str</varname>):
<programlisting>
[group]
	# Name and return type of the target function
	function.name = kstrdup
	returnType = char*

	# Names and types of the arguments of the target function
	arg.type = const char*
	arg.name = str
	
	arg.type = gfp_t
	arg.name = flags

	# Calculate length of the string
	prologue = size_t len = strlen(str);

	# The parameters to be output to the trace.
	trace.param.type = size_t
	trace.param.name = len

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (strlen=%zu, flags=%x), result: %p"

	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = len

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code =	returnValue = NULL;

# End of the group of definitions for kstrdup().
</programlisting>
    </para>
    <para>
There is an ability to different replacement functions to share same indicator function (and, therefore, share scenario). This is more than simple using same indicator functions, because this functions may use some data, which is privare for each indicator instance. In the case if sharing, these indicator function' s data will be also sharing.
    </para>
    <para>
Such sharing indicator function may be used, e.g., for target functions, which is known to use internally some common mechanism, and you want to simulate fail of this mechanism.
    </para>
    <para>
For say, that function <function>g</function> should share fault simulation scenario with <function>f</function>, you should assign parameter <symbol>fpoint.reuse_point</symbol> for group of function <function>g</function> to <code>f</code>. In this case, group definition of function <function>f</function> should precede the group definition of function <function>g</function>. Example of sharing fault simulation scenario for <function>__kmalloc</function> and <function>krealloc</function>:
<programlisting>
    ...
[group]
	# Name and return type of the target function
	function.name = __kmalloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
    ...
    
	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code = returnValue = NULL;
    
# End of the group of definitions for __kmalloc().

[group]
	# Name and return type of the target function
	function.name = krealloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = const void*
	arg.name = p

	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
    ...	

	# Fault Simulation
	<emphasis>fpoint.reuse_point = __kmalloc</emphasis>

	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for krealloc().
</programlisting>
Note, that in group definition for <function>krealloc</function> function we use same names and types for variables, which is intended to pass to indicator function, as for <function>__kmaloc</function>.
    </para>
    <para>
After writing <filename>payload.data</filename> file, you may rewrite value of module_name variable in the <filename>makefile</filename> and <filename>Kbuild</filename> according to one you use as value of <quote>module.name</quote> parameter. In the future, this step may be implemented in the <filename>makefile</filename> itself.
    </para>
Next, and the last step is running <command>make</command> utility. It generate sources for payload module, and then build this module. That is all.
    <para>
    </para>

</section>
