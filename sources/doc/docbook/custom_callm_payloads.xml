<section id="custom_callm_payloads">
<title>Writing Custom Payloads for Call Monitoring</title>
    <para>
This section describes how to write a new payload module for call monitoring using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <xref linkend="using_gen"/>.
    </para>
    <para>
The whole infrastructure necessary for building the payload module from the <quote>definition file</quote> is located in <filename class='directory'>custom_payload_callm</filename> subdirectory in the directory where the examples provided with KEDR are installed. Here are its contents:
<variablelist>
    <varlistentry><term><filename>payload.data</filename></term>
        <listitem>'definition' file to create the payload module</listitem>
    </varlistentry>
    <varlistentry><term><filename>makefile</filename></term>
        <listitem>file for common build infrastructure for <command>make</command> utility</listitem>
    </varlistentry>
    <varlistentry><term><filename>Kbuild</filename></term>
        <listitem>file for building kernel module from C sources</listitem>
    </varlistentry>
    <varlistentry><term><filename class='directory'>templates</filename></term>
        <listitem>directory containing the templates used for generating sources from the 'definition' file</listitem>
    </varlistentry>
</variablelist>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </para>
    <para>
The first and the main step is to rewrite <filename>payload.data</filename> to reflect definitions of your payload module.
    </para>
    <para>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
<variablelist>
    <varlistentry><term>module.name</term>
        <listitem>string, which will be used as module name inside its source files</listitem>
    </varlistentry>
    <varlistentry><term>module.author</term>
        <listitem>author of the module</listitem>
    </varlistentry>
    <varlistentry><term>module.license</term>
        <listitem>license for the module</listitem>
    </varlistentry>
</variablelist>
In addition, the following parameters may be defined at the global level:
<variablelist>
    <varlistentry><term>header</term>
        <listitem>the code (may be multiline) to be inserted before the definition of replacement functions. This code usually contains &apos;#include&apos; directives for header files which define target functions and types of its parameters.</listitem>
    </varlistentry>
</variablelist>
Example of global section of the <filename>payload.data</filename> file:
<programlisting>
# This module processes the calls to module_put function.

module.name = payload_callm_module_put
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/module.h&gt;
&lt;&lt;
</programlisting>
    </para>
    <para>
For each <link linkend="target_function">target function</link> the calls to which should be processed, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
<variablelist>
    <varlistentry><term>function.name</term>
        <listitem>name of the target function</listitem>
    </varlistentry>
    <varlistentry><term>returnType</term>
        <listitem>return type of the target function if it is not void, otherwise shouldn't be defined at all</listitem>
    </varlistentry>
    <varlistentry><term>returnsVoid</term>
        <listitem>any non-empty value, if the target function returns void, otherwise should't be defined at all. In the future, this parameter will, probably, not be used, but currently its usage is mandatory for the functions that return void.</listitem>
    </varlistentry>
    <varlistentry><term>arg.type</term>
        <listitem>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</listitem>
    </varlistentry>
    <varlistentry><term>arg.name</term>
        <listitem>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.name</term>
        <listitem>(multi-valued) variable names, which values will be output to the trace. This variables should be accessible in replacement function (see below). At least, one value should be output (otherwise this replacement function is meaningless).</listitem>
    </varlistentry>
    <varlistentry><term>trace.param.type</term>
        <listitem>(multi-valued) types of the values, which will be output into the trace. This types will be used for casting the values of the corresponding variables before they will be output (so, these types may differ from the real types of variables).</listitem>
    </varlistentry>
    <varlistentry><term>trace.formatString</term>
        <listitem>format string which is used for printf-like output of values from replacement function (see parameters <quote>trace.param.name</quote> and <quote>trace.param.type</quote>)</listitem>
    </varlistentry>
</variablelist>
Additionally, the following parameters can be defined at group level:
<variablelist>
    <varlistentry><term>prologue</term>
        <listitem>code (may be multiline) which will be inserted at the start of replacement function (before the call to target function). Usually, this code declares variables which will be used in output and the following code sections (see below).</listitem>
    </varlistentry>
    <varlistentry><term>middleCode</term>
        <listitem>code (may be multiline) which will be inserted after call to the target function and before the output of values to the trace. Variables can not be declared there. Usually, this code calculates the values of the variables if it is necessary before the output to the trace is done.</listitem>
    </varlistentry>
    <varlistentry><term>epilogue</term>
        <listitem>code (may be multiline) which will be inserted at the end of the replacement function (after the values are output to the trace). If <code>prologue</code> or <code>middleCode</code> request some resources from the kernel, this code can be used to release these resources.</listitem>
    </varlistentry>
</variablelist>
Visibility of variables in different parts of code of the replacement function can be described in pseudocode as follows:
<programlisting>
<symbol>returnType</symbol> replacement_function(<symbol>arg.name</symbol>...)
{
    <symbol>prologue</symbol>
    {
        <symbol>returnType</symbol> <varname>returnValue</varname> = target_function(<symbol>arg.name</symbol>...);
        <symbol>middleCode</symbol>
        output(<symbol>trace.formatString</symbol>, <symbol>trace.param.name</symbol>...);
    }
    <symbol>epilogue</symbol>
}
</programlisting>
If the target function does not return void, variable <varname>returnValue</varname> may be used as the name of variable to output (<symbol>arg.name</symbol>) and in the <symbol>middleCode</symbol>.
    </para>
    <para>
Example of the group section for module_put() target function:
<programlisting>
[group]
    # Name and return type of the target function
    function.name = module_put
    returnsVoid = yes

    # Names and types of the arguments of the target function
    arg.type = struct module*
    arg.name = m
    
    # The parameters to be output to the trace. 
    trace.param.type = void*
    trace.param.name = m

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%p)"

# End of the group of definitions for module_put().
</programlisting>
Example of the group section for __kmalloc() target function (note the usage of <varname>returnValue</varname> variable as the value of <code>trace.param.name</code> parameter):
<programlisting>
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for __kmalloc().
</programlisting>
Example of the group section for kmem_cache_alloc() target function (note the contents of <symbol>prologue</symbol> parameter):
<programlisting>
    [group]
    # Name and return type of the target function
    function.name = kmem_cache_alloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = struct kmem_cache*
    arg.name = mc
    
    arg.type = gfp_t
    arg.name = flags
    
    prologue =&gt;&gt;
size_t size = kmem_cache_size(mc);
&lt;&lt;
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for kmem_cache_alloc().
</programlisting>
    </para>
    <para>
As you can see, kmem_cache_alloc() function does not have <code>size</code> argument. If we still want to output the size of the requested memory block to the trace, we need to determine it within the replacement function. This is exactly what is done in the prologue code above.
    </para>
        
    <para>
After writing <filename>payload.data</filename> file, you can change the value of module_name variable in the <filename>makefile</filename> and <filename>Kbuild</filename> according to the one you use as value of <quote>module.name</quote> parameter. In the future, this step may be implemented in the <filename>makefile</filename> itself.
    </para>
    <para>
The last step is to run <command>make</command> utility. This will invoke the code generator tool (<command>kedr_gen</command>) to create the sources for your payload module, then the module will be built.
    </para>
</section>
