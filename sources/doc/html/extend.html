<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>5. Customizing and Extending KEDR</title><link rel="stylesheet" href="kedr-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="prev" href="using_kedr.html" title="4. Using KEDR"><link rel="next" href="reference.html" title="6. KEDR Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Customizing and Extending KEDR</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="using_kedr.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr></table><hr></div><div class="section" title="5. Customizing and Extending KEDR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extend"></a>5. Customizing and Extending KEDR</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="extend.html#using_gen">5.1. Using Generator for create custom modules</a></span></dt><dt><span class="section"><a href="extend.html#custom_callm_payloads">5.2. Writing Custom Payloads for Call Monitoring</a></span></dt><dt><span class="section"><a href="extend.html#custom_fsim_payloads">5.3. Writing Custom Payloads for Fault Simulation</a></span></dt><dt><span class="section"><a href="extend.html#custom_fsim_scenarios">5.4. Writing Custom Scenarios for Fault Simulation</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis">5.5. Implementing Custom Types of Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="extend.html#custom_analysis.basics">5.5.1. Choosing the Counters and the Functions to Process</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.payload">5.5.2. Creating the Payload Module</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.build">5.5.3. Building the Payload Module</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.use">5.5.4. Using the Payload Module</a></span></dt></dl></dd></dl></div><div class="section" title="5.1. Using Generator for create custom modules"><div class="titlepage"><div><div><h3 class="title"><a name="using_gen"></a>5.1. Using Generator for create custom modules</h3></div></div></div><p>
For creating multiple modules with simular functionality, KEDR actively use generation of files from templates. This approach makes it possible to split implementation of such modules into general implementation of the modules functionality and definition of the specific functionality of each module.
    </p><p>
So, implementation of the new module requires only to write short definition of what this module is supposed to do in extent of the base functionality. Creation of source file(s) for this module will be performed automatically by <span class="quote">“<span class="quote">generator</span>”</span>.
    </p><p>
Aside from using this mechanizm inside KEDR, it may be used for creating custom specialized modules for different purposes: call monitor payloads, fault simulation payloads, fault simulation indicators. This way for create custom modules has many advantages:
</p><div class="variablelist"><dl><dt><span class="term">it fast</span></dt><dd>e.g., implementation of new call monitor payload require about 10 lines in 'definition' file for 'header' (it contain name of module, which will be generated, author, license...) , and about 10 lines for every replacement function (description of function arguments, and format of how them should be stored in the string)</dd><dt><span class="term">it clear</span></dt><dd>all features of your module are described in one place (not scattered over different files or over one long file); every line in the 'definition' file is self explanatory</dd><dt><span class="term">it use high level of abstraction</span></dt><dd>while writing 'definition' file, you shouldn't be aware of what file(s) will be generating from them, and how exactly one or another feature will be implemented</dd><dt><span class="term">it error free</span></dt><dd>If 'definition' file is written correctly, it should generate correct code of the module; the most lines in the 'definition' file simply introduce names of some essences - such lines are always correct; rare interline dependencies may be easy debugged in clear and short 'definition' file, same for rare code chunks definitions.</dd><dt><span class="term">it produce easy updatable modules</span></dt><dd>If templates is updated to implement some new base functionality, or to change implementation, or to fix some errors, simple call 'generator' with new templates will update you module.</dd></dl></div><p>
    </p><p>
Of course, using 'generator' is not an universal means for extending functionality of standard KEDR modules. If some functionality extension is not provided by the templates, it cannot be implemented in this way. But if it is, it is recommended to use 'generator'.
    </p><p>
Next, describe common format of 'definition' file. 'Generator' is based on MiST Engine library from <a class="ulink" href="http://template2code.sourceforge.net" target="_top"><em class="citetitle">Template2Code 
project</em></a>, and is very similar to 'mist_gen' example from it. As result, format of the 'definition' file, accepted by the 'generator', is the same as format of the configuration file, accepted by 'mist_gen'. Last format is fully described <a class="ulink" href="http://template2code.sourceforge.net/mist-doc/param.html" target="_top"><em class="citetitle">here</em></a>. The only one difference - 'definition' file may contatin strings <code class="code">[block]</code>, which introduce additional division of file by blocks.
    </p><p>
Every 'definition' file is treated as array of lines. Lines which contain only white space characters (spaces and tabs) and lines, which first non-whitespace character is <code class="code">#</code> are ignored:
    </p><pre class="programlisting">
# Next line is empty, so it will be ignored

    # This line will be ignored too.
    </pre><p>
Lines like 
    </p><pre class="programlisting">
&lt;parameter-name&gt; = &lt;value&gt;
    </pre><p>
define parameter with name <code class="code">&lt;parameter-name&gt;</code> and assign string <code class="code">&lt;value&gt;</code> to it. Only one restriction on <code class="code">&lt;parameter-name&gt;</code> - is shouldn't contain whitespace characters. Whitespace characters surrounding <code class="code">&lt;parameter-name&gt;</code> and <code class="code">&lt;value&gt;</code> are ignored.
    </p><pre class="programlisting">
# Define parameter with name 'a' to '135'
a = 135
# Define parameter with name 'b' to 'some string'
b = some string
# Define parameter with name 'expression' to '2 + 3 = 5'
expression = 2 + 3 = 5
    </pre><p>
There is a way to define parameter with long value:
    </p><pre class="programlisting">
# Define parameter with name 'long-string' to 'string1 string2 string3'
# Note, that leading whitespace characters are ignored.
long-string = string1 \
    string2 \
    string3
    </pre><p>
Also, parameters with multiline value may be defined:
    </p><pre class="programlisting">
multi-line-parameter =&lt;&lt;
    line1
    line2
    ...
    lineN
&gt;&gt;
    </pre><p>
Value of 'multi-line-parameter' is precisely
    </p><pre class="programlisting">
    line1
    line2
    ...
    lineN
    </pre><p>
Note, that new-line character should follow immidiatly after <code class="code">&lt;&lt;</code> delimiter, and delimiter <code class="code">&gt;&gt;</code> should be  the only one on the line except whitespace characters.
    </p><pre class="programlisting">
# Correct definition of multiline parameter, contained &gt;&gt;
multi-line-parameter =&lt;&lt;
    &lt;&lt;a&gt;&gt;
    &lt;&lt;b&gt;&gt;
    &gt;&gt;
    </pre><p>
    </p><p>
The only information, which generator extracts from 'definition' file, is set of parameters with assigned values. Order of this parameters in the file has no sence, so 'definition' files
    </p><pre class="programlisting">
a = 5
b = 10
    </pre><p>
and
    </p><pre class="programlisting">
b = 10
a = 5
    </pre><p>
means efficiently the same: <code class="code">a='5', b='10'</code>.
    </p><p>
But when several definitions assign values to the same parameter, parameter became multi-valued, and order of the assignments become valuable.
    </p><pre class="programlisting">
a = 5
a = 10
    </pre><p>
means <code class="code">a={'5','10'}</code>, but
    </p><pre class="programlisting">
a = 10
a = 5
    </pre><p>
means <code class="code">a={'10','5'}</code>. Depended on the meaning of the parameter,  difference in order of assignments to it may have sence (e.g, order of the function parameters is critical), or may not (e.g. order of the replacement functions in the file)
    </p><p>
As a rule, order between two multi-valued parameters assignments make a sence only in case, when these parameters describe one-value attributes of same object:
    </p><pre class="programlisting">
obj.name = object1
obj.description = This is object1
obj.name = object2
obj.description = This is object2
    </pre><p>
define <code class="code">obj.name</code> as 
<span class="simplelist">object1, object2</span>,
 <code class="code">obj.description</code> as
 <span class="simplelist">This is object1, This is object2</span>,
and this may meen two object instances with attributes
 <span class="simplelist">object1, This is object1</span> and 
<span class="simplelist">object2, This is object2</span>
    </p><pre class="programlisting">
obj.name = object1
obj.description = This is object2
obj.name = object2
obj.description = This is object1
    </pre><p>
define <code class="code">obj.name</code> as 
<span class="simplelist">object1, object2</span>,
 <code class="code">obj.description</code> as
<span class="simplelist">This is object2, This is object1</span>,
and this may meen two object instances with attributes
<span class="simplelist">object1, This is object2</span> and 
<span class="simplelist">object2, This is object1</span>,
which probably is not what you want. Simple way to not get confused in ordering - define all attributes for one instance, and only then define attributes for another one.
    </p><p>
If some object has non-constant set of attributes (e.g., one of its attribute may have multiple values, or one of its attribute is optional), then you cannot define several instances of this object in one 'definition' file. This is because generator cannot determine, which instance has particular value of attribute. For this case, <code class="code">[group]</code> keyword was introduced into 'definition' file format. This keyword introduce new group of definitions, which starts just after this keyword, and ends before the next occurence of same keyword, or at the end of the file.
</p><pre class="programlisting">
module_name = Arrays
[group]
array.name = array1
array.values = val1
[group]
array.name = array2
array.values = val2
array.values = val3
[group]
array.name = array3
    </pre><p>
There are 3 groups in this file. First define <code class="code">array.name='array1'</code> and <code class="code">array.values='val1'</code>, second - <code class="code">array.name='array2'</code> and <code class="code">array.values={'val2', 'val3'}</code>, third - <code class="code">array.name='array3'</code>. Each group may be interpret as array object, object <code class="code">array1</code> contains one element <code class="code">val1</code>, object <code class="code">array2</code> contains two elements <code class="code">val2</code> and <code class="code">val3</code>, object <code class="code">array3</code> contains none elements.
    </p><p>
<code class="code">[group]</code> keyword doesn't cancelling gathering of all parameters assignments - global meaning of this file is <code class="code">module_name='Arrays'</code>, <code class="code">array.name={'array1', 'array2', 'array3'}</code> and <code class="code">array.values={'val1', 'val2', val3'}</code>. And this infomation will be processed by the generator, using one set of templates. But also information for every group will be processed, using another set of templates. And this processing will result in new multi value parameter, which values are results of particular group processing. This parameter is reffered as 'block', as the set of templates, used for its generation. And it may be used at the top level of processing, set of templates for which is reffered as 'document'.
    </p><p>
This is a basic information, which is needed for write you own 'definition' files for custom modules with KEDR templates. For more information - see documentation on 'generator'.
    </p></div><div class="section" title="5.2. Writing Custom Payloads for Call Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="custom_callm_payloads"></a>5.2. Writing Custom Payloads for Call Monitoring</h3></div></div></div><p>
This is a description, how to write new payload module for call monitoring, using KEDR tool for generation files from templates. Common abilities of this tool are detailed descibed in <a class="xref" href="extend.html#using_gen" title="5.1. Using Generator for create custom modules">Section 5.1, “Using Generator for create custom modules”</a> ...
    </p><p>
Whole infrastructure, which is needed for building payload module from 'definition' file is located in <code class="filename">custom_payload_callm</code> directory under installed expamples. Here is its content:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file for creating payload</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from c-sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory which contatin templates files, used for generating sources from 'definition' file</dd></dl></div><p>
Copy contents of this directory into you own place.
    </p><p>
The first, and the main step - rewrite <code class="filename">payload.data</code> for reflecting definitions of you own payload module.
    </p><p>
At global level (not inside groups) this file should contain definitions for next parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.licence</span></dt><dd>licence for the module</dd></dl></div><p>
Additionally, next parameters may be defined at global level:
</p><div class="variablelist"><dl><dt><span class="term">header</span></dt><dd>code (may be multi lined), which will be inserted before definition of replacement functions. Usually, this code contains '#include' directives, for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code>:
    </p><pre class="programlisting">
# This module processes the calls to module_put function.

module.name = payload_callm_module_put
module.author = Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/module.h&gt;
&lt;&lt;
    </pre><p>
    </p><p>
For each target function, which is intended to replace, group should be defined.
Each group should contain definitions for next parameters:
</p><div class="variablelist"><dl><dt><span class="term">function.name</span></dt><dd>name of the target function, which should replaced</dd><dt><span class="term">returnType</span></dt><dd>returning type of the target function, if it returns non-void, otherwise shouldn't be assigned at all</dd><dt><span class="term">returnsVoid</span></dt><dd>any non-empty value, if the target function returns void, otherwise should't be assigned at all. In the future, probably, this parameter will not be used, but currently its usage is mandatory for void functions.</dd><dt><span class="term">arg.type</span></dt><dd>types (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>names (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</dd><dt><span class="term">trace.param.name</span></dt><dd>variable names (multi-value), which values will be output into the trace. This variables should be accessible in replacement function(see below). At least, one value should be output (otherwise this replacement function is meaningless).</dd><dt><span class="term">trace.param.type</span></dt><dd>types (multi-value) of the values, which will be output into the trace. This types will be used for casting variable values before they will be output(so, these types may differ from real type of variables).</dd><dt><span class="term">trace.formatString</span></dt><dd>format string which is used for printf-like output values from replacement function (see parameters <span class="quote">“<span class="quote">trace.param.name</span>”</span> and <span class="quote">“<span class="quote">trace.param.type</span>”</span>)</dd></dl></div><p>
Additionally, next parameters may be defined at group level:
</p><div class="variablelist"><dl><dt><span class="term">prologue</span></dt><dd>code (may be multi lined) which will be inserted to the start of replacement function (before call of target function). May use variable declarations. Usually, this code declare variables, which will be used in output and next code sections (see below).</dd><dt><span class="term">middleCode</span></dt><dd>code (may be multi lined) which will be inserted after call of the target function and before output variables. May not use variable declarations. Usually, this code calculate variables, which will be used in output.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multi lined) which will be inserted at the end of replacement function (after output values). If <code class="code">prologue</code> or <code class="code">middleCode</code> requests some resources from the kernel, this code may be used for returning this resources back.</dd></dl></div><p>
Visibility of variables in different parts of code of the replacement function may be described as pseudocode:
    </p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    {
        <span class="symbol">returnType</span> <code class="varname">returnValue</code> = target_function(<span class="symbol">arg.name</span>...);
        <span class="symbol">middleCode</span>
        output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    }
    <span class="symbol">epilogue</span>
}
    </pre><p>
If target function return non-void value, variable <code class="varname">returnValue</code> may be used as name of variable to output (<span class="symbol">arg.name</span>) and in the <span class="symbol">middleCode</span>.
    </p><p>
Example of the group section for module_put() target function:
</p><pre class="programlisting">
[group]
	# Name and return type of the target function
	function.name = module_put
	returnsVoid = yes

	# Names and types of the arguments of the target function
	arg.type = struct module*
	arg.name = m
	
	# The parameters to be output to the trace. 
	trace.param.type = void*
	trace.param.name = m

	# The format string to be used for trace output.
	trace.formatString = "arguments: (%p)"

# End of the group of definitions for module_put().
    </pre><p>
Example of the group section for __kmalloc() target function (note using <code class="varname">returnValue</code> variable):
    </p><pre class="programlisting">
[group]
	# Name and return type of the target function
	function.name = __kmalloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
	# The parameters to be output to the trace. 
	trace.param.type = size_t
	trace.param.name = size

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for __kmalloc().
    </pre><p>
Example of the group section for __kmalloc() target function (note implementation <span class="symbol">prologue</span> parameter):
    </p><pre class="programlisting">
    [group]
	# Name and return type of the target function
	function.name = kmem_cache_alloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = struct kmem_cache*
	arg.name = mc
	
	arg.type = gfp_t
	arg.name = flags
	
	prologue =&gt;&gt;
size_t size = kmem_cache_size(mc);
&lt;&lt;
	# The parameters to be output to the trace. 
	trace.param.type = size_t
	trace.param.name = size

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for kmem_cache_alloc().
    </pre><p>
    </p><p>
After writing <code class="filename">payload.data</code> file, you may rewrite value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p>
Next, and the last step is running <span class="command"><strong>make</strong></span> utility. It generate sources for payload module, and then build this module. That is all.
    <p>
    </p></div><div class="section" title="5.3. Writing Custom Payloads for Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_payloads"></a>5.3. Writing Custom Payloads for Fault Simulation</h3></div></div></div><p>
This is a description, how to write new payload module for fault simulation, using KEDR tool for generation files from templates. Common abilities of this tool are detailed descibed in <a class="xref" href="extend.html#using_gen" title="5.1. Using Generator for create custom modules">Section 5.1, “Using Generator for create custom modules”</a> ...
    </p><p>
Whole infrastructure, which is needed for building payload module from 'definition' file is located in <code class="filename">custom_payload_fsim</code> directory under installed expamples. Here is its content:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file for creating payload</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from c-sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory which contatin templates files, used for generating sources from 'definition' file</dd></dl></div><p>
Copy contents of this directory into you own place.
    </p><p>
The first, and the main step - rewrite <code class="filename">payload.data</code> for reflecting definitions of you own payload module.
    </p><p>
At global level (not inside groups) this file should contain definitions for next parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.licence</span></dt><dd>licence for the module</dd></dl></div><p>
Additionally, next parameters may be defined at global level:
</p><div class="variablelist"><dl><dt><span class="term">header</span></dt><dd>code (may be multi lined), which will be inserted before definition of replacement functions. Usually, this code contains '#include' directives, for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code>:
    </p><pre class="programlisting">
# This module processes the calls to kstrdup function.

module.name = payload_fsim_kstrdup
module.author = Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/string.h&gt;
&lt;&lt;
    </pre><p>
    </p><p>
For each target function, which is intended to replace, group should be defined.
Each group should contain definitions for next parameters:
</p><div class="variablelist"><dl><dt><span class="term">function.name</span></dt><dd>name of the target function, which should replaced</dd><dt><span class="term">returnType</span></dt><dd>returning type of the target function, if it returns non-void, otherwise shouldn't be assigned at all</dd><dt><span class="term">returnsVoid</span></dt><dd>any non-empty value, if the target function returns void, otherwise should't be assigned at all. In the future, probably, this parameter will not be used, but currently its usage is mandatory for void functions.</dd><dt><span class="term">arg.type</span></dt><dd>types (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>names (multi-value) of the parameters of the target function, starting with the first one. If function doesn't take parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</dd><dt><span class="term">trace.param.name</span></dt><dd>variable names (multi-value), which values will be output into the trace. This variables should be accessible in replacement function(see below). At least, one value should be output (otherwise this replacement function is meaningless).</dd><dt><span class="term">trace.param.type</span></dt><dd>types (multi-value) of the values, which will be output into the trace. This types will be used in casting values before they will be output(so, these types may differ from real type of variables, which values are used to output).</dd><dt><span class="term">trace.formatString</span></dt><dd>format string which is used for printf-like output values from replacement function (see parameters <span class="quote">“<span class="quote">trace.param.name</span>”</span> and <span class="quote">“<span class="quote">trace.param.type</span>”</span>)</dd></dl></div><p>
Until that moment, only parameters which are also used for call monitor payload has described (see <a class="xref" href="extend.html#custom_callm_payloads" title="5.2. Writing Custom Payloads for Call Monitoring">Section 5.2, “Writing Custom Payloads for Call Monitoring”</a>). And these parameters have almost the same meaning for fault simulation payload, because it extend functionality of call monitor payload. Next, parameters which has meaning only for fault simulation:
</p><div class="variablelist"><dl><dt><span class="term">fpoint.error_code</span></dt><dd>code (may be multi line), which should be executed instead call of the target function for simulate target function failure. Usually, this code simply set <code class="varname">returnValue</code> variable, which will be returned to the caller, for signal that failure occures.</dd><dt><span class="term">fpoint.param.name</span></dt><dd>variable names (multi-value), which values will be passed to the indicator function, and may be used for determine scenario of fault simulation in it. Order of these variables make a sence, because them will be passed sequentially to the indicator function. Usually, only parameters of the target function are passed to the indicator.</dd><dt><span class="term">fpoint.param.type</span></dt><dd>types (multi-value) of the values, which values will be passed to the indicator function. This types will be used for casting variables' values before passing (so, these types may differ from real type of variables).</dd></dl></div><p>

Additionally, next parameters may be defined at group level. Them similar to the ones for call monitor payload, but may have additional work load for fault simulation facility.
</p><div class="variablelist"><dl><dt><span class="term">prologue</span></dt><dd>code (may be multi lined) which will be inserted to the start of replacement function (before call indicator function, which should decide, whether need to simulate or not). May use variable declarations. Usually, this code declare variables, which will be used in output, passed to the indicator function or used by the next code sections (see below).</dd><dt><span class="term">middleCode</span></dt><dd>code (may be multi lined) which may calculate data for output. May not use variable declarations. Note, that this code will be executed after indicator function and possible target function call or executing error-path, and so cannot change their behaviour.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multi lined) which will be inserted at the end of replacement function (after output values). If <code class="code">prologue</code> or <code class="code">middleCode</code> requests some resources from the kernel, this code may be used for returning this resources back.</dd></dl></div><p>
Visibility of variables in different parts of code of the replacement function may be described as pseudocode:
    </p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    {
        <span class="symbol">returnType</span> <code class="varname">returnValue</code>;
        if(indicator_function(<span class="symbol">fpoint.param.name</span>...) == 0)
        {
            <code class="varname">returnValue</code> = target_function(<span class="symbol">arg.name</span>...);
        }
        else
        {
            <span class="symbol">fpoint.error_code</span>;
        }
        <span class="symbol">middleCode</span>
        output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    }
    <span class="symbol">epilogue</span>
}
    </pre><p>
If target function return non-void value, variable <code class="varname">returnValue</code> may be used as name of variable to output (<span class="symbol">arg.name</span>) and in the <span class="symbol">middleCode</span>. Also, this variable should be assigned in the <span class="symbol">fpoint.error_code</span>.
    </p><p>
Example of the group section for __kmalloc target function:
</p><pre class="programlisting">
[group]
	# Name and return type of the target function
	function.name = __kmalloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
	# The parameters to be output to the trace. 
	trace.param.type = size_t
	trace.param.name = size

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (%zu, %x), result: %p"

	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code =	returnValue = NULL;

# End of the group of definitions for __kmalloc().
    </pre><p>
Example of the group section for kstrdup() target function (note using <code class="varname">len</code> variable for fault simulation as derived parameter from target function parameter <code class="varname">str</code>):
    </p><pre class="programlisting">
[group]
	# Name and return type of the target function
	function.name = kstrdup
	returnType = char*

	# Names and types of the arguments of the target function
	arg.type = const char*
	arg.name = str
	
	arg.type = gfp_t
	arg.name = flags

	# Calculate length of the string
	prologue = size_t len = strlen(str);

	# The parameters to be output to the trace.
	trace.param.type = size_t
	trace.param.name = len

	trace.param.type = unsigned int
	trace.param.name = flags

	trace.param.type = void*
	trace.param.name = returnValue

	# The format string to be used for trace output.
	trace.formatString = "arguments: (strlen=%zu, flags=%x), result: %p"

	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = len

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code =	returnValue = NULL;

# End of the group of definitions for kstrdup().
    </pre><p>
    </p><p>
There is an ability to different replacement functions to share same indicator function (and, therefore, share scenario). This is more than simple using same indicator functions, because this functions may use some data, which is privare for each indicator instance. In the case if sharing, these indicator function' s data will be also sharing.
    </p><p>
Such sharing indicator function may be used, e.g., for target functions, which is known to use internally some common mechanism, and you want to simulate fail of this mechanism.
    </p><p>
For say, that function <code class="function">g</code> should share fault simulation scenario with <code class="function">f</code>, you should assign parameter <span class="symbol">fpoint.reuse_point</span> for group of function <code class="function">g</code> to <code class="code">f</code>. In this case, group definition of function <code class="function">f</code> should precede the group definition of function <code class="function">g</code>. Example of sharing fault simulation scenario for <code class="function">__kmalloc</code> and <code class="function">krealloc</code>:
    </p><pre class="programlisting">
    ...
[group]
	# Name and return type of the target function
	function.name = __kmalloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
    ...
    
	# Fault Simulation
	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code = returnValue = NULL;
    
# End of the group of definitions for __kmalloc().

[group]
	# Name and return type of the target function
	function.name = krealloc
	returnType = void*

	# Names and types of the arguments of the target function
	arg.type = const void*
	arg.name = p

	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
    ...	

	# Fault Simulation
	<span class="emphasis"><em>fpoint.reuse_point = __kmalloc</em></span>

	fpoint.param.type = size_t
	fpoint.param.name = size

	fpoint.param.type = gfp_t
	fpoint.param.name = flags

	fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for krealloc().
    </pre><p>
Note, that in group definition for <code class="function">krealloc</code> function we use same names and types for variables, which is intended to pass to indicator function, as for <code class="function">__kmaloc</code>.
    </p><p>
After writing <code class="filename">payload.data</code> file, you may rewrite value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p>
Next, and the last step is running <span class="command"><strong>make</strong></span> utility. It generate sources for payload module, and then build this module. That is all.
    <p>
    </p></div><div class="section" title="5.4. Writing Custom Scenarios for Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_scenarios"></a>5.4. Writing Custom Scenarios for Fault Simulation</h3></div></div></div><p>
This is a description, how to write module which will implement new scenario for fault simulation, using KEDR tool for generation files from templates. Common abilities of this tool are detailed descibed in <a class="xref" href="extend.html#using_gen" title="5.1. Using Generator for create custom modules">Section 5.1, “Using Generator for create custom modules”</a> ...
    </p><p>
Whole infrastructure, which is needed for building payload module from 'definition' file is located in <code class="filename">custom_indicator_fsim</code> directory under installed expamples. Here is its content:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">indicator.data</code></span></dt><dd>'definition' file for creating module, which will implement fault simulation indicator</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from c-sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory which contatin templates files, used for generating sources from 'definition' file</dd><dt><span class="term"><code class="filename">calculator.c</code>, <code class="filename">calculator.h</code>, <code class="filename">control_file.c</code>, <code class="filename">control_file.h</code></span></dt><dd>Additional source files and header which implements parts of indicator functionality. These files are used for building module.</dd></dl></div><p>
Copy contents of this directory into you own place.
    </p><p>
The first, and the main step - rewrite file <code class="filename">indicator.data</code> for reflecting definitions of you own indicator module.
    </p><p>
As opposed to the payloads for call monitoring and fault simulation, which may implements replacement functions for several target ones in one module, every fault simulation indicator should be implemented in different module. So, groups are not used in 'definition' file for indicator module, and only global set of parameters is make sence.
    </p><p>
Indicator module should contain definitions for next parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.licence</span></dt><dd>licence for the module</dd><dt><span class="term">indicator.name</span></dt><dd>name of the indicator, exported by the module. This name should be used, when one need to assign indicator for some function.</dd><dt><span class="term">indicator.parameters.type</span></dt><dd>types (multi value) of the values, which accept indicator function. This is important part of the indicator, and will be fully described later. May be not assigned at all - in this case, indicator function will not accept parameters. </dd><dt><span class="term">indicator.parameters.name</span></dt><dd>names (multi value) of the values, which accept indicator function.</dd><dt><span class="term">expression.vars.name</span></dt><dd>variable names (multi value), which may be used in expression for set particular scenario for indicator. This names themselves doesn't concerned with variable names, used in indicator function. Order of this names has no sence. May be not assigned at all - there are another ways to declare expression variables.</dd><dt><span class="term">expression.vars.values</span></dt><dd>values (multi value) of corresponding expression variables, which will be used at expression evaluate stage (that is, when indicator function will be called). Typically, this values refer to the indicator function parameters.</dd><dt><span class="term">expression.vars.pname</span></dt><dd>names (multi value) of indicator function parameters, which may be used in expression for set particular scenario for indicator. <code class="code"><code class="varname">expression.vars.pname</code> = <code class="literal">var_a</code></code> is equivalent to <code class="code"><code class="varname">expression.vars.name</code> = <code class="literal">var_a</code></code> + <code class="code"><code class="varname">expression.vars.value</code> = <code class="literal">var_a</code></code>. May be not assigned at all - there are another ways to declare expression variables.</dd></dl></div><p>
    </p><p>
The main characteristic of fault simulation indicator is a set of scenarios, which it can implement. Aside from <code class="varname">pid</code> parameter, which may be used for every generated indicator, and which simply restrict area of fault simulation, <code class="varname">expression</code> is the only indicator's parameter, which may affect on the fault simulation scenario. Expression, which use only constant integers as arguments, may implement only "always simulate fail" or "never simulate fail" scenarious. But if expression can use variables, which may have different values at different expression evaluation stages, the set of scenarios is dramatically increased.
    </p><p>
One type of variable, which may be used in expression, is parameter of the target function. E.g., expression <code class="code">(<code class="varname">size</code> &gt; 100)</code>, where <code class="varname">size</code> corresponds to the target function parameter, implements scenario "simulate fail when <code class="varname">size</code> is greater than <code class="literal">100</code>". There is only way for indicator to implement such using of target function's parameter: declare this parameter as parameter of indicator function. So, corresponded replacement function should pass this parameter to the indicator function, whenever it should choose, whether it need to simulate fail. This indicator's behaviour is achived by ( assume that <code class="varname">size</code> parameter of the target function has type <code class="literal">size_t</code>):
    </p><pre class="programlisting">
indicator.parameters.type = size_t
indicator.parameters.name = size
    </pre><p>
    </p><p>
This fragment only define, that indicator function itself accept parameter <code class="varname">size</code>, but for permitting this parameter to be usable in expression,
    </p><pre class="programlisting">
expression.vars.pname = size
    </pre><p>
should be used.
    </p><p>
Parameters <code class="varname">expression.vars.name</code> and <code class="varname">expression.vars.value</code> may be useful for such cases:
    </p><pre class="programlisting">
...
indicator.parameters.type = const char*
indicator.parameters.name = str
...
# Expression may use variable only with integer values, so we cannot use string parameter in it.
# But we can use length of this string as parameter 'len'
expression.vars.name = len
expression.vars.value = strlen(str)
...
    </pre><p>
    </p><pre class="programlisting">
...
indicator.parameters.type = size_t
# Cannot use 'strlen' as name of the parameter, because strlen is the kernel function.
indicator.parameters.name = len
...
# But here 'strlen' is available - this is not a name of c-variable.
expression.vars.name = strlen
# We only need to bind expression variable with its value.
expression.vars.value = len
...
    </pre><p>
    </p><p>
But if we declare that indicator function accepts parameter <code class="varname">size</code> of type <span class="type">size_t</span>, we make this indicator inapplicable for that target functions, which do not accept parameter of that type. Or more exactly, indicator is not applicable for replace functions, which do not provide parameter of this type to indicator function. This limitation is work even if this parameter is not really used in the current scenario.
    </p><p>
Though it is acceptable for indicator to use in expression variables, which is not derived from indicator parameters, like 
    </p><pre class="programlisting">
expression.vars.name = prob50
expression.vars.value = random() % 2
    </pre><p>
it is not recommended, because there is more effective way to doing this. The thing is that, such type of variables is evaluated every time indicator function is called, whenever this variable is used in expression or not. And this evaluation may take relative long time. There is another type of variables, which is applicable in such case - runtime variables. Format of declaration of such variables is:
    </p><pre class="programlisting">
expression.rvars.name = prob50
expression.rvars.code =&gt;&gt;
    return random() % 2;
&lt;&lt;
    </pre><p>
<code class="varname">expression.rvars.code</code> parameter is provide code of the function, which will be used, whenever value of variable is <span class="emphasis"><em>really</em></span> needed. Costs for such optimisation - function call instead inlined code, when value of variable is needed, and inability to use local variables of indicator function (and parameters of this function).
    </p><p>
For simple writting expression, some named constants may be introduces to it.
There are two ways for doing this:
    </p><pre class="programlisting">
expression.constants.name = constant_100
expression.constants.value = 100
    </pre><p>
make available to use in the expression constant <code class="varname">constant_100</code>, which evaluated to 100.
    </p><pre class="programlisting">
expression.constants.cname = GFP_ATOMIC
    </pre><p>
make available to use in the expression constant <code class="varname">GFP_ATOMIC</code>, which evaluated to GFP_ATOMIC. Expression <code class="code">flags == GFP_ATOMIC</code> is more clear, than <code class="code">flags == 32</code>, isn't it?
    </p><p>
Additionally, next parameters may be defined:
</p><div class="variablelist"><dl><dt><span class="term">global</span></dt><dd>code (may be multi lined), which will be inserted at the global scope and its definitions will be visible in any parameter. Usually, this code contains '#include' directives, for header files which define types of parameters of the indicator, and functions, which is used in parameters.</dd></dl></div><p>
Example of indicator for <code class="function">kstrdup</code> function:
    </p><pre class="programlisting">
# This module implements indicator for kmalloc-like functions.

module.author = Tsyvarev
module.license = GPL

global =&gt;&gt;
#include &gt;linux/gfp.h&lt;      /* gfp_flags constants */
#include &gt;linux/types.h&lt;      /* size_t */
&lt;&lt;

indicator.name = kmalloc

indicator.parameters.type = size_t
indicator.parameters.name = size

indicator.parameters.type = gfp_t
indicator.parameters.name = flags

expression.constants.c_name = GFP_NOWAIT
expression.constants.c_name = GFP_KERNEL
expression.constants.c_name = GFP_USER
expression.constants.c_name = GFP_ATOMIC

expression.vars.pname = size
expression.vars.pname = flags
    </pre><p>
    </p><p>
After writing <code class="filename">indicator.data</code> file, you may rewrite value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to one you wish to use as module name.
    </p><p>
Next, and the last step is running <span class="command"><strong>make</strong></span> utility. It generate sources for indicator module, and then build this module. That is all.
    </p></div><div class="section" title="5.5. Implementing Custom Types of Analysis"><div class="titlepage"><div><div><h3 class="title"><a name="custom_analysis"></a>5.5. Implementing Custom Types of Analysis</h3></div></div></div><p>
KEDR is not only a system to perform call monitoring and fault simulation for the target kernel modules. It is a framework that allows to implement different kinds of analysis based on the information about the function calls made by the target module.
</p><p>
In this section, we will show how to create a custom analysis system on top of KEDR. The system we are going to use as an example is rather simple: it maintains a set of counters accessible from user space that provide some information about the actions of the target module.
</p><p>
This analysis system will use neither call monitoring nor fault simulation facilities of KEDR. It will only rely on KEDR core and on the <a class="link" href="reference.html#payload_api" title="6.1. API for Payload Modules">API</a> it provides. Other types of analysis could be implemented in a way similar to this example.
</p><p>
In general, a custom analysis system based on KEDR can be created in the following steps.
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Determine which information about the actions of the target module should be processed by your analysis system. Decide whether it is enough to process (and may be alter to some extent) the function calls to collect this information. If so, KEDR could be of help here.</p></li><li class="listitem"><p>Determine the calls to which functions your system needs to intercept to collect the necessary data or alter the behaviour of the target module in a required way. Note that it is only ordinary functions that count here rather than macros or inlines.</p></li><li class="listitem"><p>Prepare the source code of the payload module for KEDR that will process these intercepted functions. The examples we provide with KEDR as well as the <a class="link" href="reference.html#payload_api.stub" title="6.1.7. A Stub of a Payload Module">skeleton of a payload module</a> described in this manual can be helpful here.</p></li><li class="listitem"><p>Build the payload module. This is done in almost the same way as for any other kernel module.</p></li></ol></div><p>
Once the above steps are completed, KEDR utilities can be used to load your payload module along with the KEDR core. You can now load the target module and your system will start analyzing it.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
The source code of the analysis system developed in this example is available in <code class="filename">&lt;kedr_install_dir&gt;/share/kedr/examples/counters/</code>.
</p></div><div class="section" title="5.5.1. Choosing the Counters and the Functions to Process"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.basics"></a>5.5.1. Choosing the Counters and the Functions to Process</h4></div></div></div><p>
Suppose the following counters are going to be supported by our analysis system:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>total number of memory allocation attempts;</p></li><li class="listitem"><p>number of memory allocation attempts that have failed;</p></li><li class="listitem"><p>size of the largest memory block requested to be allocated;</p></li><li class="listitem"><p>total number of mutex lock operations;</p></li><li class="listitem"><p>mutex balance, i.e. the difference between the total numbers of lock and unlock operations.</p></li></ul></div><p>
To make the counters accessible from the user space, we can, for example, provide a file in <code class="filename">kedr_counters_example</code> directory in debugfs for each one of them.
</p><p>
Once we have decided which data concerning a target kernel module our system will be collecting and processing, we need to determine which function calls made by the module the system should intercept.
</p><p>
Consider the first three counters. All of them are related to memory allocation. To collect necessary data when the target module operates, we can  use call interception facilities provided by KEDR. When the target module calls some function that allocates memory, the corresponding function provided by our analysis system will be called instead with the same arguments. 
</p><p>
There is a number of memory allocation functions available for kernel modules. Assume for simplicity that we choose to process only the calls to the following ones:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">void* __kmalloc(size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void* krealloc(const void* p, size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void* kmem_cache_alloc(struct kmem_cache* mc, gfp_t flags)</code></p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
It should not be very hard to extend this example to support other functions that allocate memory like <code class="code">vmalloc()</code>, <code class="code">kstrdup()</code>, etc.
</p></div><p>
To collect data necessary to provide the remaining two counters, our system needs to process the calls to the operations with mutexes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">void mutex_lock(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_interruptible(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_killable(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_trylock(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">void mutex_unlock(struct mutex* lock)</code></p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the functions may be different for different variants and versions of the Linux kernel. There is no stable binary interface in the Linux kernel anyway. Please choose memory allocation operations and mutex-related functions appropriate for your kernel.
</p></div></div><div class="section" title="5.5.2. Creating the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.payload"></a>5.5.2. Creating the Payload Module</h4></div></div></div><p>
To implement our analysis system, we need to create <a class="link" href="glossary.html#payload_module" title="Payload module">a payload module</a> for KEDR. As a starting point, we can use, for example, the skeleton of a module given in <a class="xref" href="reference.html#payload_api.stub" title="6.1.7. A Stub of a Payload Module">Section 6.1.7, “A Stub of a Payload Module”</a>. The module should provide <a class="link" href="glossary.html#replacement_function" title="Replacement function">a replacement function</a> for each functon we have chosen above.
</p><p>
The instance of <code class="code">struct kedr_payload</code> could be filled as follows (this structure should be used when registering and unregistering the payload module with KEDR core):
</p><pre class="programlisting">
/* Names and addresses of the functions of interest */
static void* orig_addrs[] = {
    (void*)&amp;__kmalloc,
    (void*)&amp;krealloc,
    (void*)&amp;kmem_cache_alloc,
    (void*)&amp;mutex_lock,
    (void*)&amp;mutex_lock_interruptible,
    (void*)&amp;mutex_lock_killable,
    (void*)&amp;mutex_trylock,
    (void*)&amp;mutex_unlock
};

/* Addresses of the replacement functions - must go 
 * in the same order as for the original functions.
 */
static void* repl_addrs[] = {
    (void*)&amp;repl___kmalloc,
    (void*)&amp;repl_krealloc,
    (void*)&amp;repl_kmem_cache_alloc,
    (void*)&amp;repl_mutex_lock,
    (void*)&amp;repl_mutex_lock_interruptible,
    (void*)&amp;repl_mutex_lock_killable,
    (void*)&amp;repl_mutex_trylock,
    (void*)&amp;repl_mutex_unlock
};

static struct kedr_payload counters_payload = {
    .mod                    = THIS_MODULE,
    .repl_table.orig_addrs  = &amp;orig_addrs[0],
    .repl_table.repl_addrs  = &amp;repl_addrs[0],
    .repl_table.num_addrs   = ARRAY_SIZE(orig_addrs)
};
</pre><p>
The initial value of each counter is 0. The replacement functions actually update the counters. They do this with special locks held to avoid some of the concurrency issues. For example, the replacement function for <code class="code">__kmalloc()</code> looks like this:
</p><pre class="programlisting">
static void*
repl___kmalloc(size_t size, gfp_t flags)
{
    unsigned long irq_flags;
    void* returnValue;
    
    /* Call the target function */
    returnValue = __kmalloc(size, flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_total, irq_flags);
    ++cnt_alloc_total;
    spin_unlock_irqrestore(&amp;spinlock_alloc_total, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_failed, irq_flags);
    if (returnValue == NULL) ++cnt_alloc_failed;
    spin_unlock_irqrestore(&amp;spinlock_alloc_failed, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_max_size, irq_flags);
    if (size &gt; cnt_alloc_max_size) cnt_alloc_max_size = size;
    spin_unlock_irqrestore(&amp;spinlock_alloc_max_size, irq_flags);

    return returnValue;
}
</pre><p>
This replacement function calls <code class="code">__kmalloc()</code> (<a class="link" href="glossary.html#target_function" title="Target function">target function</a>) and records its return value. After that, it updates the variables corresponding to the relevant counters, <code class="code">cnt_alloc_total</code>, <code class="code">cnt_alloc_failed</code> and <code class="code">cnt_alloc_max_size</code>. It is not generally mandatory to call the target function there (for example, see <a class="xref" href="using_kedr.html#fault_sim" title="4.5. Fault Simulation">Section 4.5, “Fault Simulation”</a>) but it is necessary for the kind of analysis we implement in this example.
</p><p>
The technical details concerning the creation of files for the counters in debugfs, are not described here. If you are interested in these details, see the source code of <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that it is not mandatory to implement all the counters in a single payload module. For example, we could provide a module that implements the counters related to memory allocation and another one for those dealing with mutexes. As long as the sets of the <a class="link" href="glossary.html#target_function" title="Target function">target functions</a> do not intersect with each other, we may create a separate module for each set and use all these modules at the same time to analyse the target module. 
</p><p>
For simplicity, we implement all the counters in a single payload module in this example.
</p></div></div><div class="section" title="5.5.3. Building the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.build"></a>5.5.3. Building the Payload Module</h4></div></div></div><p>
The payload module that we have prepared can be built much in the same way as any other kernel module. Still, there is a couple of things to take into account.
</p><p>
First, the module uses header files provided by KEDR, so the top include directory of KEDR should be specified in <code class="code">-I</code> compiler option. The directory is usually <code class="filename">&lt;kedr_install_dir&gt;/include/</code>.
</p><p>
Second, each payload module uses functions exported by KEDR core and therefore needs the appropriate .symvers file. Before building the module, you should copy <code class="filename">kedr_base.symvers</code> file provided by KEDR to the directory of the payload module and rename it to <code class="filename">Module.symvers</code>. <code class="filename">kedr_base.symvers</code> is usually located in <code class="filename">/lib/modules/`uname -r`/symvers/</code> or in <code class="filename">&lt;kedr_install_dir&gt;/lib/modules/`uname -r`/symvers/</code> in case of a non-global installation of KEDR.
</p><p>
You can look at <code class="filename">Kbuild</code> and <code class="filename">makefile</code> files to see how the payload is built in <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p></div><div class="section" title="5.5.4. Using the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.use"></a>5.5.4. Using the Payload Module</h4></div></div></div><p>
Now that the payload module for our analysis system is built, we can use it to see how the values of the counters change as the target module operates. You can chose any kernel module as a target if you know how to properly load it and to make it operate.
</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
It is not recommended to simultaneously use payload modules implementing different types of analysis. That is, it is better not to mix the payload module from <span class="quote">“<span class="quote">Counters</span>”</span> example with those intended for call monitoring, fault simulation, etc. One of the problems that may arise here is the conflicting sets of target functions. Currently, KEDR does not detect whether the sets of target functions that the payload modules process intersect or not. If a target function is processed by more than one payload module that are currently loaded, the behaviour of KEDR is undefined.
</p></div><p>
Our analysis system makes the counters available via the files in debugfs. So if debugfs is not mounted (usually its directory is <code class="filename">/sys/kernel/debug/</code>), mount it first to a directory of your choice. For example,
</p><pre class="programlisting">
mount debugfs -t debugfs some_dir/debugfs
</pre><p>
Now it is time to load KEDR core and <code class="filename">kedr_counters.ko</code> payload module that we have built before. The easiest way is 
probably to create a configuration file, say, <code class="filename">my.conf</code>, with the following contents:
</p><pre class="programlisting">
payload path_to_example_directory/kedr_counters.ko
</pre><p>
and use <span class="command"><strong>kedr start</strong></span> with that file:
</p><pre class="programlisting">
kedr start &lt;name_of_target_module&gt; my.conf
</pre><p>
See <a class="xref" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">Section 4.1, “Controlling KEDR”</a> for a detailed information about the configuration files, <span class="command"><strong>kedr start</strong></span>, etc.
</p><p>
Load target module and do something with it. While it is working (and also after it is unloaded), you can check how the counters are shown in the 
files in <code class="filename">kedr_counters_example</code> subdirectory in debugfs.
</p><pre class="programlisting">
tester@lab-x86:&gt; cd /sys/kernel/debug/kedr_counters_example/
tester@lab-x86:&gt; ls
alloc_failed  alloc_max_size  alloc_total  mutex_balance  mutex_locks

tester@lab-x86:&gt; cat alloc_max_size 
Maximum size of a memory chunk requested: 48
</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that if you unload the target module and then load it again while the analysis system (KEDR core modules and <code class="filename">kedr_counters.ko</code> payload module) is loaded, the counters will not be reset. This is a known limitation of this example.
</p></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using_kedr.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Using KEDR </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. KEDR Reference</td></tr></table></div></body></html>
