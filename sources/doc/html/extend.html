<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>5. Customizing and Extending KEDR</title><link rel="stylesheet" href="kedr-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR 0.2 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.2 Reference Manual"><link rel="prev" href="using_kedr.html" title="4. Using KEDR"><link rel="next" href="reference.html" title="6. KEDR Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Customizing and Extending KEDR</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="using_kedr.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr></table><hr></div><div class="section" title="5. Customizing and Extending KEDR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extend"></a>5. Customizing and Extending KEDR</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="extend.html#using_gen">5.1. Using Code Generator to Create Custom Modules</a></span></dt><dt><span class="section"><a href="extend.html#custom_callm_payloads">5.2. Writing Custom Payloads for Call Monitoring</a></span></dt><dt><span class="section"><a href="extend.html#custom_fsim_payloads">5.3. Writing Custom Payloads for Fault Simulation</a></span></dt><dt><span class="section"><a href="extend.html#happens_before_parameter">5.4. <span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring and Fault Simulation Payloads</a></span></dt><dt><span class="section"><a href="extend.html#custom_fsim_scenarios">5.5. Writing Custom Scenarios for Fault Simulation</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis">5.6. Implementing Custom Types of Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="extend.html#custom_analysis.basics">5.6.1. Choosing the Counters and the Functions to Process</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.payload">5.6.2. Creating the Payload Module</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.build">5.6.3. Building the Payload Module</a></span></dt><dt><span class="section"><a href="extend.html#custom_analysis.use">5.6.4. Using the Payload Module</a></span></dt></dl></dd></dl></div><div class="section" title="5.1. Using Code Generator to Create Custom Modules"><div class="titlepage"><div><div><h3 class="title"><a name="using_gen"></a>5.1. Using Code Generator to Create Custom Modules</h3></div></div></div><p>
To automate creation of multiple modules with simular functionality, KEDR actively uses template-based generation of files. This approach facilitates code reuse as it makes it possible to separate the common parts in the implementation of the modules and the parts specific to each module. This also allows the developer of the new modules to concentrate mostly on the <span class="quote">“<span class="quote">logic</span>”</span> of what (s)he wants to implement there rather than on writing and debugging <span class="quote">“<span class="quote">boilerplate</span>”</span> code.
    </p><p>
So, to develop a new module this way, it is only necessary to prepare a short definition of what this module is supposed to do in addition to the basic functionality. Creation of the source file(s) for this module will be performed automatically by the <span class="quote">“<span class="quote">code generator</span>”</span>.
    </p><p>
Apart from usage within KEDR, this mechanism can also be used for creating custom specialized modules for different purposes: payload modules for call monitoring or fault simulation, fault simulation indicators, etc. This approach to development of custom modules has many advantages:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>fast development</em></span> - the implementation of a new payload payload module for call monitoring requires, for example, about 10 lines in the <span class="quote">“<span class="quote">definition</span>”</span> file for the <span class="quote">“<span class="quote">header</span>”</span> part (it contains the name of the module, the author and the license, etc.), and about 10 lines per replacement function (description of the arguments and the return value, etc.).</p></li><li class="listitem"><p><span class="emphasis"><em>clear and readable definition files</em></span> - all features of your module are described in one place, the so called <em class="firstterm">definition file</em> rather than scattered over different files or over one long file. Every line in a <span class="quote">“<span class="quote">definition</span>”</span> file is self-explanatory.</p></li><li class="listitem"><p><span class="emphasis"><em>high level of abstraction</em></span> - when writing a <span class="quote">“<span class="quote">definition</span>”</span> file, you do not need to care about what file(s) will be generated from it and how exactly any particular feature will be implemented.</p></li><li class="listitem"><p><span class="emphasis"><em>less error-prone code</em></span> - if the <span class="quote">“<span class="quote">definition</span>”</span> file is written correctly, correct code of the module will be generated from it. Most of the lines in that file simply define the names of some entities (variables, types, etc.) that will appear in the generated code. The rare inter-line dependencies as well as code chunk definitions can be easily debugged in the clear and short <span class="quote">“<span class="quote">definition</span>”</span> file.</p></li><li class="listitem"><p><span class="emphasis"><em>easier maintenance</em></span> - if the templates are updated to implement some new basic functionality, to fix errors or for any other reason, it is enough to run the <span class="quote">“<span class="quote">generator</span>”</span> again to update the code of the modules you have created. The enhancements and fixes will thus automatically propagate to all the modules generated using those templates.</p></li></ul></div><p>
Of course, using the <span class="quote">“<span class="quote">generator</span>”</span> is not an universal way to extend functionality of the standard KEDR modules. If some functionality is not provided by the templates, it will not be available for the generated modules. You will probably need to implement it manually - or prepare the templates of your own. Still, in many cases it can be very convenient to use the <span class="quote">“<span class="quote">generator</span>”</span> with the default templates to create modules for KEDR.
    </p><p>
Let us now consider the common format of <span class="quote">“<span class="quote">definition</span>”</span> files. 
    </p><p>
The <span class="quote">“<span class="quote">generator</span>”</span> is based on MiST Engine library from <a class="ulink" href="http://template2code.sourceforge.net" target="_top"><em class="citetitle">Template2Code 
project</em></a> and is very similar to <span class="quote">“<span class="quote">mist_gen</span>”</span> example from that project. As a result, the format of definition files accepted by the generator is the same as the format of <em class="firstterm">configuration files</em> accepted by <span class="quote">“<span class="quote">mist_gen</span>”</span>. The format is fully described <a class="ulink" href="http://template2code.sourceforge.net/mist-doc/param.html" target="_top"><em class="citetitle">here</em></a>. The only difference is that a definition file (as well as a configuration file for <span class="quote">“<span class="quote">mist_gen</span>”</span>) may contain <code class="code">[group]</code> keywords that divide the file into blocks.
    </p><p>
A definition file is treated as an array of records. The lines that contain only whitespace characters (spaces and tabs) are ignored, so are the lines where the first non-whitespace character is <code class="code">#</code>:
</p><pre class="programlisting">
# The next line is empty, so it will be ignored

    # This line will be ignored too.
</pre><p>
    </p><p>
Lines like 
</p><pre class="programlisting">
&lt;parameter-name&gt; = &lt;value&gt;
</pre><p>
define a parameter with name <code class="code">&lt;parameter-name&gt;</code> and assign the string <code class="code">&lt;value&gt;</code> to it. <code class="code">&lt;parameter-name&gt;</code> may only contain latin letters, digits, dots, hyphens and underscores. The names are case-sensitive. Whitespace characters surrounding <code class="code">&lt;parameter-name&gt;</code> and <code class="code">&lt;value&gt;</code> are ignored.
    </p><p>
</p><pre class="programlisting">
# Define parameter with name 'a' and value '135'
a = 135
# Define parameter with name 'b' and value 'some string'
b = some string
# Define parameter with name 'expression' and value '2 + 3 = 5'
expression = 2 + 3 = 5
</pre><p>
    </p><p>
There is a way to define parameter with a long value:
</p><pre class="programlisting">
# Define parameter with name 'long-string' and value 'string1 string2 string3'
# Note, that leading whitespace characters are ignored.
long-string = string1 \
    string2 \
    string3
</pre><p>
    </p><p>
In addition, parameters with multiline values can be defined too:
</p><pre class="programlisting">
multi-line-parameter =&gt;&gt;
    line1
    line2
    ...
    lineN
&lt;&lt;
</pre><p>
    </p><p>
The value of <code class="code">multi-line-parameter</code> is precisely as follows:
</p><pre class="programlisting">
    line1
    line2
    ...
    lineN
</pre><p>
    </p><p>
Note that a newline character should immediately follow <code class="code">&gt;&gt;</code> delimiter and apart from the delimiter <code class="code">&lt;&lt;</code> the should be no characters on the line (except whitespace characters).

</p><pre class="programlisting">
# Correct definition of a multiline parameter containing &gt;&gt;
multi-line-parameter =&gt;&gt;
    &lt;&lt;a&gt;&gt;
    &lt;&lt;b&gt;&gt;
    &lt;&lt;
</pre><p>
    </p><p>
The generator only extracts the set of parameters with and  their values from the definition file. The order in which these parameters are listed is not important. For example, the following definition files
</p><pre class="programlisting">
a = 5
b = 10
</pre><p>
and
</p><pre class="programlisting">
b = 10
a = 5
</pre><p>
have actually the same meaning.
    </p><p>
However when several definitions assign values to the same parameter, the parameter becomes multi-valued and the order of the assignments becomes important. Example:
    </p><p>
</p><pre class="programlisting">
a = 5
a = 10
</pre><p>
This means <code class="code">a={'5','10'}</code>, but
</p><pre class="programlisting">
a = 10
a = 5
</pre><p>
means <code class="code">a={'10','5'}</code>. 
    </p><p>
Depending on the meaning of the parameter, the difference in the order of its values may be important (e.g. the order of the function parameters is critical), or it may be not (e.g. the order of the replacement functions in the file).
    </p><p>
As a rule, the order of values of two multi-valued parameters is only significant if these parameters describe one-value attributes of same object:
    </p><p>
</p><pre class="programlisting">
obj.name = object1
obj.description = This is object1
obj.name = object2
obj.description = This is object2
</pre><p>
This defines <code class="code">obj.name</code> as 
<span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">object2</span>”</span></span>,
 <code class="code">obj.description</code> as
 <span class="simplelist"><span class="quote">“<span class="quote">This is object1</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span>.
This may mean there are two object instances with attributes
<span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span> and 
<span class="simplelist"><span class="quote">“<span class="quote">object2</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span>
    </p><p>
Let us consider the following definitions where the values of <code class="code">obj.description</code> are given in a reverse order.
</p><pre class="programlisting">
obj.name = object1
obj.description = This is object2
obj.name = object2
obj.description = This is object1
</pre><p>
This defines <code class="code">obj.name</code> as 
<span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">object2</span>”</span></span>,
 <code class="code">obj.description</code> as
<span class="simplelist"><span class="quote">“<span class="quote">This is object2</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span>.
This may mean two object instances with attributes
<span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span> and 
<span class="simplelist"><span class="quote">“<span class="quote">object2</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span>,
which is probably not what you want. 
    </p><p>
A simple way to avoid such confusion with ordering is to define all attributes for one instance first and only then define attributes for another one.
    </p><p>
If some object has a non-constant set of attributes (e.g., one of its attributes may have multiple values or one of its attribute is optional), then you cannot define several instances of this object in one definition file. This is because the generator cannot determine which instance each particular value of an attribute belongs to. To address this problem, <code class="code">[group]</code> keyword was introduced in the format of definition files. This keyword denotes a new group of definitions that starts just after this keyword and ends before the next occurence of same keyword or at the end of the file.
    </p><p>
</p><pre class="programlisting">
module_name = Arrays
[group]
array.name = array1
array.values = val1
[group]
array.name = array2
array.values = val2
array.values = val3
[group]
array.name = array3
</pre><p>
There are 3 groups in this file. The first one defines <code class="code">array.name='array1'</code> and <code class="code">array.values='val1'</code>, the second - <code class="code">array.name='array2'</code> and <code class="code">array.values={'val2', 'val3'}</code>, third - <code class="code">array.name='array3'</code>. Each group can be interpreted as a definition of an array object. The object named <code class="code">array1</code> contains one element <code class="code">val1</code>, the object named <code class="code">array2</code> contains two elements <code class="code">val2</code> and <code class="code">val3</code>, the object named <code class="code">array3</code> contains no elements.
    </p><p>
<code class="code">[group]</code> keyword does not prevent gathering of all parameter assignments. That is, the <span class="quote">“<span class="quote">global meaning</span>”</span> of this file is <code class="code">module_name='Arrays'</code>, <code class="code">array.name={'array1', 'array2', 'array3'}</code> and <code class="code">array.values={'val1', 'val2', val3'}</code>. This information will be processed by the generator using one set of templates. But besides that, the information from each group will also be processed using another set of templates. This processing will result in a new multi-valued parameter which values are the results processing of the groups. This parameter is referred to as <span class="quote">“<span class="quote">block</span>”</span>, and so is the set of templates used to  generate it. This parameter can be used at the top level of processing, the set of templates for which is referred to as <span class="quote">“<span class="quote">document</span>”</span>.
    </p><p>
As far as payload modules are concerned, <span class="quote">“<span class="quote">document</span>”</span> templates define the overall layout of the generated source and header files while <span class="quote">“<span class="quote">block</span>”</span> templates define the parts of the code related to a replacement function. That is, a <code class="code">[group]</code> block corresponds to a replacement function in this case.
    </p><p>
This section has given a brief overview of template-based code generation mechanism used in KEDR. This should be enough though if you would like to write you own <span class="quote">“<span class="quote">definition</span>”</span> files for custom modules with the templates provided by KEDR. See <a class="ulink" href="http://template2code.sourceforge.net/mist-doc/index.html" target="_top">MiST Engine Reference Manual</a> and <a class="ulink" href="http://template2code.sourceforge.net" target="_top"><span class="quote">“<span class="quote">mist_gen</span>”</span> example</a> if you want to learn more about this way of template-based code generation.
    </p></div><div class="section" title="5.2. Writing Custom Payloads for Call Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="custom_callm_payloads"></a>5.2. Writing Custom Payloads for Call Monitoring</h3></div></div></div><p>
This section describes how to write a new payload module for call monitoring using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <a class="xref" href="extend.html#using_gen" title="5.1. Using Code Generator to Create Custom Modules">Section 5.1, “Using Code Generator to Create Custom Modules”</a>.
    </p><p>
Typical purposes of a custom payload module of this kind could be as follows: 
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
support call monitoring for the functions for which it is not supported by KEDR <span class="quote">“<span class="quote">out-of-the-box</span>”</span>;
</p></li><li class="listitem"><p>
change the set of parameters output to the trace, in case you need something other than the arguments and the return value of the replacement function to be output.
</p></li></ul></div><p>
The whole infrastructure necessary for building the payload module from the <span class="quote">“<span class="quote">definition file</span>”</span> is located in <code class="filename">custom_payload_callm</code> subdirectory in the directory where the examples provided with KEDR are installed. Here are its contents:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file to create the payload module</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory containing the templates used for generating sources from the 'definition' file</dd></dl></div><p>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite <code class="filename">payload.data</code> to reflect definitions of your payload module.
    </p><p>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd></dl></div><p>
In addition, the following parameters may be defined at the global level:
</p><div class="variablelist"><dl><dt><span class="term">header</span></dt><dd>the code (may be multiline) to be inserted before the definition of replacement functions. This code usually contains '#include' directives for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code> file:
</p><pre class="programlisting">
# This module processes the calls to module_put function.

module.name = payload_callm_module_put
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/module.h&gt;
&lt;&lt;
</pre><p>
    </p><p>
For each <a class="link" href="glossary.html#target_function" title="Target function">target function</a> the calls to which should be processed, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
</p><div class="variablelist"><dl><dt><span class="term">function.name</span></dt><dd>name of the target function</dd><dt><span class="term">returnType</span></dt><dd>return type of the target function if it is not void, otherwise shouldn't be defined at all</dd><dt><span class="term">arg.type</span></dt><dd>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</dd><dt><span class="term">trace.param.name</span></dt><dd>(multi-valued) variable names, which values will be output to the trace. This variables should be accessible in replacement function (see below).</dd><dt><span class="term">trace.param.type</span></dt><dd>(multi-valued) types of the values, which will be output into the trace. This types will be used for casting the values of the corresponding variables before they will be output (so, these types may differ from the real types of variables).</dd><dt><span class="term">trace.formatString</span></dt><dd>format string which is used for printf-like output of values from replacement function (see parameters <span class="quote">“<span class="quote">trace.param.name</span>”</span> and <span class="quote">“<span class="quote">trace.param.type</span>”</span>)</dd></dl></div><p>

</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
Output to the trace is currently supported only for the variables of simple types (i.e. no strings, arrays, structures, etc.). Pointers can be output (e.g., using <code class="code"><span class="quote">“<span class="quote">%p</span>”</span></code> or a similar format) but not the data they point to. This is due to the limitations of <span class="command"><strong>kedr_gen</strong></span>. In the future versions, these limitations may be removed or at least relaxed.
</p></div><p>

Additionally, the following parameters can be defined at group level:
</p><div class="variablelist"><dl><dt><span class="term">prologue</span></dt><dd>code (may be multiline) which will be inserted at the start of replacement function (before the call to target function). Usually, this code declares variables which will be used in output and the following code sections (see below).</dd><dt><span class="term">middleCode</span></dt><dd>code (may be multiline) which will be inserted after call to the target function and before the output of values to the trace. Variables can not be declared there. Usually, this code calculates the values of the variables if it is necessary before the output to the trace is done.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multiline) which will be inserted at the end of the replacement function (after the values are output to the trace). If <code class="code">prologue</code> or <code class="code">middleCode</code> request some resources from the kernel, this code can be used to release these resources.</dd></dl></div><p>

Visibility of variables in different parts of code of the replacement function can be described in pseudocode as follows:
</p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    {
        <span class="symbol">returnType</span> <code class="varname">returnValue</code> = target_function(<span class="symbol">arg.name</span>...);
        <span class="symbol">middleCode</span>
        output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    }
    <span class="symbol">epilogue</span>
}

</pre><p>
If the target function does not return void, variable <code class="varname">returnValue</code> refers to the returning value of the function. It may be used as the name of variable to output (<span class="symbol">arg.name</span>) and in the <span class="symbol">middleCode</span>.
    </p><p>
Example of the group section for module_put() target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = module_put

    # Names and types of the arguments of the target function
    arg.type = struct module*
    arg.name = m
    
    # The parameters to be output to the trace. 
    trace.param.type = void*
    trace.param.name = m

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%p)"

# End of the group of definitions for module_put().
</pre><p>
Example of the group section for __kmalloc() target function (note the usage of <code class="varname">returnValue</code> variable as the value of <code class="code">trace.param.name</code> parameter):
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for __kmalloc().
</pre><p>
Example of the group section for kmem_cache_alloc() target function (note the contents of <span class="symbol">prologue</span> parameter):
</p><pre class="programlisting">
    [group]
    # Name and return type of the target function
    function.name = kmem_cache_alloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = struct kmem_cache*
    arg.name = mc
    
    arg.type = gfp_t
    arg.name = flags
    
    prologue =&gt;&gt;
size_t size = kmem_cache_size(mc);
&lt;&lt;
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for kmem_cache_alloc().
</pre><p>
    </p><p>
As you can see, kmem_cache_alloc() function does not have <code class="code">size</code> argument. If we still want to output the size of the requested memory block to the trace, we need to determine it within the replacement function. This is exactly what is done in the prologue code above.
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section" title="5.3. Writing Custom Payloads for Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_payloads"></a>5.3. Writing Custom Payloads for Fault Simulation</h3></div></div></div><p>
This section describes how to write a new payload module for fault simulation using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <a class="xref" href="extend.html#using_gen" title="5.1. Using Code Generator to Create Custom Modules">Section 5.1, “Using Code Generator to Create Custom Modules”</a>.
    </p><p>
Typical purposes of a custom payload module of this kind could be as follows: 
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
support fault simulation for the functions for which it is not supported by KEDR <span class="quote">“<span class="quote">out-of-the-box</span>”</span>;
</p></li><li class="listitem"><p>
change the set of parameters output to the trace, in case you need something other than the arguments and the return value of the replacement function to be output;
</p></li><li class="listitem"><p>
provide a different set of variables to be passed to fault simulation indicator (see below) - this can be necessary if you would like to implement <a class="link" href="extend.html#custom_fsim_scenarios" title="5.5. Writing Custom Scenarios for Fault Simulation">custom fault simulation scenarios</a>.
</p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the infrastructure provided by KEDR for fault simulation (<a class="link" href="glossary.html#fault_simulation_point" title="Fault simulation point">points</a>, <a class="link" href="glossary.html#fault_simulation_indicator" title="Fault simulation indicator">indicators</a> and the respective control facilities) could be used for other purposes as well. What it does in general, is to alter the behaviour of a call made by the target module if the indicator returns nonzero, or allow the target function to do its work normally if the indicator returns 0. The <span class="quote">“<span class="quote">altered behaviour</span>”</span> is controlled by the user, see the description of <code class="code">fpoint.fault_code</code> parameter below. So, instead of fault simulation, you could implement, say, timeout/sleep injection (i.e., delaying the return from the replacement function which might help with concurrency analysis, etc.) or whatever else you want.
</p></div><p>
The files necessary to build the payload module from the <span class="quote">“<span class="quote">definition file</span>”</span> are located in <code class="filename">custom_payload_fsim</code> subdirectory in the directory where the examples provided with KEDR are installed. Here are its contents:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file to create the payload module</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory containing the templates used for generating sources from the 'definition' file</dd></dl></div><p>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite <code class="filename">payload.data</code> to reflect definitions of your payload module.
    </p><p>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd></dl></div><p>
In addition, the following parameters may be defined at the global level:
</p><div class="variablelist"><dl><dt><span class="term">header</span></dt><dd>the code (may be multiline) to be inserted before the definition of replacement functions. This code usually contains '#include' directives for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code> file:
</p><pre class="programlisting">
# This module processes the calls to kstrdup function.

module.name = payload_fsim_kstrdup
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/string.h&gt;
&lt;&lt;
</pre><p>
    </p><p>
For each <a class="link" href="glossary.html#target_function" title="Target function">target function</a> the calls to which should be processed, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
</p><div class="variablelist"><dl><dt><span class="term">function.name</span></dt><dd>name of the target function</dd><dt><span class="term">returnType</span></dt><dd>return type of the target function if it is not void, otherwise shouldn't be defined at all</dd><dt><span class="term">arg.type</span></dt><dd>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the replacement function will be accessible via these names in the code.</dd><dt><span class="term">trace.param.name</span></dt><dd>(multi-valued) variable names, which values will be output to the trace. This variables should be accessible in replacement function (see below).</dd><dt><span class="term">trace.param.type</span></dt><dd>(multi-valued) types of the values, which will be output into the trace. This types will be used for casting the values of the corresponding variables before they will be output (so, these types may differ from the real types of variables).</dd><dt><span class="term">trace.formatString</span></dt><dd>format string which is used for printf-like output values from replacement function (see parameters <span class="quote">“<span class="quote">trace.param.name</span>”</span> and <span class="quote">“<span class="quote">trace.param.type</span>”</span>)</dd></dl></div><p>
    </p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
Output to the trace is currently supported only for the variables of simple types (i.e. no strings, arrays, structures, etc.). Pointers can be output (e.g., using <code class="code"><span class="quote">“<span class="quote">%p</span>”</span></code> or a similar format) but not the data they point to. This is due to the limitations of <span class="command"><strong>kedr_gen</strong></span>. In the future versions, these limitations may be removed or at least relaxed.
</p></div><p>
Until this moment, only parameters which are also used for the payload modules for call monitoring have been described (see <a class="xref" href="extend.html#custom_callm_payloads" title="5.2. Writing Custom Payloads for Call Monitoring">Section 5.2, “Writing Custom Payloads for Call Monitoring”</a>). These parameters have almost the same meaning for the payload modules for fault simulation (these modules extend the functionality of call monitoring payloads). Listed below are the parameters that are meaningful only for fault simulation:
    </p><p>
</p><div class="variablelist"><dl><dt><span class="term">fpoint.fault_code</span></dt><dd>code (may be multiline) which should be executed instead the call to the target function to simulate failure of the latter. Usually, this code simply sets <code class="varname">returnValue</code> variable which will be returned to the caller to indicate that a failure has occured.</dd><dt><span class="term">fpoint.param.name</span></dt><dd>(multi-valued) names of the variables which values will be passed to the indicator function and may be used to specify the scenario of fault simulation in it. The order of these variables is important, because they will be passed sequentially to the indicator function. Usually, only the parameters of the target function are passed to the indicator.</dd><dt><span class="term">fpoint.param.type</span></dt><dd>(multi-valued) types of the values that will be passed to the indicator function. These types will be used to properly cast the values before passing to the indicator (so these types may differ from the real types of the variables).</dd></dl></div><p>

    </p><p>
Additionally, the following parameters can be defined at the group level. They are similar to the ones used in the payload modules for call monitoring. The differences concerning fault simulation are also described below.
</p><div class="variablelist"><dl><dt><span class="term">prologue</span></dt><dd>code (may be multiline) which will be inserted at the start of replacement function (before the call to the indicator function which should decide whether need to simulate a failure or not). Usually, this code declares variables that will be used in the output, will be passed to the indicator function or used by the following code sections (see below).</dd><dt><span class="term">middleCode</span></dt><dd>code (may be multiline) which may calculate data for output. Variables can not be declared there. Note, that this code is placed after the call to the indicator function and after the possible call to the target function (or the error-path). Therefore, <code class="code">middleCode</code> cannot affect the behaviour of these parts of the replacement function. Its intended usage it to prepare the data to the output to the trace: calculate the necessary values, etc.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multiline) which will be inserted at the end of the replacement function (after the values are output to the trace). If <code class="code">prologue</code> or <code class="code">middleCode</code> request some resources from the kernel, this code can be used to release these resources.</dd></dl></div><p>
Visibility of variables in different parts of code of the replacement function may be described in pseudocode as follows:
</p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    {
        <span class="symbol">returnType</span> <code class="varname">returnValue</code>;
        if(indicator_function(<span class="symbol">fpoint.param.name</span>...) == 0)
        {
            <code class="varname">returnValue</code> = target_function(<span class="symbol">arg.name</span>...);
        }
        else
        {
            <span class="symbol">fpoint.fault_code</span>;
        }
        <span class="symbol">middleCode</span>
        output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    }
    <span class="symbol">epilogue</span>
}
</pre><p>
If the target function does not return void, variable <code class="varname">returnValue</code> can be used as name of variable to output (<span class="symbol">arg.name</span>) and in the <span class="symbol">middleCode</span>. Also, this variable should be assigned in the <span class="symbol">fpoint.fault_code</span> (otherwise it will not be initialized if the failure of the target function is simulated).
    </p><p>
Here is an example of the group section for __kmalloc target function. Note the definition of <code class="code">fpoint.fault_code</code> parameter. Its value is <span class="quote">“<span class="quote"><code class="code">returnValue = NULL;</code></span>”</span> because '=' characters after the leftmost one have no special meaning and are treated as the part of the value.
    </p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for __kmalloc().
</pre><p>
Example of the group section for kstrdup() target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = kstrdup
    returnType = char*

    # Names and types of the arguments of the target function
    arg.type = const char*
    arg.name = str
    
    arg.type = gfp_t
    arg.name = flags

    # Calculate length of the string
    prologue = size_t len = strlen(str);

    # The parameters to be output to the trace.
    trace.param.type = size_t
    trace.param.name = len

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void*
    trace.param.name = returnValue

    # The format string to be used for trace output.
    trace.formatString = "arguments: (strlen=%zu, flags=%x), result: %p"

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = len

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for kstrdup().
</pre><p>
    </p><p>
Note the usage of <code class="varname">len</code> variable for fault simulation in the example above. This value is calculated in the prologue based on the target function parameter <code class="varname">str</code> and is then used as one of the parameters to be passed to the fault simulation indicator.
    </p><p>
It is possible for different replacement functions to share the same indicator function (and, therefore, share the scenario). This is more than simply using the same indicator functions, this is using a single instance of an indicator. These functions may use some data private for each indicator instance. In case if sharing, this data will be also shared.
    </p><p>
Sharing of the indicator functions can be useful, for example, for the target functions that are known to use a common mechanism internally (e.g. memory allocator), and you want to simulate a failure of this mechanism.
    </p><p>
If, say, function <code class="function">g</code> should share the fault simulation scenario with <code class="function">f</code>, you should define parameter <span class="symbol">fpoint.reuse_point</span> in the group of function <code class="function">g</code> with value <code class="code">f</code>. In this case, the group for function <code class="function">f</code> should precede the group for function <code class="function">g</code>. Example of sharing a fault simulation scenario for <code class="function">__kmalloc</code> and <code class="function">krealloc</code>:
</p><pre class="programlisting">
    ...
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    ...
    
    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;
    
# End of the group of definitions for __kmalloc().

[group]
    # Name and return type of the target function
    function.name = krealloc
    returnType = void*

    # Names and types of the arguments of the target function
    arg.type = const void*
    arg.name = p

    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    ... 

    # Fault Simulation
    <span class="emphasis"><em>fpoint.reuse_point = __kmalloc</em></span>

    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = returnValue = NULL;

# End of the group of definitions for krealloc().
</pre><p>
Note that in the group for <code class="function">krealloc</code> function, we use the same names and types of the variables intended to be passed to the indicator function, as for <code class="function">__kmalloc</code>.
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section" title="5.4. “trace.happensBefore” Parameter for Call Monitoring and Fault Simulation Payloads"><div class="titlepage"><div><div><h3 class="title"><a name="happens_before_parameter"></a>5.4. <span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring and Fault Simulation Payloads</h3></div></div></div><p>
There is a parameter that changes control flow of the replacement function in call monitor and fault simulation payloads:
</p><div class="variablelist"><dl><dt><span class="term">trace.happensBefore</span></dt><dd>If this parameter is defined (its precise value does not matter), the trace will be output before the target function is called. With this parameter defined, <code class="code">middleCode</code> parameter should not be used as well as <code class="varname">returnValue</code> variable.</dd></dl></div><p>
    </p><p>
The main purpose of using <code class="code">trace.happensBefore</code> parameter is collecting correct trace on SMP systems and the like. Suppose, two threads of execution call <code class="function">mutex_lock</code> and <code class="function">mutex_unlock</code> functions for the same mutex. One of the correct orders of these calls is:
</p><pre class="programlisting">
[1]    <code class="function">mutex_lock</code>
[1]    <code class="function">mutex_unlock</code>
[2]    <code class="function">mutex_lock</code>
[2]    <code class="function">mutex_unlock</code>
</pre><p>
([<em class="replaceable"><code>n</code></em>] means that the operation is performed by the thread <em class="replaceable"><code>n</code></em>).
    </p><p>
So one may expect that same order will be recorded in the trace:
</p><pre class="programlisting">
1    called_mutex_lock
1    called_mutex_unlock
2    called_mutex_lock
2    called_mutex_unlock
</pre><p>
    </p><p>
As described in the <a class="xref" href="extend.html#custom_callm_payloads" title="5.2. Writing Custom Payloads for Call Monitoring">Section 5.2, “Writing Custom Payloads for Call Monitoring”</a>, a replacement function calls the target function first and only after that outputs its parameters to the trace. So the following order of the instructions is possible:
</p><pre class="programlisting">
[1]    [call replacement function for <code class="function">mutex_lock</code>]
[1]    mutex_lock
[1]    output("called_mutex_lock")
[1]    [replacement function for <code class="function">mutex_lock</code> returns]
[1]    [call replacement function for mutex_unlock]
[1]    mutex_unlock
[2]    [call replacement function for <code class="function">mutex_lock</code>]
[2]    mutex_lock
[2]    output("called_mutex_lock")
[2]    [replacement function for <code class="function">mutex_lock</code> returns]
[1]    output("called_mutex_unlock")
[1]    [replacement function for <code class="function">mutex_unlock</code> returns]
[2]    [call replacement function for mutex_unlock]
[2]    mutex_unlock
[2]    output("called_mutex_unlock")
[2]    [replacement function for <code class="function">mutex_unlock</code> returns]
</pre><p>
    </p><p>
Even though the order of calls to the target functions is correct, these instructions produce the trace that reflects impossible call order:
</p><pre class="programlisting">
1    called_mutex_lock
2    called_mutex_lock
1    called_mutex_unlock
2    called_mutex_unlock
</pre><p>
    </p><p>
From the kernel's point of view, the calls to <code class="function">mutex_lock</code> and <code class="function">mutex_unlock</code> are not related to the trace output made by KEDR. So the operations that output trace can be performed in any order, no matter in what order the target functions were called.
    </p><p>
To get a correct trace, we need to use <code class="code">trace.happensBefore</code> parameter for the replacement function for <code class="function">mutex_unlock</code>. At the abstract level, this parameter means <span class="quote">“<span class="quote">Whenever <code class="function">mutex_unlock</code> is called before some other function and nobody enforces this order explicitly, the order should be preserved in the trace</span>”</span>.
    </p><p>
Note that although <code class="function">mutex_lock</code> function must also be called before the corresponding <code class="function">mutex_unlock</code>, this order is not affected by <code class="code">trace.happensBefore</code> parameter.
    </p><pre class="programlisting">
...
[1]    mutex_lock
...
[1]    mutex_unlock
...
</pre><p>
The difference is that such order should be enforced <span class="emphasis"><em>explicitly</em></span>, that is, by the user of these functions and thus of the target module. If the target module calls, say, <code class="function">mutex_lock</code> strictly before <code class="function">mutex_unlock</code>, the replacement function for <code class="function">mutex_lock</code> will return strictly before the one for <code class="function">mutex_unlock</code> starts executing. This, in turn, automatically enforces that the corresponding trace records will go in the right order too.
    </p><p>
If <code class="code">trace.happensBefore</code> parameter is defined, the control flow of the replacement functions could be described in pseudocode as follows:
</p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    target_function(<span class="symbol">arg.name</span>...);
    <span class="symbol">epilogue</span>
}
</pre><p>
    </p><p>
For a fault simulation replacement function, the control flow is as follows in this case:
</p><pre class="programlisting">
<span class="symbol">returnType</span> replacement_function(<span class="symbol">arg.name</span>...)
{
    <span class="symbol">prologue</span>
    output(<span class="symbol">trace.formatString</span>, <span class="symbol">trace.param.name</span>...);
    if(indicator_function(<span class="symbol">fpoint.param.name</span>...) == 0)
    {
        target_function(<span class="symbol">arg.name</span>...);
    }
    else
    {
        <span class="symbol">fpoint.fault_code</span>;
    }
    <span class="symbol">epilogue</span>
}
</pre><p>
    </p><p>
Another example of internal happens-before relationship is the one between <code class="function">kfree</code> and <code class="function">__kmalloc</code> functions. This relationship reflects the fact that <code class="function">__kmalloc</code> cannot return an address that was previously returned by another <code class="function">__kmalloc</code> call and was not processed by <code class="function">kfree</code>. Using <code class="code">trace.happensBefore</code> parameter one can make sure the order of the trace records is correct:
</p><pre class="programlisting"> 
    [group]
    # Name and return type of the target function
    function.name = kfree

    # Names and types of the arguments of the target function
    arg.type = void*
    arg.name = p
    
    # The parameters to be output to the trace.
    trace.param.type = void*
    trace.param.name = p

    # Happens-before relationship with kmalloc
    <span class="emphasis"><em>trace.happensBefore = yes</em></span>

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%p)"

# End of the group of definitions for kfree().
</pre><p>
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
For the trace records to reflect the fact that function <code class="function">A</code> has happens-before ordering with function <code class="function">B</code>, one should define <code class="code">trace.happensBefore</code> parameter for the function <code class="function">A</code> and <span class="emphasis"><em>should not define it</em></span> for the function <code class="function">B</code>. <code class="code">trace.happensBefore</code> cannot be used to enforce two different orderings for the calls to a single function such as <code class="function">krealloc</code> (which may be modelled as <code class="function">__kmalloc</code> + <code class="function">kfree</code>).
    </p><p>
Usually, the functions for which <code class="code">trace.happensBefore</code> parameter makes sense, return void and are not interesting for fault simulation.
    </p></div></div><div class="section" title="5.5. Writing Custom Scenarios for Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_scenarios"></a>5.5. Writing Custom Scenarios for Fault Simulation</h3></div></div></div><p>
The fault simulation scenarios described in <a class="xref" href="using_kedr.html#fault_sim" title="4.5. Fault Simulation">Section 4.5, “Fault Simulation”</a> are configurable and are probably enough for many cases. If they are not, a kernel module implementing a custom <a class="link" href="glossary.html#fault_simulation_indicator" title="Fault simulation indicator">fault simulation indicator</a> can be developed. This section describes how do this using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <a class="xref" href="extend.html#using_gen" title="5.1. Using Code Generator to Create Custom Modules">Section 5.1, “Using Code Generator to Create Custom Modules”</a>
    </p><p>
The whole infrastructure needed to build the module based on the definition file and the templates is located in <code class="filename">custom_indicator_fsim</code> subdirectory in the directory where the examples provided with KEDR are installed. Here are its contents:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">indicator.data</code></span></dt><dd>'definition' file to create the module that will implement the fault simulation indicator</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd><dt><span class="term"><code class="filename">templates</code></span></dt><dd>directory containing the templates used for generating sources from the 'definition' file</dd><dt><span class="term"><code class="filename">calculator.c</code>, <code class="filename">calculator.h</code>, <code class="filename">control_file.c</code>, <code class="filename">control_file.h</code></span></dt><dd>additional source and header files that implement some of the indicator's functionality. These files are used for building the module.</dd></dl></div><p>
To use all this in development of your module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite file <code class="filename">indicator.data</code> to reflect the definitions of your indicator module.
    </p><p>
Unlike a payload module for <a class="link" href="extend.html#custom_callm_payloads" title="5.2. Writing Custom Payloads for Call Monitoring">call monitoring</a> or <a class="link" href="extend.html#custom_fsim_payloads" title="5.3. Writing Custom Payloads for Fault Simulation">fault simulation</a> that can implement replacement functions for several target functions in a single module, each fault simulation indicator should be implemented in a separate module. So, groups are not used in the definition file for the indicator module. Only the global set of parameters is taken into account.
    </p><p>
Indicator module should contain definitions of the following parameters:
</p><div class="variablelist"><dl><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd><dt><span class="term">indicator.name</span></dt><dd>name of the indicator, provided by the module. This is the very name that should be used when one applies the indicator to some target function (to be exact, to a <a class="link" href="glossary.html#fault_simulation_indicator" title="Fault simulation indicator">fault simulation point</a>).</dd><dt><span class="term">indicator.parameter.type</span></dt><dd>(multi-valued) types of the values that the indicator function accepts. This is an important part of the indicator and will be described later in detail. This parameter may be assigned no value at all - in this case, the indicator function will accept no parameters. </dd><dt><span class="term">indicator.parameter.name</span></dt><dd>(multi-valued) names of the values that the indicator function accepts.</dd><dt><span class="term">expression.variable.name</span></dt><dd>(multi-valued) names of variables that can be used in an expression to set a particular scenario for the indicator (see also <a class="xref" href="using_kedr.html#fault_sim" title="4.5. Fault Simulation">Section 4.5, “Fault Simulation”</a>). The names themselves are by no means bound to the names of variables used in the indicator. The order of values is not important for this parameter. This parameter may even be left undefined as there are other ways to declare expression variables.</dd><dt><span class="term">expression.variable.value</span></dt><dd>(multi-valued) values of the corresponding expression variables that will be used during the evaluation of the expression (that is, when the indicator function is called). Typically, these values refer to the parameters of the indicator function.</dd><dt><span class="term">expression.variable.pname</span></dt><dd>(multi-valued) names of the parameters of the indicator function that can be used in an expression to set a particular scenario for the indicator. <code class="code"><code class="varname">expression.variable.pname</code> = <code class="literal">var_a</code></code> is equivalent to <code class="code"><code class="varname">expression.variable.name</code> = <code class="literal">var_a</code></code> + <code class="code"><code class="varname">expression.variable.value</code> = <code class="literal">var_a</code></code>. This parameter may even be left undefined as there are other ways to declare expression variables.</dd></dl></div><p>
    </p><p>
The main characteristic of a fault simulation indicator is a set of scenarios, which it can implement. Apart from <code class="varname">pid</code> parameter that can be used for each generated indicator and simply restricts the <span class="quote">“<span class="quote">area</span>”</span> of fault simulation, <code class="varname">expression</code> is the only indicator's parameter, which may affect the fault simulation scenario. An expression that uses only constant integers as arguments may implement only <span class="pcite"><span class="quote">“<span class="quote">always simulate fail</span>”</span></span> or <span class="pcite"><span class="quote">“<span class="quote">never simulate fail</span>”</span></span> scenarios. But if the expression can use variables which may have different values each time the expression is evaluated, the set of supported scenarios increases dramatically.
    </p><p>
One type of variable that can be used in the expression is the parameter of the target function. E.g., expression <code class="code">(<code class="varname">size</code> &gt; 100)</code>, where <code class="varname">size</code> corresponds to the target function parameter, implements the scenario <span class="pcite"><span class="quote">“<span class="quote">simulate fail when <code class="varname">size</code> is greater than <code class="literal">100</code></span>”</span></span>. The only way for the indicator to implement such usage of a target function's parameter is to declare this parameter as parameter of indicator function. So, the corresponding replacement function should pass this parameter to the indicator function whenever it should choose whether it needs to simulate a failure. This behaviour of the indicator is achieved by the following definitions (assume <code class="varname">size</code> parameter of the target function has type <code class="literal">size_t</code>):
</p><pre class="programlisting">
indicator.parameter.type = size_t
indicator.parameter.name = size
</pre><p>
    </p><p>
This fragment only defines that the indicator function itself accepts parameter <code class="varname">size</code>. To permit using this parameter in the expression, the following definition should be used as well:
    </p><pre class="programlisting">
expression.variable.pname = size
</pre><p>
Parameters <code class="varname">expression.variable.name</code> and <code class="varname">expression.variable.value</code> may be useful for such cases:
</p><pre class="programlisting">
...
indicator.parameter.type = const char*
indicator.parameter.name = str
...
# Expression may use variables only with integer values, so we cannot use 
# a string parameter in it.
# But we can use the length of this string as parameter 'len'
expression.variable.name = len
expression.variable.value = strlen(str)
...
</pre><p>
</p><pre class="programlisting">
...
indicator.parameter.type = size_t
# Cannot use 'strlen' as name of the parameter, because strlen() is 
# the kernel function.
indicator.parameter.name = len
...
# But here 'strlen' is available - this is not a name of C variable.
expression.variable.name = strlen
# We only need to bind expression variable to its value.
expression.variable.value = len
...
</pre><p>
    </p><p>
However if we declare that the indicator function accepts parameter <code class="varname">size</code> of type <span class="type">size_t</span>, we make this indicator not applicable for those target functions that do not accept a parameter of that type. Or to be more exact, the indicator is not applicable for (cannot be used from) the replacement functions that do not provide a parameter of this type to indicator function. This limitation holds even if this parameter is not really used in the current scenario.
    </p><p>
Although it is acceptable for the indicator to use the variables in expression, which are not derived from the indicator's parameters like 
</p><pre class="programlisting">
expression.variable.name = prob50
expression.variable.value = random() % 2
</pre><p>
it is not recommended, because there is a more efficient way to do this. The thing is that, the variables of this kind are evaluated every time the indicator function is called, no matter if this variable is used in the expression or not. This evaluation may take relatively long time in some cases. There is another type of variables which is applicable in such cases - <em class="firstterm">runtime variables</em>. Declaration of such variables has the following format:
</p><pre class="programlisting">
expression.rvariable.name = prob50
expression.rvariable.code =&gt;&gt;
    return random() % 2;
&lt;&lt;
</pre><p>
<code class="varname">expression.rvariable.code</code> parameter provides the code of the function which will be used whenever value of variable is <span class="emphasis"><em>really</em></span> needed. The costs of such optimisation are a function call used instead of the inlined code when the value of the variable is needed, and inability to use local variables of the indicator function (and parameters of this function) to prepared the value of the runtime variable.
    </p><p>
To simplify writing expressions and to make them more readable, named constants can be declared and then used there. There are two ways to do this:
</p><pre class="programlisting">
expression.constant.name = constant_100
expression.constant.value = 100
</pre><p>
This makes the constant with name <code class="varname">constant_100</code> and value 100 available for usage in the expressions.
</p><pre class="programlisting">
expression.constant.cname = GFP_ATOMIC
</pre><p>
This makes the constant with name <code class="varname">GFP_ATOMIC</code> which evaluates to GFP_ATOMIC available for usage in the expressions. Expression <code class="code">flags == GFP_ATOMIC</code> is clearer and easier to read than <code class="code">flags == 32</code>, isn't it?
    </p><p>
Additionally, the following parameter can be defined:
</p><div class="variablelist"><dl><dt><span class="term">global</span></dt><dd>code (may be multiline) that will be inserted at the global scope and its definitions will be visible everywhere in the source file of the indicator. Usually, this code contains <code class="code">#include</code> directives for the header files containing types definitions of parameters of the indicator and declarations of the functions used to obtain the values of the parameters.</dd></dl></div><p>
Example of indicator for <code class="function">kstrdup</code> function:
</p><pre class="programlisting">
# This module implements indicator for kmalloc-like functions.

module.author = Andrey Tsyvarev
module.license = GPL

global =&gt;&gt;
#include &lt;linux/gfp.h&gt;      /* gfp_flags constants */
#include &lt;linux/types.h&gt;    /* size_t */
&lt;&lt;

indicator.name = kmalloc

indicator.parameter.type = size_t
indicator.parameter.name = size

indicator.parameter.type = gfp_t
indicator.parameter.name = flags

expression.constant.c_name = GFP_NOWAIT
expression.constant.c_name = GFP_KERNEL
expression.constant.c_name = GFP_USER
expression.constant.c_name = GFP_ATOMIC

expression.variable.pname = size
expression.variable.pname = flags
</pre><p>
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. 
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section" title="5.6. Implementing Custom Types of Analysis"><div class="titlepage"><div><div><h3 class="title"><a name="custom_analysis"></a>5.6. Implementing Custom Types of Analysis</h3></div></div></div><p>
KEDR is not only a system to perform call monitoring and fault simulation for the target kernel modules. It is a framework that allows to implement different kinds of analysis based on the information about the function calls made by the target module.
</p><p>
In this section, we will show how to create a custom analysis system on top of KEDR. The system we are going to use as an example is rather simple: it maintains a set of counters accessible from user space that provide some information about the actions of the target module.
</p><p>
This analysis system will use neither call monitoring nor fault simulation facilities of KEDR. It will only rely on KEDR core and on the <a class="link" href="reference.html#payload_api" title="6.1. API for Payload Modules">API</a> it provides. Other types of analysis could be implemented in a way similar to this example.
</p><p>
In general, a custom analysis system based on KEDR can be created in the following steps.
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Determine which information about the actions of the target module should be processed by your analysis system. Decide whether it is enough to process (and may be alter to some extent) the function calls to collect this information. If so, KEDR could be of help here.</p></li><li class="listitem"><p>Determine the calls to which functions your system needs to intercept to collect the necessary data or alter the behaviour of the target module in a required way. Note that it is only ordinary functions that count here rather than macros or inlines.</p></li><li class="listitem"><p>Prepare the source code of the payload module for KEDR that will process these intercepted functions. The examples we provide with KEDR as well as the <a class="link" href="reference.html#payload_api.stub" title="6.1.7. A Stub of a Payload Module">skeleton of a payload module</a> described in this manual can be helpful here.</p></li><li class="listitem"><p>Build the payload module. This is done in almost the same way as for any other kernel module.</p></li></ol></div><p>
Once the above steps are completed, KEDR utilities can be used to load your payload module along with the KEDR core. You can now load the target module and your system will start analyzing it.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
The source code of the analysis system developed in this example is available in </p><p><code class="filename">&lt;kedr_install_dir&gt;/share/kedr/examples/counters/</code>.
</p></div><div class="section" title="5.6.1. Choosing the Counters and the Functions to Process"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.basics"></a>5.6.1. Choosing the Counters and the Functions to Process</h4></div></div></div><p>
Suppose the following counters are going to be supported by our analysis system:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>total number of memory allocation attempts;</p></li><li class="listitem"><p>number of memory allocation attempts that have failed;</p></li><li class="listitem"><p>size of the largest memory block requested to be allocated;</p></li><li class="listitem"><p>total number of mutex lock operations;</p></li><li class="listitem"><p>mutex balance, i.e. the difference between the total numbers of lock and unlock operations.</p></li></ul></div><p>
To make the counters accessible from the user space, we can, for example, provide a file in <code class="filename">kedr_counters_example</code> directory in debugfs for each one of them.
</p><p>
Once we have decided which data concerning a target kernel module our system will be collecting and processing, we need to determine which function calls made by the module the system should intercept.
</p><p>
Consider the first three counters. All of them are related to memory allocation. To collect necessary data when the target module operates, we can  use call interception facilities provided by KEDR. When the target module calls some function that allocates memory, the corresponding function provided by our analysis system will be called instead with the same arguments. 
</p><p>
There is a number of memory allocation functions available for kernel modules. Assume for simplicity that we choose to process only the calls to the following ones:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">void* __kmalloc(size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void* krealloc(const void* p, size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void* kmem_cache_alloc(struct kmem_cache* mc, gfp_t flags)</code></p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
It should not be very hard to extend this example to support other functions that allocate memory like <code class="code">vmalloc()</code>, <code class="code">kstrdup()</code>, etc.
</p></div><p>
To collect data necessary to provide the remaining two counters, our system needs to process the calls to the operations with mutexes:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="code">void mutex_lock(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_interruptible(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_killable(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_trylock(struct mutex* lock)</code></p></li><li class="listitem"><p><code class="code">void mutex_unlock(struct mutex* lock)</code></p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the functions may be different for different variants and versions of the Linux kernel. There is no stable binary interface in the Linux kernel anyway. Please choose memory allocation operations and mutex-related functions appropriate for your kernel.
</p></div></div><div class="section" title="5.6.2. Creating the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.payload"></a>5.6.2. Creating the Payload Module</h4></div></div></div><p>
To implement our analysis system, we need to create <a class="link" href="glossary.html#payload_module" title="Payload module">a payload module</a> for KEDR. As a starting point, we can use, for example, the skeleton of a module given in <a class="xref" href="reference.html#payload_api.stub" title="6.1.7. A Stub of a Payload Module">Section 6.1.7, “A Stub of a Payload Module”</a>. The module should provide <a class="link" href="glossary.html#replacement_function" title="Replacement function">a replacement function</a> for each functon we have chosen above.
</p><p>
The instance of <code class="code">struct kedr_payload</code> could be filled as follows (this structure should be used when registering and unregistering the payload module with KEDR core):
</p><pre class="programlisting">
/* Names and addresses of the functions of interest */
static void* orig_addrs[] = {
    (void*)&amp;__kmalloc,
    (void*)&amp;krealloc,
    (void*)&amp;kmem_cache_alloc,
    (void*)&amp;mutex_lock,
    (void*)&amp;mutex_lock_interruptible,
    (void*)&amp;mutex_lock_killable,
    (void*)&amp;mutex_trylock,
    (void*)&amp;mutex_unlock
};

/* Addresses of the replacement functions - must go 
 * in the same order as for the original functions.
 */
static void* repl_addrs[] = {
    (void*)&amp;repl___kmalloc,
    (void*)&amp;repl_krealloc,
    (void*)&amp;repl_kmem_cache_alloc,
    (void*)&amp;repl_mutex_lock,
    (void*)&amp;repl_mutex_lock_interruptible,
    (void*)&amp;repl_mutex_lock_killable,
    (void*)&amp;repl_mutex_trylock,
    (void*)&amp;repl_mutex_unlock
};

static struct kedr_payload counters_payload = {
    .mod                    = THIS_MODULE,
    .repl_table.orig_addrs  = &amp;orig_addrs[0],
    .repl_table.repl_addrs  = &amp;repl_addrs[0],
    .repl_table.num_addrs   = ARRAY_SIZE(orig_addrs),
    .target_load_callback   = NULL,
    .target_unload_callback = NULL
};
</pre><p>
The initial value of each counter is 0. The replacement functions actually update the counters. They do this with special locks held to avoid some of the concurrency issues. For example, the replacement function for <code class="code">__kmalloc()</code> looks like this:
</p><pre class="programlisting">
static void*
repl___kmalloc(size_t size, gfp_t flags)
{
    unsigned long irq_flags;
    void* returnValue;
    
    /* Call the target function */
    returnValue = __kmalloc(size, flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_total, irq_flags);
    ++cnt_alloc_total;
    spin_unlock_irqrestore(&amp;spinlock_alloc_total, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_failed, irq_flags);
    if (returnValue == NULL) ++cnt_alloc_failed;
    spin_unlock_irqrestore(&amp;spinlock_alloc_failed, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_max_size, irq_flags);
    if (size &gt; cnt_alloc_max_size) cnt_alloc_max_size = size;
    spin_unlock_irqrestore(&amp;spinlock_alloc_max_size, irq_flags);

    return returnValue;
}
</pre><p>
This replacement function calls <code class="code">__kmalloc()</code> (<a class="link" href="glossary.html#target_function" title="Target function">target function</a>) and records its return value. After that, it updates the variables corresponding to the relevant counters, <code class="code">cnt_alloc_total</code>, <code class="code">cnt_alloc_failed</code> and <code class="code">cnt_alloc_max_size</code>. It is not generally mandatory to call the target function there (for example, see <a class="xref" href="using_kedr.html#fault_sim" title="4.5. Fault Simulation">Section 4.5, “Fault Simulation”</a>) but it is necessary for the kind of analysis we implement in this example.
</p><p>
The technical details concerning the creation of files for the counters in debugfs, are not described here. If you are interested in these details, see the source code of <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that it is not mandatory to implement all the counters in a single payload module. For example, we could provide a module that implements the counters related to memory allocation and another one for those dealing with mutexes. As long as the sets of the <a class="link" href="glossary.html#target_function" title="Target function">target functions</a> do not intersect with each other, we may create a separate module for each set and use all these modules at the same time to analyse the target module. 
</p><p>
For simplicity, we implement all the counters in a single payload module in this example.
</p></div></div><div class="section" title="5.6.3. Building the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.build"></a>5.6.3. Building the Payload Module</h4></div></div></div><p>
The payload module that we have prepared can be built much in the same way as any other kernel module. Still, there is a couple of things to take into account.
</p><p>
First, the module uses header files provided by KEDR, so the top include directory of KEDR should be specified in <code class="code">-I</code> compiler option. The directory is usually <code class="filename">&lt;kedr_install_dir&gt;/include/</code>.
</p><p>
Second, each payload module uses functions exported by KEDR core and therefore needs the appropriate .symvers file. Before building the module, you should copy <code class="filename">kedr_base.symvers</code> file provided by KEDR to the directory of the payload module and rename it to <code class="filename">Module.symvers</code>. <code class="filename">kedr_base.symvers</code> is usually located in <code class="filename">/lib/modules/`uname -r`/symvers/</code> or in <code class="filename">&lt;kedr_install_dir&gt;/lib/modules/`uname -r`/symvers/</code> in case of a non-global installation of KEDR.
</p><p>
You can look at <code class="filename">Kbuild</code> and <code class="filename">makefile</code> files to see how the payload is built in <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p></div><div class="section" title="5.6.4. Using the Payload Module"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.use"></a>5.6.4. Using the Payload Module</h4></div></div></div><p>
Now that the payload module for our analysis system is built, we can use it to see how the values of the counters change as the target module operates. You can chose any kernel module as a target if you know how to properly load it and to make it operate.
</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
It is not recommended to simultaneously use payload modules implementing different types of analysis. That is, it is better not to mix the payload module from <span class="quote">“<span class="quote">Counters</span>”</span> example with those intended for call monitoring, fault simulation, etc. One of the problems that may arise here is the conflicting sets of target functions. Currently, KEDR does not detect whether the sets of target functions that the payload modules process intersect or not. If a target function is processed by more than one payload module that are currently loaded, the behaviour of KEDR is undefined.
</p></div><p>
Our analysis system makes the counters available via the files in debugfs. So if debugfs is not mounted (usually its directory is <code class="filename">/sys/kernel/debug/</code>), mount it first to a directory of your choice. For example,
</p><pre class="programlisting">
mount debugfs -t debugfs some_dir/debugfs
</pre><p>
Now it is time to load KEDR core and <code class="filename">kedr_counters.ko</code> payload module that we have built before. The easiest way is 
probably to create a configuration file, say, <code class="filename">my.conf</code>, with the following contents:
</p><pre class="programlisting">
payload path_to_example_directory/kedr_counters.ko
</pre><p>
and use <span class="command"><strong>kedr start</strong></span> with that file:
</p><pre class="programlisting">
kedr start &lt;name_of_target_module&gt; my.conf
</pre><p>
See <a class="xref" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">Section 4.1, “Controlling KEDR”</a> for a detailed information about the configuration files, <span class="command"><strong>kedr start</strong></span>, etc.
</p><p>
Load target module and do something with it. While it is working (and also after it is unloaded), you can check how the counters are shown in the 
files in <code class="filename">kedr_counters_example</code> subdirectory in debugfs.
</p><pre class="programlisting">
tester@lab-x86:&gt; cd /sys/kernel/debug/kedr_counters_example/
tester@lab-x86:&gt; ls
alloc_failed  alloc_max_size  alloc_total  mutex_balance  mutex_locks

tester@lab-x86:&gt; cat alloc_max_size 
Maximum size of a memory chunk requested: 48
</pre><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that if you unload the target module and then load it again while the analysis system (KEDR core modules and <code class="filename">kedr_counters.ko</code> payload module) is loaded, the counters will not be reset. This is a known limitation of this example.
</p></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="using_kedr.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="reference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Using KEDR </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. KEDR Reference</td></tr></table></div></body></html>
