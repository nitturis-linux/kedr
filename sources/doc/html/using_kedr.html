<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>4. Using KEDR</title><link rel="stylesheet" href="kedr-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="prev" href="getting_started.html" title="3. Getting Started"><link rel="next" href="extend.html" title="5. Customizing and Extending KEDR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. Using KEDR</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="getting_started.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="extend.html">Next</a></td></tr></table><hr></div><div class="section" title="4. Using KEDR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using_kedr"></a>4. Using KEDR</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="using_kedr.html#kedr_control">4.1. Controlling KEDR</a></span></dt><dd><dl><dt><span class="section"><a href="using_kedr.html#kedr_control.general">4.1.1. General</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.syntax">4.1.2. Usage</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.options">4.1.3. Options</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.description">4.1.4. Description</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.caveats">4.1.5. Caveats</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.config_file">4.1.6. Configuration file</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.examples">4.1.7. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="using_kedr.html#capture_trace">4.2. Capturing the Trace</a></span></dt><dd><dl><dt><span class="section"><a href="using_kedr.html#capture_trace.general">4.2.1. General</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.syntax">4.2.2. Usage</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_capture_trace.options">4.2.3. Options</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.description">4.2.4. Description</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.caveats">4.2.5. Caveats</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.examples">4.2.6. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="using_kedr.html#how_kedr_works">4.3. How KEDR Works</a></span></dt><dt><span class="section"><a href="using_kedr.html#call_mon">4.4. Call Monitoring</a></span></dt><dt><span class="section"><a href="using_kedr.html#fault_sim">4.5. Fault Simulation</a></span></dt></dl></div><div class="section" title="4.1. Controlling KEDR"><div class="titlepage"><div><div><h3 class="title"><a name="kedr_control"></a>4.1. Controlling KEDR</h3></div></div></div><div class="section" title="4.1.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.general"></a>4.1.1. General</h4></div></div></div><p>
    <span class="command"><strong>kedr</strong></span> - service-like tool for simplify control of KEDR.
</p></div><div class="section" title="4.1.2. Usage"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.syntax"></a>4.1.2. Usage</h4></div></div></div><div class="cmdsynopsis"><p><code class="command">kedr start</code>   <em class="replaceable"><code>target_name</code></em>  [ -c <em class="replaceable"><code>conf_string</code></em>  |   <em class="replaceable"><code>conf_file</code></em> ...]</p></div><div class="cmdsynopsis"><p><code class="command">kedr stop</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr status</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr restart</code> </p></div></div><div class="section" title="4.1.3. Options"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.options"></a>4.1.3. Options</h4></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="option">-c</code> <em class="replaceable"><code>conf_string</code></em></span></dt><dd><p>
Use configuration string <em class="replaceable"><code>conf_string</code></em> instead of default configuration file.
            </p></dd><dt><span class="term"><em class="replaceable"><code>conf_file</code></em></span></dt><dd><p>
Use configuration file <em class="replaceable"><code>conf_file</code></em> instead of default configuration file.
            </p></dd></dl></div><p>
All <em class="replaceable"><code>conf_string</code></em> and(or) <em class="replaceable"><code>conf_file</code></em>, which appears in the command options, joined into one configuration file in the same order, as them appear in the command line, and resulting file is used as configuration file for the command.
            </p><p>
If no <em class="replaceable"><code>conf_string</code></em> and <em class="replaceable"><code>conf_file</code></em> options are given, command use default configurations file, which is <code class="filename">/var/opt/kedr/kedr.conf</code> or <code class="filename">%prefix%/var/kedr.conf</code>.

            </p></div><div class="section" title="4.1.4. Description"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.description"></a>4.1.4. Description</h4></div></div></div><div class="section" title="4.1.4.1. kedr start"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.start"></a>4.1.4.1. kedr start</h5></div></div></div><p>
<span class="command"><strong>kedr start</strong></span> firstly loads KEDR module kedr_base. Then it translate configuration file(default or given by the options, see <a class="xref" href="using_kedr.html#kedr_control.options" title="4.1.3. Options">Section 4.1.3, “Options”</a>) in the <span class="quote">“<span class="quote">on_load</span>”</span> mode and execute all resulting strings. Finally, KEDR module kedr_controller is loaded, with target_name parameter equal to <em class="replaceable"><code>target_name</code></em>.
        </p><p>
If kedr_base module is already loaded, <span class="command"><strong>kedr start</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently loaded, <span class="command"><strong>kedr start</strong></span> does nothing and returns 1.
        </p><p>
If starting kedr_base or kedr_controller modules, or processing some line in configuration file failed(return not 0), rollback is performed. That is, all lines in configuration file, up to the failed line, are processed in <span class="quote">“<span class="quote">on_unload</span>”</span> mode, and kedr_base module is unloaded(if it was started successfully). Then 1 is returned.
        </p></div><div class="section" title="4.1.4.2. kedr stop"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.stop"></a>4.1.4.2. kedr stop</h5></div></div></div><p>
<span class="command"><strong>kedr stop</strong></span> firstly unload KEDR module kedr_controller. Then translate configuration file, that was used at the last start, in <span class="quote">“<span class="quote">on_unload</span>”</span> mode and execute resulting strings. Finally, module kedr_base is unloaded.
        </p><p>
If kedr_base module was not started, <span class="command"><strong>kedr stop</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently running, <span class="command"><strong>kedr stop</strong></span> does nothing and returns 1 error code.
        </p></div><div class="section" title="4.1.4.3. kedr status"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.status"></a>4.1.4.3. kedr status</h5></div></div></div><p>
<span class="command"><strong>kedr status</strong></span> output information about status of KEDR.
That is: whether kedr_base kernel module is loaded, what payload modules are currently loaded, whether kedr_controller module is loaded, whether module, for which controller should watch(target module), is currently loaded.
        </p></div><div class="section" title="4.1.4.4. kedr restart"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.restart"></a>4.1.4.4. kedr restart</h5></div></div></div><p>
<span class="command"><strong>kedr restart</strong></span> does efficiently same as
            </p><pre class="programlisting">
<span class="command"><strong>kedr stop</strong></span> &amp;&amp; <span class="command"><strong>kedr start</strong></span> <em class="replaceable"><code>target_name</code></em> <em class="replaceable"><code>conf_file</code></em>
            </pre><p>
with <em class="replaceable"><code>target_name</code></em> equal to current name of the target and <em class="replaceable"><code>conf_file</code></em> equal to the configuration file(default or constructed from options), with which KEDR was started last time.
        </p><p>
If kedr_base module is not currently loading, <span class="command"><strong>kedr restart</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently loading, <span class="command"><strong>kedr restart</strong></span> does nothing and returns 1.
        </p><p>
If after executing stop stage kedr_base module is loaded, start stage will not be executed and <span class="command"><strong>kedr restart</strong></span> returns 1.
        </p></div></div><div class="section" title="4.1.5. Caveats"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.caveats"></a>4.1.5. Caveats</h4></div></div></div><p>
<span class="command"><strong>kedr</strong></span> in <span class="command"><strong>start</strong></span>, <span class="command"><strong>stop</strong></span> and <span class="command"><strong>restart</strong></span> modes change state of tracepoints, breaking usage of the trace. So, capturing trace mechanizm should be not running while exectute given command in the given modes. Precisely,
<span class="command"><strong>kedr_capture_trace</strong></span> shouldn't be in capturing state and <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> shouldn't be running, while <span class="command"><strong>kedr start</strong></span>, <span class="command"><strong>kedr stop</strong></span> or <span class="command"><strong>kedr restart</strong></span> command is executed.
    </p></div><div class="section" title="4.1.6. Configuration file"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.config_file"></a>4.1.6. Configuration file</h4></div></div></div><p>
Configurations file is treated as ordered array of lines of given formats:
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <pre class="synopsis">
<code class="literal">on_load</code> <em class="replaceable"><code>shell-command</code></em>
                </pre>
            </td></tr><tr><td>
                <pre class="synopsis">
<code class="literal">on_unload</code> <em class="replaceable"><code>shell-command</code></em>
                </pre>
            </td></tr><tr><td>
                <pre class="synopsis">
<code class="literal">module</code>|<code class="literal">payload</code> <em class="replaceable"><code>module-name</code></em>|<em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
                 </pre>
            </td></tr></table><p>
    </p><p>
        Also, empty lines, lines containing only spaces and lines started with <code class="literal">#</code> are allowed and ignored when parsing configuration file.
    </p><p>
        Line, containing <em class="replaceable"><code>shell-command</code></em>, prepended by <code class="literal">on_load</code>, executed in <span class="quote">“<span class="quote">on_load</span>”</span> mode and ignored otherwise.
    </p><p>
        Line, containing <em class="replaceable"><code>shell-command</code></em>, prepended by <code class="literal">on_unload</code>, executed in <span class="quote">“<span class="quote">on_unload</span>”</span> mode and ignored otherwise.
    </p><p>
Line
        </p><pre class="synopsis">
<code class="literal">module</code> <em class="replaceable"><code>module-name</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
        </pre><p>
where <em class="replaceable"><code>module-name</code></em> is name of module or its alias, is efficiently equivalent to
        </p><pre class="programlisting">
<code class="literal">on_load</code> modprobe <em class="replaceable"><code>module-name</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
<code class="literal">on_unload</code> modprobe -r <em class="replaceable"><code>module-name</code></em> 
        </pre><p>
    </p><p>
Line
        </p><pre class="synopsis">
<code class="literal">module</code> <em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
        </pre><p>
where <em class="replaceable"><code>module-filename</code></em> is path(absolute) to the module, is efficiently equivalent to
        </p><pre class="programlisting">
<code class="literal">on_load</code> insmod <em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
<code class="literal">on_unload</code> rmmod <em class="replaceable"><code>module-filename</code></em> 
        </pre><p>
    </p><p>
Keyword <code class="literal">payload</code> at the start of the line have same meaning, as <code class="literal">module</code>, but also marks <em class="replaceable"><code>module-name</code></em> or <em class="replaceable"><code>module-filename</code></em> as payload module.
    </p><p>
        In <span class="quote">“<span class="quote">on_load</span>”</span> mode all translated lines in configuration file executed from the first to the last, in <span class="quote">“<span class="quote">on_unload</span>”</span> - from the last to the first (e.g, if module A is loaded after module B, then A unloaded before B).
    </p></div><div class="section" title="4.1.7. Examples"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.examples"></a>4.1.7. Examples</h4></div></div></div><p>
After
        </p><pre class="programlisting">
kedr start module1
        </pre><p>
KEDR will be started with default payloads and when module named <code class="literal">module1</code> will be loaded, it will be watched by the KEDR.
    </p><p>
        </p><pre class="programlisting">
kedr start module1 -c 'payload payload1 arg1 arg2' -c 'payload payload2'
        </pre><p>
do the same, but instead loading default payloads, it load payload <code class="literal">payload1</code> with arguments <code class="literal">arg1</code> <code class="literal">arg2</code> and <code class="literal">payload2</code>.
    </p><p>
If payload module <code class="literal">payload1</code> use symbols from module <code class="literal">module1</code>, then configuration file should contain
        </p><pre class="programlisting">
...
module module1
payload payload1
...
        </pre><p>
(in that order!)
    </p></div></div><div class="section" title="4.2. Capturing the Trace"><div class="titlepage"><div><div><h3 class="title"><a name="capture_trace"></a>4.2. Capturing the Trace</h3></div></div></div><div class="section" title="4.2.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.general"></a>4.2.1. General</h4></div></div></div><p>
    <span class="command"><strong>kedr_capture_trace</strong></span> - service-like tool for capture output of payloads' tracepoints into file, specified by user.
</p><p>
    <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> - script for capture output of payloads' tracepoints into file, specified by user. Wait until message about unloading of the current target is appeared in the output file, and quit.
</p></div><div class="section" title="4.2.2. Usage"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.syntax"></a>4.2.2. Usage</h4></div></div></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace start</code>   <em class="replaceable"><code>file</code></em>  [<em class="replaceable"><code>debugfs_mount_point</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace stop</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace status</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace_until_done.sh</code>   <em class="replaceable"><code>file</code></em>  [<em class="replaceable"><code>debugfs_mount_point</code></em>]</p></div></div><div class="section" title="4.2.3. Options"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_capture_trace.options"></a>4.2.3. Options</h4></div></div></div><div class="variablelist"><dl><dt><span class="term"><em class="replaceable"><code>file</code></em></span></dt><dd><p>
Path to file, where to store results of capturing. If file exitst, trace content will be appended to it content.
            </p></dd><dt><span class="term"><em class="replaceable"><code>debugfs_mount_point</code></em></span></dt><dd><p>
Directory, where debugfs filesystem is currently mounted. This filesystem contains tracing file, which will be capturing. When argument is not supplied,
it is assumed that mount point of debugfs filesystem is <code class="filename">/sys/kernel/debug</code>.
            </p></dd></dl></div></div><div class="section" title="4.2.4. Description"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.description"></a>4.2.4. Description</h4></div></div></div><div class="section" title="4.2.4.1. kedr_capture_trace start"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.start"></a>4.2.4.1. kedr_capture_trace start</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace start</strong></span> start to capturing output into tracing file and store this output into file <em class="replaceable"><code>file</code></em>. Note, that all strings, stored in <em class="replaceable"><code>file</code></em>, are deleted from tracing file.
        </p><p>
If capturing already started, <span class="command"><strong>kedr_capture_trace start</strong></span> does nothing and returns 1.
        </p></div><div class="section" title="4.2.4.2. kedr_capture_trace stop"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.stop"></a>4.2.4.2. kedr_capture_trace stop</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace stop</strong></span> stops to capturing tracing file. After this command is returned, all tracing strings are stored into tracing file as usual.
        </p><p>
If capturing is not started, <span class="command"><strong>kedr_capture_trace stop</strong></span> does nothing and returns 1.
        </p><p>
<span class="command"><strong>kedr_capture_trace start</strong></span> should not be called while <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> is running.
        </p></div><div class="section" title="4.2.4.3. kedr status"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.status"></a>4.2.4.3. kedr status</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace status</strong></span> report, whether capturing was started or not. In the future, it may also report, into what file trace is stored.
        </p></div><div class="section" title="4.2.4.4. kedr_capture_trace_until_done.sh"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.until_done"></a>4.2.4.4. kedr_capture_trace_until_done.sh</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> firstly verify, whether <em class="replaceable"><code>file</code></em> exists. If it is so, and file already contains mark of unloading target without following mark of loading target, script ends immidiately.
        </p><p>
If <em class="replaceable"><code>file</code></em> doesn't exist, or it doesn't contain mark of last target unloading, script starts to capture trace into <em class="replaceable"><code>file</code></em> (in the appending mode). Calling process is blocked until mark of unloading target appears in the <em class="replaceable"><code>file</code></em>. After that, script stop capturing and returns.
        </p></div></div><div class="section" title="4.2.5. Caveats"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.caveats"></a>4.2.5. Caveats</h4></div></div></div><p>
Because both <span class="command"><strong>kedr_capture_trace</strong></span> and <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> programs capture physycally one trace, them should't be used simultaneously. That is, <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> shouldn't be called while <span class="command"><strong>kedr_capture_trace</strong></span> is in capturing state, and <span class="command"><strong>kedr_capture_trace start</strong></span> shouldn't be called while <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> is running.
    </p></div><div class="section" title="4.2.6. Examples"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.examples"></a>4.2.6. Examples</h4></div></div></div><p>
Will be in the getted started.    
    </p></div></div><div class="section" title="4.3. How KEDR Works"><div class="titlepage"><div><div><h3 class="title"><a name="how_kedr_works"></a>4.3. How KEDR Works</h3></div></div></div><p>
The interaction between the software components involved in driver 
analysis with KEDR is outlined at the figure below. The logical components 
related to KEDR are colored in green.
</p><div class="mediaobject"><img src="images/system_architecture.png" alt="KEDR: system architecture"></div><p>
The user controls the analysis process via convenience API and tools 
(<em class="firstterm"><span class="quote">“<span class="quote">Kernel Module Analysis API + Tools</span>”</span></em> 
on the figure) - either manually or via a user-space application. 
</p><p>
The actual analysis of the target kernel module (driver) is performed by 
<a class="link" href="glossary.html#payload_module" title="Payload module">payload modules</a> of different types. 
</p><p>
If the target module tries to call a function which one of the payload 
modules is interested in (<a class="link" href="glossary.html#target_function" title="Target function"><em class="firstterm">target 
function</em></a>), that payload module takes control and executes
the corresponding <a class="link" href="glossary.html#replacement_function" title="Replacement function"><em class="firstterm">replacement
function</em></a> instead. This way, the payload
module can get access to the arguments of the target function. In addition,
the payload module can change the behaviour of the target driver, for 
example make it look like the target function has failed, etc.
</p><div class="itemizedlist"><p>
Payload modules can do various things:
</p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Collect data about which function was called when, with what arguments, and
what it returned (<em class="firstterm"><span class="quote">“<span class="quote">Call Monitor</span>”</span></em> 
on the figure). The data is output to a trace 
(via <em class="firstterm"><span class="quote">“<span class="quote">Data Collector</span>”</span></em> facilities) 
and can then be analyzed by user-space applications.
</p></li><li class="listitem"><p>
Simulate the situations when the kernel seems to fail to satisfy some of 
the requests made by the target driver 
(<em class="firstterm"><span class="quote">“<span class="quote">Fault Similator</span>”</span></em> on the 
figure). That is, simulate low memory conditions, etc. Fault simulation is 
performed according to the <em class="firstterm">scenarios</em> selected by the 
user. It can be used to check if the driver is still reliable in error 
conditions, if possible failures of the called functions are properly 
handled by the driver, etc. 
    </p><p>
The <em class="firstterm"><span class="quote">“<span class="quote">Control Interface</span>”</span></em> is used here, 
for example, to manage the fault simulation scenarios, etc.
</p></li><li class="listitem"><p>
Check various requirements for the operation of the driver 
(<em class="firstterm"><span class="quote">“<span class="quote">Base Checker</span>”</span></em> on the figure): whether 
it properly copies data to and from user space, whether it 
uses virtual memory facilities in a right way, etc. 
</p></li><li class="listitem"><p>
...And much more (see <a class="xref" href="extend.html#custom_analysis" title="5.4. Implementing New Types of Analysis">Section 5.4, “Implementing New Types of Analysis”</a>).
</p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Currently, KEDR already provides the sets of payload modules to perform 
call monitoring and fault simulation. Payload modules for other types of 
analysis can be developed separately.
</p></div><p>
When loaded, payload modules register themselves with the KEDR core 
(<code class="filename">kedr-base</code> module, actually) - see 
<a class="xref" href="extend.html#payload_api" title="5.2. API for Payload Modules">Section 5.2, “API for Payload Modules”</a>.
</p><p>
For the payload modules to be able to work, the KEDR core must instrument 
the calls in the memory image of the target driver. The KEDR core has the 
means to detect loading of the target driver (<em class="firstterm"><span class="quote">“<span class="quote">Loading 
Detector</span>”</span></em> on the figure). After the driver is loaded but 
before it begins to execute its initialization function, the KEDR core 
instruments the calls in it (<em class="firstterm"><span class="quote">“<span class="quote">Call Instrumentation 
Facilities</span>”</span></em> on the figure). Technically, loading detection
and call instrumentation are performed by <code class="filename">kedr-controller</code> 
module.
</p><div class="orderedlist"><p>
<a class="link" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">KEDR service script</a> makes sure each 
component of KEDR is loaded in proper order. It does roughly the following 
(the more precise description is available in <a class="xref" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">Section 4.1, “Controlling KEDR”</a>):
</p><ol class="orderedlist" type="1"><li class="listitem"><p>
Loads the <code class="filename">kedr-base</code> module responsible to keep track 
of payload modules and to provide API to them.
</p></li><li class="listitem"><p>
Loads the payload modules listed in the configuration file. Each payload 
module should register itself with the KEDR core by calling (see <a class="xref" href="extend.html#payload_api" title="5.2. API for Payload Modules">Section 5.2, “API for Payload Modules”</a>), this is usually done in its init function.
</p></li><li class="listitem"><p>
Loads the <code class="filename">kedr-controller</code> module passing it the name 
of the target module as a parameter (<span class="quote">“<span class="quote">target_name</span>”</span>). From 
this moment, the KEDR core begins watching for the specified target module 
to load (see also <a class="xref" href="getting_started.html" title="3. Getting Started">Section 3, “Getting Started”</a>).
</p></li></ol></div><p>
When the analysis is done, the <a class="link" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">KEDR service 
script</a> unloads the modules mentioned above, in appropriate order.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the KEDR core (<code class="filename">kedr-base</code> and 
<code class="filename">kedr-controller</code> modules) makes no assumptions about what 
exactly the currently registered payload modules do. This allows to 
implement different types of analysis with the help of KEDR.
</p></div></div><div class="section" title="4.4. Call Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="call_mon"></a>4.4. Call Monitoring</h3></div></div></div>

TODO: describe how use KEDR call monitoring facilities and how to choose 
among the provided payload modules, etc. 

The calls to which functions can be monitored - ?

Describe the appropriate examples too.

</div><div class="section" title="4.5. Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="fault_sim"></a>4.5. Fault Simulation</h3></div></div></div>

TODO: describe how use KEDR fault simulation facilities and how to customize the set of functions to be affected and the scenarios (using the canned ones or providing your own).

Describe the appropriate examples too.

</div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="getting_started.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="extend.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3. Getting Started </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5. Customizing and Extending KEDR</td></tr></table></div></body></html>
