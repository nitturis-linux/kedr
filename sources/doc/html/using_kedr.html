<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>4. Using KEDR</title><link rel="stylesheet" href="kedr-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="prev" href="getting_started.html" title="3. Getting Started"><link rel="next" href="extend.html" title="5. Customizing and Extending KEDR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. Using KEDR</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="getting_started.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="extend.html">Next</a></td></tr></table><hr></div><div class="section" title="4. Using KEDR"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="using_kedr"></a>4. Using KEDR</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="using_kedr.html#kedr_control">4.1. Controlling KEDR</a></span></dt><dd><dl><dt><span class="section"><a href="using_kedr.html#kedr_control.general">4.1.1. General</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.syntax">4.1.2. Usage</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.options">4.1.3. Options</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.description">4.1.4. Description</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.caveats">4.1.5. Caveats</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.config_file">4.1.6. Configuration file</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_control.examples">4.1.7. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="using_kedr.html#capture_trace">4.2. Capturing the Trace</a></span></dt><dd><dl><dt><span class="section"><a href="using_kedr.html#capture_trace.general">4.2.1. General</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.syntax">4.2.2. Usage</a></span></dt><dt><span class="section"><a href="using_kedr.html#kedr_capture_trace.options">4.2.3. Options</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.description">4.2.4. Description</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.caveats">4.2.5. Caveats</a></span></dt><dt><span class="section"><a href="using_kedr.html#capture_trace.examples">4.2.6. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="using_kedr.html#how_kedr_works">4.3. How KEDR Works</a></span></dt><dt><span class="section"><a href="using_kedr.html#call_mon">4.4. Call Monitoring</a></span></dt><dt><span class="section"><a href="using_kedr.html#fault_sim">4.5. Fault Simulation</a></span></dt></dl></div><div class="section" title="4.1. Controlling KEDR"><div class="titlepage"><div><div><h3 class="title"><a name="kedr_control"></a>4.1. Controlling KEDR</h3></div></div></div><div class="section" title="4.1.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.general"></a>4.1.1. General</h4></div></div></div><p>
    <span class="command"><strong>kedr</strong></span> - service-like tool for simplify control of KEDR.
</p></div><div class="section" title="4.1.2. Usage"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.syntax"></a>4.1.2. Usage</h4></div></div></div><div class="cmdsynopsis"><p><code class="command">kedr start</code>   <em class="replaceable"><code>target_name</code></em>  [ -c <em class="replaceable"><code>conf_string</code></em>  |   <em class="replaceable"><code>conf_file</code></em> ...]</p></div><div class="cmdsynopsis"><p><code class="command">kedr stop</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr status</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr restart</code> </p></div></div><div class="section" title="4.1.3. Options"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.options"></a>4.1.3. Options</h4></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="option">-c</code> <em class="replaceable"><code>conf_string</code></em></span></dt><dd><p>
Use configuration string <em class="replaceable"><code>conf_string</code></em> instead of default configuration file.
            </p></dd><dt><span class="term"><em class="replaceable"><code>conf_file</code></em></span></dt><dd><p>
Use configuration file <em class="replaceable"><code>conf_file</code></em> instead of default configuration file.
            </p></dd></dl></div><p>
All <em class="replaceable"><code>conf_string</code></em> and(or) <em class="replaceable"><code>conf_file</code></em>, which appears in the command options, joined into one configuration file in the same order, as them appear in the command line, and resulting file is used as configuration file for the command.
            </p><p>
If no <em class="replaceable"><code>conf_string</code></em> and <em class="replaceable"><code>conf_file</code></em> options are given, command use default configurations file, which is <code class="filename">/var/opt/kedr/kedr.conf</code> or <code class="filename">%prefix%/var/kedr.conf</code>.

            </p></div><div class="section" title="4.1.4. Description"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.description"></a>4.1.4. Description</h4></div></div></div><div class="section" title="4.1.4.1. kedr start"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.start"></a>4.1.4.1. kedr start</h5></div></div></div><p>
<span class="command"><strong>kedr start</strong></span> firstly loads KEDR module kedr_base. Then it translate configuration file(default or given by the options, see <a class="xref" href="using_kedr.html#kedr_control.options" title="4.1.3. Options">Section 4.1.3, “Options”</a>) in the <span class="quote">“<span class="quote">on_load</span>”</span> mode and execute all resulting strings. Finally, KEDR module kedr_controller is loaded, with target_name parameter equal to <em class="replaceable"><code>target_name</code></em>.
        </p><p>
If kedr_base module is already loaded, <span class="command"><strong>kedr start</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently loaded, <span class="command"><strong>kedr start</strong></span> does nothing and returns 1.
        </p><p>
If starting kedr_base or kedr_controller modules, or processing some line in configuration file failed(return not 0), rollback is performed. That is, all lines in configuration file, up to the failed line, are processed in <span class="quote">“<span class="quote">on_unload</span>”</span> mode, and kedr_base module is unloaded(if it was started successfully). Then 1 is returned.
        </p></div><div class="section" title="4.1.4.2. kedr stop"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.stop"></a>4.1.4.2. kedr stop</h5></div></div></div><p>
<span class="command"><strong>kedr stop</strong></span> firstly unload KEDR module kedr_controller. Then translate configuration file, that was used at the last start, in <span class="quote">“<span class="quote">on_unload</span>”</span> mode and execute resulting strings. Finally, module kedr_base is unloaded.
        </p><p>
If kedr_base module was not started, <span class="command"><strong>kedr stop</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently running, <span class="command"><strong>kedr stop</strong></span> does nothing and returns 1 error code.
        </p></div><div class="section" title="4.1.4.3. kedr status"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.status"></a>4.1.4.3. kedr status</h5></div></div></div><p>
<span class="command"><strong>kedr status</strong></span> output information about status of KEDR.
That is: whether kedr_base kernel module is loaded, what payload modules are currently loaded, whether kedr_controller module is loaded, whether module, for which controller should watch(target module), is currently loaded.
        </p></div><div class="section" title="4.1.4.4. kedr restart"><div class="titlepage"><div><div><h5 class="title"><a name="kedr_control.description.restart"></a>4.1.4.4. kedr restart</h5></div></div></div><p>
<span class="command"><strong>kedr restart</strong></span> does efficiently same as
            </p><pre class="programlisting">
<span class="command"><strong>kedr stop</strong></span> &amp;&amp; <span class="command"><strong>kedr start</strong></span> <em class="replaceable"><code>target_name</code></em> <em class="replaceable"><code>conf_file</code></em>
            </pre><p>
with <em class="replaceable"><code>target_name</code></em> equal to current name of the target and <em class="replaceable"><code>conf_file</code></em> equal to the configuration file(default or constructed from options), with which KEDR was started last time.
        </p><p>
If kedr_base module is not currently loading, <span class="command"><strong>kedr restart</strong></span> does nothing and returns 1.
        </p><p>
If module with name <em class="replaceable"><code>target_name</code></em> is currently loading, <span class="command"><strong>kedr restart</strong></span> does nothing and returns 1.
        </p><p>
If after executing stop stage kedr_base module is loaded, start stage will not be executed and <span class="command"><strong>kedr restart</strong></span> returns 1.
        </p></div></div><div class="section" title="4.1.5. Caveats"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.caveats"></a>4.1.5. Caveats</h4></div></div></div><p>
<span class="command"><strong>kedr</strong></span> in <span class="command"><strong>start</strong></span>, <span class="command"><strong>stop</strong></span> and <span class="command"><strong>restart</strong></span> modes change state of tracepoints, breaking usage of the trace. So, capturing trace mechanizm should be not running while exectute given command in the given modes. Precisely,
<span class="command"><strong>kedr_capture_trace</strong></span> shouldn't be in capturing state and <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> shouldn't be running, while <span class="command"><strong>kedr start</strong></span>, <span class="command"><strong>kedr stop</strong></span> or <span class="command"><strong>kedr restart</strong></span> command is executed.
    </p></div><div class="section" title="4.1.6. Configuration file"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.config_file"></a>4.1.6. Configuration file</h4></div></div></div><p>
Configurations file is treated as ordered array of lines of given formats:
        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>
                <pre class="synopsis">
<code class="literal">on_load</code> <em class="replaceable"><code>shell-command</code></em>
                </pre>
            </td></tr><tr><td>
                <pre class="synopsis">
<code class="literal">on_unload</code> <em class="replaceable"><code>shell-command</code></em>
                </pre>
            </td></tr><tr><td>
                <pre class="synopsis">
<code class="literal">module</code>|<code class="literal">payload</code> <em class="replaceable"><code>module-name</code></em>|<em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
                 </pre>
            </td></tr></table><p>
    </p><p>
        Also, empty lines, lines containing only spaces and lines started with <code class="literal">#</code> are allowed and ignored when parsing configuration file.
    </p><p>
        Line, containing <em class="replaceable"><code>shell-command</code></em>, prepended by <code class="literal">on_load</code>, executed in <span class="quote">“<span class="quote">on_load</span>”</span> mode and ignored otherwise.
    </p><p>
        Line, containing <em class="replaceable"><code>shell-command</code></em>, prepended by <code class="literal">on_unload</code>, executed in <span class="quote">“<span class="quote">on_unload</span>”</span> mode and ignored otherwise.
    </p><p>
Line
        </p><pre class="synopsis">
<code class="literal">module</code> <em class="replaceable"><code>module-name</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
        </pre><p>
where <em class="replaceable"><code>module-name</code></em> is name of module or its alias, is efficiently equivalent to
        </p><pre class="programlisting">
<code class="literal">on_load</code> modprobe <em class="replaceable"><code>module-name</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
<code class="literal">on_unload</code> modprobe -r <em class="replaceable"><code>module-name</code></em> 
        </pre><p>
    </p><p>
Line
        </p><pre class="synopsis">
<code class="literal">module</code> <em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
        </pre><p>
where <em class="replaceable"><code>module-filename</code></em> is path(absolute) to the module, is efficiently equivalent to
        </p><pre class="programlisting">
<code class="literal">on_load</code> insmod <em class="replaceable"><code>module-filename</code></em> [<span class="optional"><em class="replaceable"><code>parameters...</code></em></span>]
<code class="literal">on_unload</code> rmmod <em class="replaceable"><code>module-filename</code></em> 
        </pre><p>
    </p><p>
Keyword <code class="literal">payload</code> at the start of the line have same meaning, as <code class="literal">module</code>, but also marks <em class="replaceable"><code>module-name</code></em> or <em class="replaceable"><code>module-filename</code></em> as payload module.
    </p><p>
        In <span class="quote">“<span class="quote">on_load</span>”</span> mode all translated lines in configuration file executed from the first to the last, in <span class="quote">“<span class="quote">on_unload</span>”</span> - from the last to the first (e.g, if module A is loaded after module B, then A unloaded before B).
    </p></div><div class="section" title="4.1.7. Examples"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_control.examples"></a>4.1.7. Examples</h4></div></div></div><p>
After
        </p><pre class="programlisting">
kedr start module1
        </pre><p>
KEDR will be started with default payloads and when module named <code class="literal">module1</code> will be loaded, it will be watched by the KEDR.
    </p><p>
        </p><pre class="programlisting">
kedr start module1 -c 'payload payload1 arg1 arg2' -c 'payload payload2'
        </pre><p>
do the same, but instead loading default payloads, it load payload <code class="literal">payload1</code> with arguments <code class="literal">arg1</code> <code class="literal">arg2</code> and <code class="literal">payload2</code>.
    </p><p>
If payload module <code class="literal">payload1</code> use symbols from module <code class="literal">module1</code>, then configuration file should contain
        </p><pre class="programlisting">
...
module module1
payload payload1
...
        </pre><p>
(in that order!)
    </p></div></div><div class="section" title="4.2. Capturing the Trace"><div class="titlepage"><div><div><h3 class="title"><a name="capture_trace"></a>4.2. Capturing the Trace</h3></div></div></div><div class="section" title="4.2.1. General"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.general"></a>4.2.1. General</h4></div></div></div><p>
    <span class="command"><strong>kedr_capture_trace</strong></span> - service-like tool for capture output of payloads' tracepoints into file, specified by user.
</p><p>
    <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> - script for capture output of payloads' tracepoints into file, specified by user. Wait until message about unloading of the current target is appeared in the output file, and quit.
</p></div><div class="section" title="4.2.2. Usage"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.syntax"></a>4.2.2. Usage</h4></div></div></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace start</code>   <em class="replaceable"><code>file</code></em>  [<em class="replaceable"><code>debugfs_mount_point</code></em>]</p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace stop</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace status</code> </p></div><div class="cmdsynopsis"><p><code class="command">kedr_capture_trace_until_done.sh</code>   <em class="replaceable"><code>file</code></em>  [<em class="replaceable"><code>debugfs_mount_point</code></em>]</p></div></div><div class="section" title="4.2.3. Options"><div class="titlepage"><div><div><h4 class="title"><a name="kedr_capture_trace.options"></a>4.2.3. Options</h4></div></div></div><div class="variablelist"><dl><dt><span class="term"><em class="replaceable"><code>file</code></em></span></dt><dd><p>
Path to file, where to store results of capturing. If file exitst, trace content will be appended to it content.
            </p></dd><dt><span class="term"><em class="replaceable"><code>debugfs_mount_point</code></em></span></dt><dd><p>
Directory, where debugfs filesystem is currently mounted. This filesystem contains tracing file, which will be capturing. When argument is not supplied,
it is assumed that mount point of debugfs filesystem is <code class="filename">/sys/kernel/debug</code>.
            </p></dd></dl></div></div><div class="section" title="4.2.4. Description"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.description"></a>4.2.4. Description</h4></div></div></div><div class="section" title="4.2.4.1. kedr_capture_trace start"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.start"></a>4.2.4.1. kedr_capture_trace start</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace start</strong></span> start to capturing output into tracing file and store this output into file <em class="replaceable"><code>file</code></em>. Note, that all strings, stored in <em class="replaceable"><code>file</code></em>, are deleted from tracing file.
        </p><p>
If capturing already started, <span class="command"><strong>kedr_capture_trace start</strong></span> does nothing and returns 1.
        </p></div><div class="section" title="4.2.4.2. kedr_capture_trace stop"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.stop"></a>4.2.4.2. kedr_capture_trace stop</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace stop</strong></span> stops to capturing tracing file. After this command is returned, all tracing strings are stored into tracing file as usual.
        </p><p>
If capturing is not started, <span class="command"><strong>kedr_capture_trace stop</strong></span> does nothing and returns 1.
        </p><p>
<span class="command"><strong>kedr_capture_trace start</strong></span> should not be called while <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> is running.
        </p></div><div class="section" title="4.2.4.3. kedr status"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.status"></a>4.2.4.3. kedr status</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace status</strong></span> report, whether capturing was started or not. In the future, it may also report, into what file trace is stored.
        </p></div><div class="section" title="4.2.4.4. kedr_capture_trace_until_done.sh"><div class="titlepage"><div><div><h5 class="title"><a name="capture_trace.description.until_done"></a>4.2.4.4. kedr_capture_trace_until_done.sh</h5></div></div></div><p>
<span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> firstly verify, whether <em class="replaceable"><code>file</code></em> exists. If it is so, and file already contains mark of unloading target without following mark of loading target, script ends immidiately.
        </p><p>
If <em class="replaceable"><code>file</code></em> doesn't exist, or it doesn't contain mark of last target unloading, script starts to capture trace into <em class="replaceable"><code>file</code></em> (in the appending mode). Calling process is blocked until mark of unloading target appears in the <em class="replaceable"><code>file</code></em>. After that, script stop capturing and returns.
        </p></div></div><div class="section" title="4.2.5. Caveats"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.caveats"></a>4.2.5. Caveats</h4></div></div></div><p>
Because both <span class="command"><strong>kedr_capture_trace</strong></span> and <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> programs capture physycally one trace, them should't be used simultaneously. That is, <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> shouldn't be called while <span class="command"><strong>kedr_capture_trace</strong></span> is in capturing state, and <span class="command"><strong>kedr_capture_trace start</strong></span> shouldn't be called while <span class="command"><strong>kedr_capture_trace_until_done.sh</strong></span> is running.
    </p></div><div class="section" title="4.2.6. Examples"><div class="titlepage"><div><div><h4 class="title"><a name="capture_trace.examples"></a>4.2.6. Examples</h4></div></div></div><p>
Will be in the getted started.    
    </p></div></div><div class="section" title="4.3. How KEDR Works"><div class="titlepage"><div><div><h3 class="title"><a name="how_kedr_works"></a>4.3. How KEDR Works</h3></div></div></div><p>
The interaction between the software components involved in driver 
analysis with KEDR is outlined at the figure below. The logical components 
related to KEDR are colored in green.
</p><div class="mediaobject"><img src="images/system_architecture.png" alt="KEDR: system architecture"></div><p>
The user controls the analysis process via convenience API and tools 
(<em class="firstterm"><span class="quote">“<span class="quote">Kernel Module Analysis API + Tools</span>”</span></em> 
on the figure) - either manually or via a user-space application. 
</p><p>
The actual analysis of the target kernel module (driver) is performed by 
<a class="link" href="glossary.html#payload_module" title="Payload module">payload modules</a> of different types. 
</p><p>
If the target module tries to call a function which one of the payload 
modules is interested in (<a class="link" href="glossary.html#target_function" title="Target function"><em class="firstterm">target 
function</em></a>), that payload module takes control and executes
the corresponding <a class="link" href="glossary.html#replacement_function" title="Replacement function"><em class="firstterm">replacement
function</em></a> instead. This way, the payload
module can get access to the arguments of the target function. In addition,
the payload module can change the behaviour of the target driver, for 
example make it look like the target function has failed, etc.
</p><div class="itemizedlist"><p>
Payload modules can do various things:
</p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Collect data about which function was called when, with what arguments, and
what it returned (<em class="firstterm"><span class="quote">“<span class="quote">Call Monitor</span>”</span></em> 
on the figure). The data is output to a trace 
(via <em class="firstterm"><span class="quote">“<span class="quote">Data Collector</span>”</span></em> facilities) 
and can then be analyzed by user-space applications.
</p></li><li class="listitem"><p>
Simulate the situations when the kernel seems to fail to satisfy some of 
the requests made by the target driver 
(<em class="firstterm"><span class="quote">“<span class="quote">Fault Similator</span>”</span></em> on the 
figure). That is, simulate low memory conditions, etc. Fault simulation is 
performed according to the <em class="firstterm">scenarios</em> selected by the 
user. It can be used to check if the driver is still reliable in error 
conditions, if possible failures of the called functions are properly 
handled by the driver, etc. 
    </p><p>
The <em class="firstterm"><span class="quote">“<span class="quote">Control Interface</span>”</span></em> is used here, 
for example, to manage the fault simulation scenarios, etc.
</p></li><li class="listitem"><p>
Check various requirements for the operation of the driver 
(<em class="firstterm"><span class="quote">“<span class="quote">Base Checker</span>”</span></em> on the figure): whether 
it properly copies data to and from user space, whether it 
uses virtual memory facilities in a right way, etc. 
</p></li><li class="listitem"><p>
...And much more (see <a class="xref" href="extend.html#custom_analysis" title="5.5. Implementing Custom Types of Analysis">Section 5.5, “Implementing Custom Types of Analysis”</a>).
</p></li></ul></div><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Currently, KEDR already provides the sets of payload modules to perform 
call monitoring and fault simulation. Payload modules for other types of 
analysis can be developed separately.
</p></div><p>
When loaded, payload modules register themselves with the KEDR core 
(<code class="filename">kedr-base</code> module, actually) - see 
<a class="xref" href="reference.html#payload_api" title="6.1. API for Payload Modules">Section 6.1, “API for Payload Modules”</a>.
</p><p>
For the payload modules to be able to work, the KEDR core must instrument 
the calls in the memory image of the target driver. The KEDR core has the 
means to detect loading of the target driver (<em class="firstterm"><span class="quote">“<span class="quote">Loading 
Detector</span>”</span></em> on the figure). After the driver is loaded but 
before it begins to execute its initialization function, the KEDR core 
instruments the calls in it (<em class="firstterm"><span class="quote">“<span class="quote">Call Instrumentation 
Facilities</span>”</span></em> on the figure). Technically, loading detection
and call instrumentation are performed by <code class="filename">kedr-controller</code> 
module.
</p><div class="orderedlist"><p>
<a class="link" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">KEDR service script</a> makes sure each 
component of KEDR is loaded in proper order. It does roughly the following 
(the more precise description is available in <a class="xref" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">Section 4.1, “Controlling KEDR”</a>):
</p><ol class="orderedlist" type="1"><li class="listitem"><p>
Loads the <code class="filename">kedr-base</code> module responsible to keep track 
of payload modules and to provide API to them.
</p></li><li class="listitem"><p>
Loads the payload modules listed in the configuration file. Each payload 
module should register itself with the KEDR core by calling (see <a class="xref" href="reference.html#payload_api" title="6.1. API for Payload Modules">Section 6.1, “API for Payload Modules”</a>), this is usually done in its init function.
</p></li><li class="listitem"><p>
Loads the <code class="filename">kedr-controller</code> module passing it the name 
of the target module as a parameter (<span class="quote">“<span class="quote">target_name</span>”</span>). From 
this moment, the KEDR core begins watching for the specified target module 
to load (see also <a class="xref" href="getting_started.html" title="3. Getting Started">Section 3, “Getting Started”</a>).
</p></li></ol></div><p>
When the analysis is done, the <a class="link" href="using_kedr.html#kedr_control" title="4.1. Controlling KEDR">KEDR service 
script</a> unloads the modules mentioned above, in appropriate order.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the KEDR core (<code class="filename">kedr-base</code> and 
<code class="filename">kedr-controller</code> modules) makes no assumptions about what 
exactly the currently registered payload modules do. This allows to 
implement different types of analysis with the help of KEDR.
</p></div></div><div class="section" title="4.4. Call Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="call_mon"></a>4.4. Call Monitoring</h3></div></div></div><p>
Call monitoring is a way of using replacement function to collect statistics about target functions calls.
    </p><p>
KEDR contains collection of payloads, which may be used for call monitoring purpose. They store information about what kernel functions was called from the target module and in what order, parameters, which was passed to this functions and result returned. Then this information may be used by user-space application at runtime with the help of <a class="link" href="using_kedr.html#capture_trace" title="4.2. Capturing the Trace">kedr_capture_trace</a> tool.
    </p><p>
Format of information stored is similar to the trace format of the ftrace tool.
Here is example of such trace (header line is shown only for description purpose):
    </p><pre class="programlisting">
  TASK-PID CPU#  TIMESTAMP     FUNCTION
--------------------------------------------------------------------
insmod-709 [000] 99689.618433: target_session_begins: target_module: "kedr_sample_target"
insmod-709 [000] 99689.627529: called___kmalloc: arguments(184, d0), result: d80c3600
dd-743 [000] 99861.116151: called___kmalloc: arguments(4000, d0), result: decaa000
dd-743 [000] 99861.116614: called_copy_from_user: arguments(decaa000, 09b00000, 1), result: 0
...
rmmod-17250 [000] 102326.651693: target_session_ends: target_module: "kedr_sample_target"
    </pre><p>
'FUNCTION' field has format <code class="code">called_&lt;function-name&gt;: arguments(&lt;arguments-list&gt;), result:&lt;value-returned&gt;</code> for functions calls and <code class="code">target_session_&lt;begins|end&gt;: target_module: "&lt;target-module-name&gt;"</code> for markers of load and unload target module.
    </p><p>
Only calls to the subset of all kernel functions is detected, but this subset may be easy extended by implemented you own modules (see <a class="xref" href="extend.html#custom_callm_payloads" title="5.2. Writing Custom Payloads for Call Monitoring">Section 5.2, “Writing Custom Payloads for Call Monitoring”</a>). Here is a full list of the payload modules, which may be used for call monitoring, and lists of functions, detected by each module. (Function name in '[' and ']' means, that this function is detected only if it is exported by the kernel; only one of functions, delimited by '/', is detected, depended on which of them is exported by the kernel).
    </p><p>
</p><div class="itemizedlist"><ul class="itemizedlist" type="opencircle"><li class="listitem" style="list-style-type: circle">kedr_cm_cmm.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>__kmalloc</td></tr><tr><td>krealloc</td></tr><tr><td>kfree</td></tr><tr><td>kmem_cache_alloc</td></tr><tr><td>[kmem_cache_alloc_notrace]</td></tr><tr><td>kmem_cache_free</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_user_space_access.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>copy_to_user/_copy_to_user</td></tr><tr><td>copy_from_user/_copy_from_user</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_mutexes.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>__mutex_init</td></tr><tr><td>mutex_lock</td></tr><tr><td>mutex_lock_interruptible</td></tr><tr><td>mutex_trylock</td></tr><tr><td>mutex_unlock</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_spinlocks.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>_spin_lock_irqsave/_raw_spin_lock_irqsave</td></tr><tr><td>_spin_unlock_irqrestore/_raw_spin_unlock_irqrestore</td></tr></table>
    additionally, with "enable_full_spinlock" option set,
    <table border="0" summary="Simple list" class="simplelist"><tr><td>_spin_lock/_raw_spin_lock</td></tr><tr><td>_spin_lock_irq/_raw_spin_lock_irq</td></tr><tr><td>_spin_unlock/_raw_spin_unlock</td></tr><tr><td>_spin_unlock_irq/_raw_spin_unlock_irq</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_waitqueue.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>__wake_up</td></tr><tr><td>init_waitqueue_head/__init_waitqueue_head</td></tr><tr><td>prepare_to_wait</td></tr><tr><td>finish_wait</td></tr><tr><td>remove_wait_queue</td></tr><tr><td>add_wait_queue</td></tr><tr><td>add_wait_queue_exclusive</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_capable.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>capable&gt;</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_vmm.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>vmalloc</td></tr><tr><td>__vmalloc</td></tr><tr><td>vmalloc_user</td></tr><tr><td>vmalloc_node</td></tr><tr><td>vmalloc_32</td></tr><tr><td>vfree</td></tr></table></li><li class="listitem" style="list-style-type: circle">kedr_cm_schedule.ko:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>schedule</td></tr><tr><td>[preempt_schedule]</td></tr><tr><td>_cond_resched</td></tr><tr><td>schedule_timeout</td></tr><tr><td>schedule_timeout_uninterruptible</td></tr><tr><td>schedule_timeout_interruptible</td></tr><tr><td>io_schedule</td></tr><tr><td>cond_resched_lock/__cond_resched_lock</td></tr></table></li></ul></div><p>
    </p></div><div class="section" title="4.5. Fault Simulation"><div class="titlepage"><div><div><h3 class="title"><a name="fault_sim"></a>4.5. Fault Simulation</h3></div></div></div><p>
Fault simulation is a way of using replacement function to emulate fail of the corresponding target function. The decision whether emulate or do not emulate fail (last case means to emulate normal work of the target function) is made according to the some scenario.
    </p><p>
In the KEDR such replacement functions and scenarios are fully independent: replacement function may be written by one author, scenario - by another one, and the person, who need to use some scenario for some function, can simply assign scenario for the replacement function at runtime.
    </p><p>
KEDR contains collection of payloads, each of which may be used for performing fault simulation of a set of the kernel functions. Also, these payloads perfom call monitoring of all functions them replace. Information, which stored by this call monitoring, and methods for work with this information are excatly the same as for standard KEDR call monitoring payloads (see <a class="xref" href="using_kedr.html#call_mon" title="4.4. Call Monitoring">Section 4.4, “Call Monitoring”</a>). Of cource, in the case of fail emulation, result of this emulation will be stored, instead of the regular result of the target function. (Because the result of emulation will be returned to the caller).
    </p><p>
By default, scenario for fault simulation is "never emulate fail", so all fault simulation payloads work as is they are simple call monitor payloads. For manage scenarios, each payload export one or more directories like <code class="filename">/sys/kernel/debug/kedr_fault_simulation/points/&lt;function-name&gt;</code>, where <code class="code">&lt;function-name&gt;</code> is a name of the kernel function, which fault simulation scenario is managed. (It is assumed, that debugfs filesystem is mounted to <code class="filename">/sys/kernel/debug</code>). Each such directory contains file <code class="filename">current_indicator</code>, which reflect a name of the <a class="link" href="glossary.html#fault_simulation_indicator" title="Fault simulation indicator">fault simulation indicator</a>, which is currently used for the function. In abstract, fault simulation indicator is a function, which is called whenever payload need to decide, whether it need to simulate target function fail. If this function returns not zero, then decision to simulate fail is made. You might say, that indicator <span class="emphasis"><em>implements</em></span> fault simulation scenario. Reading from file <code class="filename">current_indicator</code> return name of currently used indicator, writing name of some indicator to this file set this indicator for the function.
    </p><p>
Examples:
    </p><pre class="programlisting">
cat /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
in case when fault simulation payload, replacing <code class="function">__kmalloc</code>, has just loaded, print <code class="computeroutput">none</code> - none indicator is currently set.
    </p><pre class="programlisting">
echo common &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
set indicator with name <span class="quote">“<span class="quote">common</span>”</span> for <code class="function">__kmalloc</code>, so subsequent
    </p><pre class="programlisting">
cat /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
print <code class="computeroutput">common</code>.
    </p><pre class="programlisting">
echo unknown_indicator_name &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
print something like <code class="computeroutput">bash: echo: write error: Operation not permitted</code>, if indicator with name <span class="quote">“<span class="quote">unknown_indicator_name</span>”</span> is not exist.
    </p><p>
KEDR provide a set of kernel modules, which implement indicators for different purpose. Each such module export directory <code class="filename">/sys/kernel/debug/kedr_fault_simulation/points/&lt;indicator-name&gt;</code>, where <code class="code">&lt;indicator-name&gt;</code> is the name which identify indicator, exported by the module. Really, each indicator implements not only one scenario, but parametrized family of them. How to change parameters of scenario, used by indicator, will be describe later....This parametrization may be performed when indicator is assigned to the function (via writing string like <code class="code">&lt;indicator-name&gt; &lt;indicator-params&gt;</code> into function's file <code class="filename">current_indicator</code>) or at runtime.
    </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
Each function use its own instance of indicator, and changing parameters of the indicator affects only to the instance, to which this changing is applied. Even if indicator with same name is used for other functions, parameters of other instances of the indicator do not change.
    </div><p>
    </p><p>
Indicator with name <span class="quote">“<span class="quote">common</span>”</span> is the common indicator, which may be used for any function. By default, it's function always return 0 (<span class="quote">“<span class="quote">never to simulate</span>”</span>). But after it is set, it creates two files in the <code class="filename">/sys/kernel/debug/kedr_fault_simulation/points/&lt;function-name&gt;</code> directory: <code class="filename">expression</code> and <code class="filename">pid</code>. 
    </p><p>
File <code class="filename">expression</code> reflect the mathematical expression, which result is used as returning value of indicator's function. Reading from this file returns expression, currently used by indicator's function. Writing some expression to this file force indicator's function to use this expression. Expression may contain:
</p><div class="itemizedlist"><ul class="itemizedlist" type="opencircle"><li class="listitem" style="list-style-type: circle">signed decimal integer numbers
</li><li class="listitem" style="list-style-type: circle">any mathematical operation from list:
    <table border="0" summary="Simple list" class="simplelist"><tr><td>"!" - logical not</td></tr><tr><td>"~" - binary not</td></tr><tr><td>"+" - unary plus</td></tr><tr><td>"-" - unary minus</td></tr><tr><td>"*" - multiplication</td></tr><tr><td>"/" - integer division</td></tr><tr><td>"%" - residue of division</td></tr><tr><td>"+" - binary plus</td></tr><tr><td>"-" - binary minus</td></tr><tr><td>"&gt;&gt;" - arithmetic right shift</td></tr><tr><td>"&lt;&lt;" - arithmetic left shift</td></tr><tr><td>"&lt;" - less</td></tr><tr><td>"&gt;" - greater</td></tr><tr><td>"&lt;=" - less or equal</td></tr><tr><td>"&gt;=" - greater or equal</td></tr><tr><td>"a=b" - equal</td></tr><tr><td>"a!=b" - not equal</td></tr><tr><td>"&amp;" - binary and</td></tr><tr><td>"^" - binary xor</td></tr><tr><td>"|" - binary or</td></tr><tr><td>"&amp;&amp;" - logical and</td></tr><tr><td>"a||b" - logical or</td></tr><tr><td>"?", ":" - conditional operator</td></tr></table></li><li class="listitem" style="list-style-type: circle">variables:
    <div class="variablelist"><dl><dt><span class="term">in_init</span></dt><dd>evaluated to not 0, if target module currently execute its init function, otherwise evaluated to 0</dd><dt><span class="term">rnd100</span></dt><dd>evaluated to random integer number from [0...99]</dd><dt><span class="term">rnd10000</span></dt><dd>evaluated to random integer number from [0...9999]</dd><dt><span class="term">times</span></dt><dd>evaluated to the ordinal number of this function call since indicator has set or its expression has changed</dd></dl></div></li></ul></div><p>
    </p><p>
Examples:
    </p><pre class="programlisting">
echo common &gt;/sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
will set <span class="quote">“<span class="quote">common</span>”</span> indicator for function <code class="function">__kmalloc</code>, scenario will be "never simulate fail".
So,
    </p><pre class="programlisting">
cat /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will print <code class="computeroutput">0</code>.
    </p><pre class="programlisting">
echo 1 &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will set scenario to "always simulate fail".
    </p><pre class="programlisting">
echo '!in_init' &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will set scenario to "after module is initialized, always simulate fail".
    </p><pre class="programlisting">
echo '!in_init &amp;&amp; (rnd100 &lt; 20)'&gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will set scenario to "after module is initialized, simulate fail for 20% of all function calls".
    </p><pre class="programlisting">
echo '(times % 3) = 0'&gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will set scenario to "simulate fail for every third function call"(succeed, succeed, fail, succeed, succeed, fail, succeed...).
    </p><p>
File <code class="filename">pid</code> reflect set of processes, which is affected by the fault simulation of this function. Initially (after indicator was set for the function) pid is <code class="literal">0</code>, and whenever replaced function is called, it verify (according to the <code class="varname">expression</code>), where it should emulate fail or not. In case when someone write not-<code class="literal">0</code> value to the <code class="filename">pid</code> file, only the process with given pid and its direct and indicrect child processes will be affected to the fault simulation. Other processes will always get result of the real call of the target function. (And this calls will not increment <code class="varname">times</code> variable).
    </p><p>
Example:
    </p><pre class="programlisting">
echo common &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
echo 1 &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
echo $$ &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/pid
    </pre><p>
will set scenario to "simulate fail for every function call, which is done by processes, directly or indirectly derived from the current shell".
    </p><p>
There is a possibility to set indicator for the function and the expression for this indicator in one step. For doing this, one may write to file <code class="filename">current_indicator</code> string <code class="code">common &lt;expression&gt;</code>. E.g., this command
    </p><pre class="programlisting">
echo 'common !init &amp;&amp; (times % 2 = 0)' &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
do effectly the same as two commands
</p><pre class="programlisting">
echo common &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
echo 'common !init &amp;&amp; (times % 2 = 0)' &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
    </p><p>
<code class="varname">pid</code> parameter may be assigned only after setting indicator.
    </p><p>
Other indicators, provided with KEDR, extend facility of <span class="quote">“<span class="quote">common</span>”</span> indicator by adding additional variables, which may be used in expression.
    </p><p>
Indicator <span class="quote">“<span class="quote">kmalloc</span>”</span> allow usage of <code class="varname">size</code> and <code class="varname">flags</code> variables, which is parameters of __kmalloc function. Also it accept some gfp_t named constant definitions like <code class="varname">GFP_KERNEL</code> and <code class="varname">GFP_ATOMIC</code>. E.g.
    </p><pre class="programlisting">
echo 'kmalloc (flags = GFP_ATOMIC) &amp;&amp; (size &gt; 100)' &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
will set scenarion for <code class="function">__kmalloc</code> function "simulate fault for all memory requests with flags equal to GFP_ATOMIC and size more then 100".
But this extension of <span class="quote">“<span class="quote">common</span>”</span> indicator is made by the cost of generality - this indicator may be set only for <code class="function">__kmalloc</code> function, and those functions, which provide <code class="varname">size</code> and <code class="varname">flags</code> parameters.
    </p><p>
Similar, indicator <span class="quote">“<span class="quote">capable</span>”</span> allow usage of <code class="varname">cap</code> variable, which is a parameter of the <code class="function">capable</code> function. Also it accept all named constants, which may be used for this parameter. E.g.
    </p><pre class="programlisting">
echo 'capable cap = CAP_SYS_ADMIN' &gt; /sys/kernel/debug/kedr_fault_simulation/points/capable/current_indicator
    </pre><p>
will set scenarion for <code class="function">capable</code> function "simulate fault for all requests for administrative capabilities".
    </p><p>
Here is a list of KEDR modules, which implements fault simulation indicators:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">kedr_fsim_indicator_common.ko</code></span></dt><dd>implements <span class="quote">“<span class="quote">common</span>”</span> indicator</dd><dt><span class="term"><code class="filename">kedr_fsim_indicator_kmalloc.ko</code></span></dt><dd>implements <span class="quote">“<span class="quote">kmalloc</span>”</span> indicator</dd><dt><span class="term"><code class="filename">kedr_fsim_indicator_capable.ko</code></span></dt><dd>implements <span class="quote">“<span class="quote">capable</span>”</span> indicator</dd></dl></div><p>
If you want to extend <span class="quote">“<span class="quote">common</span>”</span> indicator for some other function type, see <a class="xref" href="extend.html#custom_fsim_scenarios" title="5.4. Writing Custom Scenarios for Fault Simulation">Section 5.4, “Writing Custom Scenarios for Fault Simulation”</a>.
    </p><p>
And list of KEDR fault simulation payloads:
</p><div class="variablelist"><dl><dt><span class="term"><code class="filename">kedr_fsim_capable.ko</code></span></dt><dd>implements fault simulation for function <code class="function">capable</code></dd><dt><span class="term"><code class="filename">kedr_fsim_user_space_access.ko</code></span></dt><dd>implements fault simulation for functions
        <span class="simplelist">
        <code class="function">copy_to_user</code>/<code class="function">_copy_to_user</code>
        , 
        <code class="function">copy_from_user</code>/<code class="function">_copy_from_user</code>
        </span></dd><dt><span class="term"><code class="filename">kedr_fsim_cmm.ko</code></span></dt><dd>implements fault simulation for functions
        <span class="simplelist"><code class="function">__kmalloc</code>, <code class="function">krealloc</code>, <code class="function">kmem_cache_alloc</code>, [<code class="function">kmem_cache_alloc_notrace</code>]</span></dd></dl></div><p>
Though KEDR module <code class="filename">kedr_fsim_cmm.ko</code> implements fault simulation facility for 4 functions, it export only one directory <code class="filename">__kmalloc</code> to manage fault simulation scenarios.
All 4 functions share scenario, which is set for <code class="function">__kmalloc</code> function.
    </p><p>
    If you want to implement fault simulation payload for other functions, see <a class="xref" href="extend.html#custom_fsim_payloads" title="5.3. Writing Custom Payloads for Fault Simulation">Section 5.3, “Writing Custom Payloads for Fault Simulation”</a>.
    </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="getting_started.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="extend.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">3. Getting Started </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5. Customizing and Extending KEDR</td></tr></table></div></body></html>
