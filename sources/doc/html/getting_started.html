<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>3. Getting Started</title><link rel="stylesheet" href="kedr-doc.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.1 Reference Manual"><link rel="prev" href="overview.html" title="2. Overview"><link rel="next" href="using_kedr.html" title="4. Using KEDR"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Getting Started</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="overview.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="using_kedr.html">Next</a></td></tr></table><hr></div><div class="section" title="3. Getting Started"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="getting_started"></a>3. Getting Started</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="getting_started.html#getting_started.install">3.1. Installation</a></span></dt><dt><span class="section"><a href="getting_started.html#getting_started.example">3.2. A Simple Example</a></span></dt><dt><span class="section"><a href="getting_started.html#getting_started.call_monitoring">3.3. Call monitoring</a></span></dt><dt><span class="section"><a href="getting_started.html#getting_started.fault_simulation">3.4. Fault simulation</a></span></dt></dl></div><p>
This section shows how to install KEDR framework and how to use it to analyse a simple kernel module.
</p><div class="section" title="3.1. Installation"><div class="titlepage"><div><div><h3 class="title"><a name="getting_started.install"></a>3.1. Installation</h3></div></div></div><p>
It is recommended to build KEDR from source. This allows to avoid a lot of issues concerning the differences between many versions and variants of Linux kernel. For the present, there is no official binary distribution of KEDR. 
</p><p>
The source code of the framework can be downloaded from the <a class="ulink" href="http://developer.berlios.de/projects/kedr/" target="_top">project site</a> at BerliOS Developer.
</p><div class="itemizedlist"><p>
To be able to build KEDR, you need the following:
</p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
Your Linux system should have kernel version 2.6.31 or newer (<span class="command"><strong>uname -r</strong></span> command should tell you what kernel version you are currently using)
</p></li><li class="listitem"><p>
CMake build system (<a class="ulink" href="http://cmake.org/" target="_top">http://cmake.org/</a>) version 2.6 or newer (version 2.8 or newer is preferable), 
</p></li><li class="listitem"><p>
GNU C and C++ compilers - version 4.0 or newer is recommended
</p></li><li class="listitem"><p>
GNU Make
</p></li><li class="listitem"><p>
Other tools and packages necessary to build kernel modules: on some systems it can be <span class="quote">“<span class="quote">kernel-*-devel</span>”</span>, <span class="quote">“<span class="quote">kernel-*-source</span>”</span>, <span class="quote">“<span class="quote">kernel-*-syms</span>”</span> or some other packages, on some systems you may need to install <span class="quote">“<span class="quote">DKMS</span>”</span> package as well, etc.
</p></li></ul></div><p>
After all the prerequisites have been met, unpack the archive with the sources (<code class="filename">kedr-&lt;version&gt;.tar.bz2</code>) and create another directory, say, <code class="filename">kedr-build</code> where KEDR will be built.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
It is highly recommended to use an out-of-source build, i.e. not to build KEDR from the directory containing its sources. With an out-of-source build, you leave the source tree of KEDR unchanged, which can be convenient. You can also configure and build the framework from different build directories with different options if you want to. An in-source build would make this impossible.
</p></div><p>
Change current directory to <code class="filename">kedr-build</code> and configure the package using the following command:
</p><pre class="programlisting">
cmake -DCMAKE_INSTALL_PREFIX=&lt;install_directory&gt; &lt;path-to-kedr-sources&gt;
</pre><p>
The package will be configured to be installed to <em class="replaceable"><code>&lt;install_directory&gt;</code></em>. For example:
</p><pre class="programlisting">
cmake -DCMAKE_INSTALL_PREFIX=/opt/kedr/ ../kedr-0.1/
</pre><p>
If the configuration stage completes successfully, you can type <span class="command"><strong>make</strong></span> to build the package and <span class="command"><strong>make install</strong></span> - to install it to the configured location (<code class="filename">/opt/kedr/</code> in the example above). You may need to execute <span class="command"><strong>make install</strong></span> as a root user.
</p><p>
If you would like to install KEDR to the default location (usually, <code class="filename">/usr/local/</code>), you can omit that <code class="code">CMAKE_INSTALL_PREFIX</code> stuff and configure the package as follows:
</p><pre class="programlisting">
cmake ../kedr-0.1/
</pre><p>
To remove the files installed with <span class="command"><strong>make install</strong></span>, you can use <span class="command"><strong>make uninstall</strong></span> command.
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Currently, <span class="command"><strong>make uninstall</strong></span> does not remove directories, only files. That is why it can be convenient to install KEDR to a custom location like <code class="filename">/opt/kedr/</code> rather than to <code class="filename">/usr/local/</code> or the like. In the former case it is easier to cleanup after the package: <span class="command"><strong>make uninstall</strong></span> followed by <span class="command"><strong>rm -rf /opt/kedr</strong></span> will do the job.
</p></div><p>
KEDR package also contains a set of tests for KEDR framework. You may want to run these tests after KEDR is built but before it is installed to see if the tools provided by the framework correctly operate on your system. To do so, just execute <span class="command"><strong>make check</strong></span> (as root user).
</p></div><div class="section" title="3.2. A Simple Example"><div class="titlepage"><div><div><h3 class="title"><a name="getting_started.example"></a>3.2. A Simple Example</h3></div></div></div><p>
Show how to run KEDR for a simple kernel module.
</p><p>
As a simple kernel module you can take <span class="quote">“<span class="quote">sample_target</span>”</span> module from installed examples. Copy contents of the directory <code class="filename">sample_target</code> into your own place, and run 'make' in that place. You should get file <code class="filename">kedr_sample_target.ko</code> there. It is a kernel module, which we will use to demonstrate abilities of the KEDR.
</p><p>
Run script
    </p><pre class="programlisting">
/usr/local/bin/kedr start kedr_sample_target
    </pre><p>
It will starts KEDR modules and prepare them to interfere with kernel module with name <span class="quote">“<span class="quote">kedr_sample_target</span>”</span>. Note, that <span class="quote">“<span class="quote">kedr_sample_target</span>”</span> itself is not loading at this stage. But whenever this module will be loaded, KEDR will automatically connect with it.
</p><p>
Now, run our module. It is better to do this by executing
    </p><pre class="programlisting">
kedr_sample_target load
    </pre><p>
from the directory with the compiled <span class="quote">“<span class="quote">kedr_sample_target</span>”</span> module. The thing is that <span class="quote">“<span class="quote">kedr_sample_target</span>”</span> module really create character device, and aside from the loading module itself, the script creates <code class="filename">/dev/cfake</code> node, which represents this character device in the your filesystem.
</p><p>
Now KEDR is worked and we may do something usefull. What really may be done depends from additional steps in the process of loading KEDR and target module, and will be described in the followed sections.
</p><p>
After work with KEDR, it may be stopped. But firstly, you should unload target module, otherwise KEDR cannot be stopped. 
</p><p>Call
    </p><pre class="programlisting">
kedr_sample_target unload
    </pre><p>
will unload our example module.
</p><p>Finally,
    </p><pre class="programlisting">
/usr/local/bin/kedr stop
    </pre><p>
will stop KEDR service.
</p></div><div class="section" title="3.3. Call monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="getting_started.call_monitoring"></a>3.3. Call monitoring</h3></div></div></div><p>
Show now how to use KEDR for call monitoring, that is gathering information
about functions calls from target module's code. Its ability of KEDR will be demostrated on <span class="quote">“<span class="quote">kedr_sample_target</span>”</span> as target module.
</p><p>
Really, call of
    </p><pre class="programlisting">
/usr/local/bin/kedr start kedr_sample_target
    </pre><p>
without additional arguments, aside from loading KEDR base facilities, also loads modules to perform call monitoring.
</p><p>
Information about kernel function calls is output into debugfs filesystem, so to see this information, you need to have this filesystem mounted to some node of you filesystem.
Usually, it mounted by default to <code class="filename">/sys/kernel/debug</code>. If it is not you case, you can mount it, executing
    </p><pre class="programlisting">
mount debugfs -t debugfs /sys/kernel/debug
    </pre><p>
</p><p>
You can force to output information about kernel function calls into you own file, instead system-special temporary one. For doing this, execute
    </p><pre class="programlisting">
/usr/local/bin/kedr_capture_trace start <em class="replaceable"><code>file-to-store-trace</code></em>
    </pre><p>
From this moment, all tracing information will be stored into file <em class="replaceable"><code>file-to-store-trace</code></em>.
</p><p>
Now, everything is ready to load kernel module which we will watch for. Do it:
    </p><pre class="programlisting">
kedr_sample_target load
    </pre><p>
</p><p>
Do something with character device, creating by the module. E.g., write zeroes into it:
    </p><pre class="programlisting">
dd if=/dev/zero of=/dev/cfake bs=1 count=10
    </pre><p>
</p><p>
Now, open file with trace (which path you pass to <span class="command"><strong>kedr_capture_trace</strong></span> script). Here you may found lines like
    </p><pre class="programlisting">
insmod-709 [000] 99689.618433: target_session_begins: target_module: "kedr_sample_target"
insmod-709 [000] 99689.627529: called___kmalloc: arguments(184, d0), result: d80c3600
dd-743 [000] 99861.116151: called___kmalloc: arguments(4000, d0), result: decaa000
dd-743 [000] 99861.116614: called_copy_from_user: arguments(decaa000, 09b00000, 1), result: 0
...
    </pre><p>
First line says, that KEDR is determine, that target module is loaded.
Second line shows information about the first detected call of kernel function - __kmalloc, and show parameters, which has passed to it(size=184, flags=0xd0) and value, which this call has returned (adresss 0xd80c3600). According to the process name - 'insmod' - we may assume, that this call has done at initialization stage of the module.
Third line also shows detected call of __kmalloc, but at the writing stage - process name is 'dd'.
Forth line shows detected call of another kernel function - copy_from_user.
And so on.
</p><p>
Unload driver module, using command
    </p><pre class="programlisting">
kedr_sample_target unload
    </pre><p>
Line like 
    </p><pre class="programlisting">
rmmod-17250 [000] 102326.651693: target_session_ends: target_module: "kedr_sample_target"
    </pre><p>
should appear in the trace file. There will be nothing to new in this file, until target will be loaded again. So, stop redirection of the trace into our file:
    </p><pre class="programlisting">
/usr/local/bin/kedr_capture_trace stop
    </pre><p>
</p><p>
Last step - stopping KEDR modules.
    </p><pre class="programlisting">
/usr/local/bin/kedr stop
    </pre><p>
</p></div><div class="section" title="3.4. Fault simulation"><div class="titlepage"><div><div><h3 class="title"><a name="getting_started.fault_simulation"></a>3.4. Fault simulation</h3></div></div></div><p>
Show now how to use KEDR for fault simulation, that is emulation of the system with low resources or which operates strange(but correct!). This ability of KEDR will also be demostrated on <span class="quote">“<span class="quote">kedr_sample_target</span>”</span> as target module.
</p><p>
We do not need call monitoring facilities there, so we replace default configuration of the KEDR. Create file <code class="filename">kedr.conf</code> in some place, and write next lines to it:
</p><pre class="programlisting">
module /lib/modules/'uname -r'/misc/kedr_fault_simulation.ko
module /lib/modules/'uname -r'/misc/kedr_fsim_cmm.ko
</pre><p>
</p><p>
Then, call
    </p><pre class="programlisting">
/usr/local/bin/kedr start kedr_sample_target <em class="replaceable"><code>path-to-conf-file</code></em>
    </pre><p>
where <em class="replaceable"><code>path-to-conf-file</code></em> should be set to the full name of file you created. Now KEDR is prepared to simulate system, which may fail to allocate memory(e.g., via __kmalloc). Note, that this simulation will be performed only with respect to the target module, others parts of the kernel will not be affected.
</p><p>
Now we choose scenario, according to which we will fail __kmalloc call. For doing this, load module, which implements some scenario:
    </p><pre class="programlisting">
insmod /lib/modules/'uname -r'/misc/kedr_fsim_indicator_kmalloc.ko
    </pre><p>
and inform KEDR, that we want to use this scenario for __kmalloc:
    </p><pre class="programlisting">
echo "kmalloc" &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/current_indicator
    </pre><p>
In the last listing we assume, that debugfs is mounted into <code class="filename">/sys/kernel/debug</code>.
</p><p>
Really, "kmalloc" scenario is a set of scenarios, so choose one:
    </p><pre class="programlisting">
echo "1" &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
This scenario is "fail always" (for the question fail or not, it always answer "1", that is "yes").
</p><p>
As we may see from the section about call monitoring, kedr_sample_target module calls __kmalloc in the its initialization function, so we may suggest, that loading of entire module should fail, because it couldn't allocate memory for its own use. Verify it:
    </p><pre class="programlisting">
kedr_sample_target load
    </pre><p>

    </p><pre class="programlisting">
insmod: error inserting 'kedr_sample_target.ko': -1 Cannot allocate memory
    </pre><p>
As it was expected!
</p><p>
Change scenario to:
    </p><pre class="programlisting">
echo "size &gt; 2000" &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
which mean, that only requests of size more than 2000 bytes will fail.
Now load the target module 
    </p><pre class="programlisting">
kedr_sample_target load
    </pre><p>
will succeed, but attempt to write to it
    </p><pre class="programlisting">
dd if=/dev/zero of=/dev/cfake bs=1 count=10
    </pre><p>
will fail:
    </p><pre class="programlisting">
dd: opening '/dev/cfake': Cannot allocate memory
    </pre><p>
This is because module couldn't allocate 4000 bytes.
</p><p>
Setting scenario to "0"
    </p><pre class="programlisting">
echo "0" &gt; /sys/kernel/debug/kedr_fault_simulation/points/__kmalloc/expression
    </pre><p>
will cancel fault simulation of __kmalloc(test it by yourself).
</p><p>
Now unload scenario module
    </p><pre class="programlisting">
rmmod kedr_fsim_indicator_kmalloc.ko
    </pre><p>
Scenario for the __kmalloc will be cleared automatically(with cleared scenario function will always succeed).
</p><p>
Unload target module
    </p><pre class="programlisting">
kedr_sample_target unload
    </pre><p>
and stop KEDR
    </p><pre class="programlisting">
/usr/local/bin/kedr stop
    </pre><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="overview.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="using_kedr.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">2. Overview </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4. Using KEDR</td></tr></table></div></body></html>
