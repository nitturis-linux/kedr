<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>5. Customizing and Extending KEDR</title><link rel="stylesheet" type="text/css" href="kedr-doc.css"><meta name="generator" content="DocBook XSL Stylesheets V1.77.1"><link rel="home" href="index.html" title="KEDR 0.4 Reference Manual"><link rel="up" href="index.html" title="KEDR 0.4 Reference Manual"><link rel="prev" href="kedr_manual_using_kedr.html" title="4. Using KEDR"><link rel="next" href="kedr_manual_reference.html" title="6. KEDR Reference"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Customizing and Extending KEDR</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="kedr_manual_using_kedr.html">Prev</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="kedr_manual_reference.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kedr_manual_extend"></a>5. Customizing and Extending KEDR</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="kedr_manual_extend.html#using_gen">5.1. Using Code Generator to Create Custom Modules</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_callm_payloads">5.2. Writing Custom Payloads for Call Monitoring</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#happens_before_parameter">5.3. <span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_fsim_payloads">5.4. Writing Custom Payloads for Fault Simulation</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_fsim_scenarios">5.5. Writing Custom Scenarios for Fault Simulation</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis">5.6. Implementing Custom Types of Analysis</a></span></dt><dd><dl><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.basics">5.6.1. Choosing the Counters and the Functions to Process</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.define_trampolines">5.6.2. Describing the Targets</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.generate_trampolines">5.6.3. Generating the Trampolines</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.payload">5.6.4. Creating the Payload Module</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.build">5.6.5. Building the Payload Module</a></span></dt><dt><span class="section"><a href="kedr_manual_extend.html#custom_analysis.use">5.6.6. Using the Payload Module</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using_gen"></a>5.1. Using Code Generator to Create Custom Modules</h3></div></div></div><p>
To automate creation of multiple modules with simular functionality, KEDR actively uses template-based generation of files. This approach facilitates code reuse as it makes it possible to separate the common parts in the implementation of the modules and the parts specific to each module. This also allows the developer of the new modules to concentrate mostly on the <span class="quote">“<span class="quote">logic</span>”</span> of what (s)he wants to implement there rather than on writing and debugging <span class="quote">“<span class="quote">boilerplate</span>”</span> code.
    </p><p>
So, to develop a new module this way, it is only necessary to prepare a short definition of what this module is supposed to do in addition to the basic functionality. Creation of the source file(s) for this module will be performed automatically by the <span class="quote">“<span class="quote">code generator</span>”</span>.
    </p><p>
Apart from usage within KEDR, this mechanism can also be used for creating custom specialized modules for different purposes: payload modules for call monitoring or fault simulation, fault simulation indicators, etc. This approach to development of custom modules has many advantages:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>fast development</em></span> - the implementation of a new payload payload module for call monitoring requires, for example, about 10 lines in the <span class="quote">“<span class="quote">definition</span>”</span> file for the <span class="quote">“<span class="quote">header</span>”</span> part (it contains the name of the module, the author and the license, etc.), and about 10 lines per target function (description of the arguments and the return value, etc.) the calls to which are to be traced.</p></li><li class="listitem"><p><span class="emphasis"><em>clear and readable definition files</em></span> - all features of your module are described in one place, the so called <em class="firstterm">definition file</em> rather than scattered over different files or over one long file. Every line in a <span class="quote">“<span class="quote">definition</span>”</span> file is self-explanatory.</p></li><li class="listitem"><p><span class="emphasis"><em>high level of abstraction</em></span> - when writing a <span class="quote">“<span class="quote">definition</span>”</span> file, you do not need to care about what file(s) will be generated from it and how exactly any particular feature will be implemented.</p></li><li class="listitem"><p><span class="emphasis"><em>less error-prone code</em></span> - if the <span class="quote">“<span class="quote">definition</span>”</span> file is written correctly, correct code of the module will be generated from it. Most of the lines in that file simply define the names of some entities (variables, types, etc.) that will appear in the generated code. The rare inter-line dependencies as well as code chunk definitions can be easily debugged in the clear and short <span class="quote">“<span class="quote">definition</span>”</span> file.</p></li><li class="listitem"><p><span class="emphasis"><em>easier maintenance</em></span> - if the templates are updated to implement some new basic functionality, to fix errors or for any other reason, it is enough to run the <span class="quote">“<span class="quote">generator</span>”</span> again to update the code of the modules you have created. The enhancements and fixes will thus automatically propagate to all the modules generated using those templates.</p></li></ul></div><p>
Of course, using the <span class="quote">“<span class="quote">generator</span>”</span> is not an universal way to extend functionality of the standard KEDR modules. If some functionality is not provided by the templates, it will not be available for the generated modules. You will probably need to implement it manually - or prepare the templates of your own. Still, in many cases it can be very convenient to use the <span class="quote">“<span class="quote">generator</span>”</span> with the default templates to create modules for KEDR.
    </p><p>
Let us now consider the common format of <span class="quote">“<span class="quote">definition</span>”</span> files. 
    </p><p>
The <span class="quote">“<span class="quote">generator</span>”</span> is based on MiST Engine library from <a class="ulink" href="http://template2code.sourceforge.net" target="_top"><em class="citetitle">Template2Code project</em></a> and is very similar to <span class="quote">“<span class="quote">mist_gen</span>”</span> example from that project. As a result, the format of definition files accepted by the generator is the same as the format of <em class="firstterm">configuration files</em> accepted by <span class="quote">“<span class="quote">mist_gen</span>”</span>. The format is fully described <a class="ulink" href="http://template2code.sourceforge.net/mist-doc/param.html" target="_top"><em class="citetitle">here</em></a>. The only difference is that a definition file (as well as a configuration file for <span class="quote">“<span class="quote">mist_gen</span>”</span>) may contain <code class="code">[group]</code> keywords that divide the file into blocks.
    </p><p>
A definition file is treated as an array of records. The lines that contain only whitespace characters (spaces and tabs) are ignored, so are the lines where the first non-whitespace character is <code class="code">#</code>:
</p><pre class="programlisting">
# The next line is empty, so it will be ignored

    # This line will be ignored too.
</pre><p>
    </p><p>
Lines like 
</p><pre class="programlisting">
&lt;parameter-name&gt; = &lt;value&gt;
</pre><p>
define a parameter with name <code class="code">&lt;parameter-name&gt;</code> and assign the string <code class="code">&lt;value&gt;</code> to it. <code class="code">&lt;parameter-name&gt;</code> may only contain latin letters, digits, dots, hyphens and underscores. The names are case-sensitive. Whitespace characters surrounding <code class="code">&lt;parameter-name&gt;</code> and <code class="code">&lt;value&gt;</code> are ignored.
    </p><p>
</p><pre class="programlisting">
# Define parameter with name 'a' and value '135'
a = 135
# Define parameter with name 'b' and value 'some string'
b = some string
# Define parameter with name 'expression' and value '2 + 3 = 5'
expression = 2 + 3 = 5
</pre><p>
    </p><p>
There is a way to define parameter with a long value:
</p><pre class="programlisting">
# Define parameter with name 'long-string' and value 'string1 string2 string3'
# Note, that leading whitespace characters are ignored.
long-string = string1 \
    string2 \
    string3
</pre><p>
    </p><p>
In addition, parameters with multiline values can be defined too:
</p><pre class="programlisting">
multi-line-parameter =&gt;&gt;
    line1
    line2
    ...
    lineN
&lt;&lt;
</pre><p>
    </p><p>
The value of <code class="code">multi-line-parameter</code> is precisely as follows:
</p><pre class="programlisting">
    line1
    line2
    ...
    lineN
</pre><p>
    </p><p>
Note that a newline character should immediately follow <code class="code">&gt;&gt;</code> delimiter and apart from the delimiter <code class="code">&lt;&lt;</code>, there should be no characters on the line (except whitespace characters).

</p><pre class="programlisting">
# Correct definition of a multiline parameter containing &gt;&gt;
multi-line-parameter =&gt;&gt;
    &lt;&lt;a&gt;&gt;
    &lt;&lt;b&gt;&gt;
    &lt;&lt;
</pre><p>
    </p><p>
The generator only extracts the set of parameters with and  their values from the definition file. The order in which these parameters are listed is not important. For example, the following definition files
</p><pre class="programlisting">
a = 5
b = 10
</pre><p>
and
</p><pre class="programlisting">
b = 10
a = 5
</pre><p>
have actually the same meaning.
    </p><p>
However when several definitions assign values to the same parameter, the parameter becomes multi-valued and the order of the assignments becomes important. Example:
    </p><p>
</p><pre class="programlisting">
a = 5
a = 10
</pre><p>
This means <code class="code">a={'5','10'}</code>, but
</p><pre class="programlisting">
a = 10
a = 5
</pre><p>
means <code class="code">a={'10','5'}</code>. 
    </p><p>
Depending on the meaning of the parameter, the difference in the order of its values may be important (e.g. the order of the function parameters is critical), or it may be not (e.g. the order of the target functions descriptions in the file).
    </p><p>
As a rule, the order of values of two multi-valued parameters is only significant if these parameters describe one-value attributes of same object:
    </p><p>
</p><pre class="programlisting">
obj.name = object1
obj.description = This is object1
obj.name = object2
obj.description = This is object2
</pre><p>
This defines <code class="code">obj.name</code> as <span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">object2</span>”</span></span>, <code class="code">obj.description</code> as <span class="simplelist"><span class="quote">“<span class="quote">This is object1</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span>.
This may mean there are two object instances with attributes <span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span> and <span class="simplelist"><span class="quote">“<span class="quote">object2</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span>
    </p><p>
Let us consider the following definitions where the values of <code class="code">obj.description</code> are given in a reverse order.
</p><pre class="programlisting">
obj.name = object1
obj.description = This is object2
obj.name = object2
obj.description = This is object1
</pre><p>
This defines <code class="code">obj.name</code> as <span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">object2</span>”</span></span>, <code class="code">obj.description</code> as <span class="simplelist"><span class="quote">“<span class="quote">This is object2</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span>. This may mean two object instances with attributes
<span class="simplelist"><span class="quote">“<span class="quote">object1</span>”</span>, <span class="quote">“<span class="quote">This is object2</span>”</span></span> and <span class="simplelist"><span class="quote">“<span class="quote">object2</span>”</span>, <span class="quote">“<span class="quote">This is object1</span>”</span></span>, which is probably not what you want. 
    </p><p>
A simple way to avoid such confusion with ordering is to define all attributes for one instance first and only then define attributes for another one.
    </p><p>
If some object has a non-constant set of attributes (e.g., one of its attributes may have multiple values or one of its attribute is optional), then you cannot define several instances of this object in one definition file. This is because the generator cannot determine which instance each particular value of an attribute belongs to. To address this problem, <code class="code">[group]</code> keyword was introduced in the format of definition files. This keyword denotes a new group of definitions that starts just after this keyword and ends before the next occurence of same keyword or at the end of the file.
    </p><p>
</p><pre class="programlisting">
module_name = Arrays
[group]
array.name = array1
array.values = val1
[group]
array.name = array2
array.values = val2
array.values = val3
[group]
array.name = array3
</pre><p>
There are 3 groups in this file. The first one defines <code class="code">array.name='array1'</code> and <code class="code">array.values='val1'</code>, the second - <code class="code">array.name='array2'</code> and <code class="code">array.values={'val2', 'val3'}</code>, third - <code class="code">array.name='array3'</code>. Each group can be interpreted as a definition of an array object. The object named <code class="code">array1</code> contains one element <code class="code">val1</code>, the object named <code class="code">array2</code> contains two elements <code class="code">val2</code> and <code class="code">val3</code>, the object named <code class="code">array3</code> contains no elements.
    </p><p>
<code class="code">[group]</code> keyword does not prevent gathering of all parameter assignments. That is, the <span class="quote">“<span class="quote">global meaning</span>”</span> of this file is <code class="code">module_name='Arrays'</code>, <code class="code">array.name={'array1', 'array2', 'array3'}</code> and <code class="code">array.values={'val1', 'val2', val3'}</code>. This information will be processed by the generator using one set of templates. But besides that, the information from each group will also be processed using another set of templates. This processing will result in a new multi-valued parameter which values are the results processing of the groups. This parameter is referred to as <span class="quote">“<span class="quote">block</span>”</span>, and so is the set of templates used to  generate it. This parameter can be used at the top level of processing, the set of templates for which is referred to as <span class="quote">“<span class="quote">document</span>”</span>.
    </p><p>
As far as payload modules are concerned, <span class="quote">“<span class="quote">document</span>”</span> templates define the overall layout of the generated source and header files while <span class="quote">“<span class="quote">block</span>”</span> templates define the parts of the code related to a target function. That is, a <code class="code">[group]</code> block corresponds to a target function in this case.
    </p><p>
This section has given a brief overview of template-based code generation mechanism used in KEDR. This should be enough though if you would like to write you own <span class="quote">“<span class="quote">definition</span>”</span> files for custom modules with the templates provided by KEDR. See <a class="ulink" href="http://template2code.sourceforge.net/mist-doc/index.html" target="_top">MiST Engine Reference Manual</a> and <a class="ulink" href="http://template2code.sourceforge.net" target="_top"><span class="quote">“<span class="quote">mist_gen</span>”</span> example</a> if you want to learn more about this way of template-based code generation.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom_callm_payloads"></a>5.2. Writing Custom Payloads for Call Monitoring</h3></div></div></div><p>
This section describes how to write a new payload module for call monitoring using a tool provided by KEDR to generate source files from the templates. Common abilities of this tool are described in detail in <a class="xref" href="kedr_manual_extend.html#using_gen">Section 5.1, “Using Code Generator to Create Custom Modules”</a>.
    </p><p>
Typical purposes of a custom payload module of this kind could be as follows: 
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
support call monitoring for the functions for which it is not supported by KEDR <span class="quote">“<span class="quote">out-of-the-box</span>”</span>;
</p></li><li class="listitem"><p>
change the set of parameters output to the trace, in case you need something other than the arguments and the return value of the target function to be output.
</p></li></ul></div><p>
The whole infrastructure necessary for building the payload module from the <span class="quote">“<span class="quote">definition file</span>”</span> is located in <code class="filename">custom_payload_callm</code> subdirectory in the directory where the examples provided with KEDR are installed (<code class="filename">/usr/local/share/kedr/examples/</code> by default). Here are its contents:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file to create the payload module</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd></dl></div><p>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite <code class="filename">payload.data</code> to reflect definitions of your payload module.
    </p><p>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd></dl></div><p>
In addition, the following parameters may be defined at the global level:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">header</span></dt><dd>the code (may be multiline) to be inserted before the definition of target functions. This code usually contains '#include' directives for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code> file:
</p><pre class="programlisting">
# This module processes the calls to module_put function.

module.name = payload_callm_module_put
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/module.h&gt;
&lt;&lt;
</pre><p>
    </p><p>
For each <a class="link" href="kedr_manual_glossary.html#target_function">target function</a> the information about which is to be output to the trace, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">function.name</span></dt><dd>name of the target function</dd><dt><span class="term">returnType</span></dt><dd>return type of the target function if it is not void, otherwise shouldn't be defined at all</dd><dt><span class="term">arg.type</span></dt><dd>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the target function will be accessible via these names in the code.</dd><dt><span class="term">trace.param.name</span></dt><dd>(multi-valued) variable names, which values will be output to the trace. This variables should be accessible when parameters will be output to the trace.</dd><dt><span class="term">trace.param.type</span></dt><dd>(multi-valued) types of the values, which will be output into the trace. This types will be used for casting the values of the corresponding variables before they will be output (so, these types may differ from the real types of variables).</dd><dt><span class="term">trace.formatString</span></dt><dd>format string which is used for printf-like output of values from target function (see parameters <span class="quote">“<span class="quote">trace.param.name</span>”</span> and <span class="quote">“<span class="quote">trace.param.type</span>”</span>)</dd></dl></div><p>

</p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
Output to the trace is currently supported only for the variables of simple types (i.e. no strings, arrays, structures, etc.). Pointers can be output using <code class="code"><span class="quote">“<span class="quote">%p</span>”</span></code> or a similar format. This is due to the limitations of <span class="command"><strong>kedr_gen</strong></span>. In the future versions, these limitations may be removed or at least relaxed.
</p></div><p>

Additionally, the following parameters can be defined at group level:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">prologue</span></dt><dd>code (may be multiline) which will be executed before the values are output to the trace. Usually, this code declares variables that will be used in the output.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multiline) which will be executed after the values have been output to the trace. If <code class="code">prologue</code> request some resources from the kernel, this is the place where these resources can be released.</dd></dl></div><p>

If the target function does not return void, <code class="varname">ret_val</code> variable refers to the return value of the function. It may be used as the name of variable to output (<span class="symbol">arg.name</span>) and in the <span class="symbol">prologue</span> and <span class="symbol">epilogue</span> sections.
    </p><p>
Example of the group section for module_put() target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = module_put

    # Names and types of the arguments of the target function
    arg.type = struct module *
    arg.name = m
    
    # The parameters to be output to the trace. 
    trace.param.type = void *
    trace.param.name = m

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%p)"

# End of the group of definitions for module_put().
</pre><p>
Example of the group section for __kmalloc() target function (note the usage of <code class="varname">ret_val</code> variable as the value of <code class="code">trace.param.name</code> parameter):
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void *

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void *
    trace.param.name = ret_val

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for __kmalloc().
</pre><p>
Example of the group section for kmem_cache_alloc() target function (note the contents of <span class="symbol">prologue</span> parameter):
</p><pre class="programlisting">
    [group]
    # Name and return type of the target function
    function.name = kmem_cache_alloc
    returnType = void *

    # Names and types of the arguments of the target function
    arg.type = struct kmem_cache *
    arg.name = mc
    
    arg.type = gfp_t
    arg.name = flags
    
    prologue =&gt;&gt;
size_t size = kmem_cache_size(mc);
&lt;&lt;
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = size

    trace.param.type = unsigned int
    trace.param.name = flags

    trace.param.type = void *
    trace.param.name = ret_val

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%zu, %x), result: %p"

# End of the group of definitions for kmem_cache_alloc().
</pre><p>
    </p><p>
As you can see, kmem_cache_alloc() function does not have <code class="code">size</code> argument. If we still want to output the size of the requested memory block to the trace, we need to determine it for for use in output to the trace. This is exactly what is done in the prologue code above.
    </p><p>
If the target function takes variable number of arguments, then following parameters should be defined:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ellipsis</span></dt><dd>If function takes variable number of arguments, this parameter should be non-empty.</dd><dt><span class="term">last_arg</span></dt><dd>If function takes variable number of arguments, this parameter should be set to the name of last named argument.</dd><dt><span class="term">original_code</span></dt><dd>If function takes variable number of arguments, this parameter should be non-empty and contain code, which is equvalent to the function body and uses <code class="varname">args</code> variable of type <span class="type">va_list</span> for iterate over variadic arguments. If function return value, it should be assigned to <code class="varname">ret_val</code> variable.</dd></dl></div><p>
In case of function with variable number of arguments, code defined in <code class="code">prologue</code> and <code class="code">epilog</code> parameters can use variable <code class="varname">args</code> of type <span class="type">va_list</span> for iterate over variadic parameters of the function. Note, that this variable is initialized only once and doesn't depend from the one used in <code class="code">original_code</code> parameter.
    </p><p>
Example of the group section for snprintf target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = snprintf

    # Names and types of the arguments of the target function
    arg.type = char *
    arg.name = buf
    
    arg.type = size_t
    arg.name = size
    
    arg.type = const char *
    arg.name = fmt

    # Indicator of variable number of arguments
    ellipsis = true
    
    # Variable arguments-specific definitions
    last_arg = fmt
    original_code = ret_val = vsnprintf(buf, size, fmt, args);
    
    prologue = size_t len = ret_val &lt; size ? ret_val + 1 : size;
    
    # The parameters to be output to the trace. 
    trace.param.type = size_t
    trace.param.name = len

    # The format string to be used for trace output.
    trace.formatString = "number of bytes written: (%zu)"

# End of the group of definitions for snprintf.
</pre><p>
Note the usage of vsnprintf() function in <code class="code">original_code</code> parameter. This function is equivalent to the target functions but takes <span class="type">va_list</span> argument as reference to variadic arguments.
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="happens_before_parameter"></a>5.3. <span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring</h3></div></div></div><p>
There is a parameter that changes order of <a class="link" href="kedr_manual_glossary.html#target_function">target function</a> call and output of values to the trace:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">trace.happensBefore</span></dt><dd>If this parameter is defined (its actual value does not matter), the trace will be output <span class="emphasis"><em>before</em></span> the target function is called. With this parameter defined, variable <code class="varname">ret_val</code> should not be used.</dd></dl></div><p>
    </p><p>
The main purpose of using <code class="code">trace.happensBefore</code> parameter is collecting correct trace on SMP systems and the like. Suppose, two threads of execution call <code class="function">mutex_lock</code> and <code class="function">mutex_unlock</code> functions for the same mutex. One of the correct sequences of these calls is:
		</p><pre class="programlisting">
[1]    mutex_lock
[1]    mutex_unlock
[2]    mutex_lock
[2]    mutex_unlock
</pre><p>
(<code class="code">[n]</code> means that the operation is performed by the thread <em class="replaceable"><code>n</code></em>).
    </p><p>
So one may expect that same order will be recorded in the trace:
    </p><pre class="programlisting">
1    called_mutex_lock
1    called_mutex_unlock
2    called_mutex_lock
2    called_mutex_unlock
</pre><p>
Normally, target function is called and then its parameters are output to the trace. So the following order of the instructions is possible:
    </p><pre class="programlisting">
[1]    [call trampoline function for mutex_lock()]
[1]    mutex_lock
[1]    output("called_mutex_lock")
[1]    [trampoline function for mutex_lock() returns]
[1]    [call trampoline function for mutex_unlock]
[1]    mutex_unlock
[2]    [call trampoline function for mutex_lock()]
[2]    mutex_lock
[2]    output("called_mutex_lock")
[2]    [trampoline function for mutex_lock() returns]
[1]    output("called_mutex_unlock")
[1]    [trampoline function for mutex_unlock() returns]
[2]    [call trampoline function for mutex_unlock]
[2]    mutex_unlock
[2]    output("called_mutex_unlock")
[2]    [trampoline function for mutex_unlock() returns]
</pre><p>
Even though the order of calls to the target functions is correct, these instructions produce the trace that shows an impossible order of the calls:
    </p><pre class="programlisting">
1    called_mutex_lock
2    called_mutex_lock
1    called_mutex_unlock
2    called_mutex_unlock
</pre><p>
From the kernel's point of view, the calls to <code class="function">mutex_lock</code> and <code class="function">mutex_unlock</code> are not related to the trace output made by KEDR. So the operations that output trace can be performed in any order, no matter in what order the target functions were called.
    </p><p>
To get a correct trace, we need to use <code class="code">trace.happensBefore</code> parameter for the target function <code class="function">mutex_unlock</code>. At the abstract level, this parameter means <span class="quote">“<span class="quote">Whenever <code class="function">mutex_unlock</code> is called before some other function and nobody enforces this order explicitly, the order should be preserved in the trace</span>”</span>.
    </p><p>
Note that although <code class="function">mutex_lock</code> function must also be called before the corresponding <code class="function">mutex_unlock</code>, this order is not affected by <code class="code">trace.happensBefore</code> parameter.
    </p><pre class="programlisting">
...
[1]    mutex_lock
...
[1]    mutex_unlock
...
</pre><p>
The difference is that such order should be enforced <span class="emphasis"><em>explicitly</em></span>, that is, by the user of these functions and thus of the target module. If the target module calls, say, <code class="function">mutex_lock</code> strictly before <code class="function">mutex_unlock</code>, the trampoline function for <code class="function">mutex_lock</code> will return strictly before the one for <code class="function">mutex_unlock</code> starts executing. This, in turn, automatically enforces that the corresponding trace records will go in the right order too.
    </p><p>
Another example of internal happens-before relationship is the one between <code class="function">kfree</code> and <code class="function">__kmalloc</code> functions. This relationship reflects the fact that <code class="function">__kmalloc</code> cannot return an address that was previously returned by another <code class="function">__kmalloc</code> call and was not processed by <code class="function">kfree</code>. Using <code class="code">trace.happensBefore</code> parameter one can make sure the order of the trace records is correct:
    </p><pre class="programlisting"> 
    [group]
    # Name and return type of the target function
    function.name = kfree

    # Names and types of the arguments of the target function
    arg.type = void*
    arg.name = p
    
    # The parameters to be output to the trace.
    trace.param.type = void*
    trace.param.name = p

    # Happens-before relationship with kmalloc
    <span class="emphasis"><em>trace.happensBefore = yes</em></span>

    # The format string to be used for trace output.
    trace.formatString = "arguments: (%p)"

# End of the group of definitions for kfree().
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
For the trace records to reflect the fact that function <code class="function">A</code> has happens-before ordering with function <code class="function">B</code>, one should define <code class="code">trace.happensBefore</code> parameter for the function <code class="function">A</code> and <span class="emphasis"><em>should not define it</em></span> for the function <code class="function">B</code>. <code class="code">trace.happensBefore</code> cannot be used to enforce two different orderings for the calls to a single function such as <code class="function">krealloc</code> (which may be modelled as <code class="function">__kmalloc</code> followed by <code class="function">kfree</code>).
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_payloads"></a>5.4. Writing Custom Payloads for Fault Simulation</h3></div></div></div><p>
This section describes how to write a new payload module for fault simulation using <span class="command"><strong>kedr_gen</strong></span> tool provided by KEDR to generate source files from the templates. Common abilities of <span class="command"><strong>kedr_gen</strong></span> are described in detail in <a class="xref" href="kedr_manual_extend.html#using_gen">Section 5.1, “Using Code Generator to Create Custom Modules”</a>.
    </p><p>
Typical purposes of a custom payload module of this kind could be as follows: 
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
support fault simulation for the functions for which it is not supported by KEDR <span class="quote">“<span class="quote">out-of-the-box</span>”</span>;
</p></li><li class="listitem"><p>
provide a different set of variables to be passed to fault simulation indicator (see below) - this can be necessary if you would like to implement <a class="link" href="kedr_manual_extend.html#custom_fsim_scenarios">custom fault simulation scenarios</a>.
</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the infrastructure provided by KEDR for fault simulation (<a class="link" href="kedr_manual_glossary.html#fault_simulation_point">points</a>, <a class="link" href="kedr_manual_glossary.html#fault_simulation_indicator">indicators</a> and the respective control facilities) could be used for other purposes as well. In general, it allows to alter the behaviour of a call made by the target module if the indicator returns nonzero, or allow the target function to do its work normally if the indicator returns 0. The <span class="quote">“<span class="quote">altered behaviour</span>”</span> is controlled by the user, see the description of <code class="code">fpoint.fault_code</code> parameter below. So, instead of fault simulation, you could implement, say, timeout/sleep injection (i.e., delaying the return from the replacement function which might help with concurrency analysis, etc.) or whatever else you want.
</p></div><p>
The files necessary to build the payload module from the <span class="quote">“<span class="quote">definition file</span>”</span> are located in <code class="filename">custom_payload_fsim</code> subdirectory in the directory where the examples provided with KEDR are installed (<code class="filename">/usr/local/share/kedr/examples/</code> by default). Here are its contents:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">payload.data</code></span></dt><dd>'definition' file to create the payload module</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd></dl></div><p>
To use all this in development of your payload module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite <code class="filename">payload.data</code> to reflect definitions of your payload module.
    </p><p>
At the global level (i.e. before the first group begins), this file should contain definitions for the following parameters:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">module.name</span></dt><dd>string, which will be used as module name inside its source files</dd><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd></dl></div><p>
In addition, the following parameters may be defined at the global level:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">header</span></dt><dd>the code (may be multiline) to be inserted before the definition of replacement functions. This code usually contains '#include' directives for header files which define target functions and types of its parameters.</dd></dl></div><p>
Example of global section of the <code class="filename">payload.data</code> file:
</p><pre class="programlisting">
# This module processes the calls to kstrdup function.

module.name = payload_fsim_kstrdup
module.author = Andrey Tsyvarev
module.license = GPL

header =&gt;&gt;
#include &lt;linux/string.h&gt;
&lt;&lt;
</pre><p>
    </p><p>
For each <a class="link" href="kedr_manual_glossary.html#target_function">target function</a> to be processed, a group should be prepared in the definition file.
Each group should contain definitions for the following parameters:
	</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">function.name</span></dt><dd>name of the target function</dd><dt><span class="term">returnType</span></dt><dd>return type of the target function if it is not void, otherwise shouldn't be defined at all</dd><dt><span class="term">arg.type</span></dt><dd>(multi-valued) types of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all.</dd><dt><span class="term">arg.name</span></dt><dd>(multi-valued) names of the parameters of the target function, starting with the first one. If the function has no parameters, shouldn't be assigned at all. Parameters of the target function will be accessible via these names in the code.</dd><dt><span class="term">fpoint.fault_code</span></dt><dd>code (may be multiline) which should be executed instead the call to the target function to simulate failure of the latter. Usually, this code simply sets <code class="varname">ret_val</code> variable to a value indicating that a failure has occured. For the caller of the target function, it will look like the target function has returned this value.</dd><dt><span class="term">fpoint.param.name</span></dt><dd>(multi-valued) names of the variables which values will be passed to the indicator function and may be used to specify the scenario of fault simulation in it. The order of these variables is important, because they will be passed sequentially to the indicator function. Usually, only the parameters of the target function are passed to the indicator.</dd><dt><span class="term">fpoint.param.type</span></dt><dd>(multi-valued) types of the values that will be passed to the indicator function. These types will be used to properly cast the values before passing to the indicator (so these types may differ from the real types of the variables).</dd><dt><span class="term">fpoint.rename</span></dt><dd>Instead of using the name of the target function as a  name of the fault simulation point, use the name given by this parameter.</dd><dt><span class="term">fpoint.reuse_point</span></dt><dd>Instead of creating a new fault simulation point for this function, use the previously defined point with the name given by this parameter.</dd></dl></div><p>
Additionally, the following parameters can be defined at the group level. They are similar to the ones used in the payload modules for call monitoring.
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">prologue</span></dt><dd>code (may be multiline) which will be inserted at the start of replacement function (before the call to the indicator function which should decide whether need to simulate a failure or not). Usually, this code declares variables that will be passed to the indicator function.</dd><dt><span class="term">epilogue</span></dt><dd>code (may be multiline) which will be inserted at the end of the replacement function (after  executing target function or simulating its fault). If <code class="code">prologue</code> request some resources from the kernel, this is the place to release these resources.</dd></dl></div><p>
If the target function does not return void, <code class="varname">ret_val</code> variable should be set in <span class="symbol">fpoint.fault_code</span> to the value that the target function would return in case of the particular failure.
    </p><p>
Here is an example of the group section for __kmalloc target function. Note the definition of <code class="code">fpoint.fault_code</code> parameter. Its value is <span class="quote">“<span class="quote"><code class="code">ret_val = NULL;</code></span>”</span> because '=' characters after the leftmost one have no special meaning and are treated as the part of the value.
    </p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void *

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = ret_val = NULL;

# End of the group of definitions for __kmalloc().
</pre><p>
Example of the group section for kstrdup() target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = kstrdup
    returnType = char *

    # Names and types of the arguments of the target function
    arg.type = const char *
    arg.name = str
    
    arg.type = gfp_t
    arg.name = flags

    # Calculate length of the string
    prologue = size_t len = strlen(str);

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = len

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = ret_val = NULL;

# End of the group of definitions for kstrdup().
</pre><p>
    </p><p>
Note the usage of <code class="varname">len</code> variable for fault simulation in the example above. This value is calculated in the prologue based on the target function parameter <code class="varname">str</code> and is then used as one of the parameters to be passed to the fault simulation indicator.
    </p><p>
If the target function takes variable number of arguments, then following parameters should be defined in the group:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">ellipsis</span></dt><dd>If function takes variable number of arguments, this parameter should be non-empty.</dd><dt><span class="term">last_arg</span></dt><dd>If function takes variable number of arguments, this parameter should be set to the name of last named argument.</dd><dt><span class="term">original_code</span></dt><dd>If function takes variable number of arguments, this parameter should be non-empty and contain code, which is equvalent to the function body and uses <code class="varname">args</code> variable of type <span class="type">va_list</span> for iterate over variadic arguments. If function return value, it should be assigned to <code class="varname">ret_val</code> variable.</dd></dl></div><p>
In that case code defined in <code class="code">prologue</code>, <code class="code">epilog</code> and  <code class="code">fpoint.fault_code</code> parameters can use variable <code class="varname">args</code> of type <span class="type">va_list</span> for iterate over variadic parameters of the target function. Note, that this variable is initialized only once and its instance used in <code class="code">prologue</code> and <code class="code">epilog</code> parameters, one used in <code class="code">fpoint.fault_code</code> parameters and one used in <code class="code">original_code</code> parameter are independent from each other.
    </p><p>
Example of the group section for kasprintf() target function:
</p><pre class="programlisting">
[group]
    # Name and return type of the target function
    function.name = kasprintf
    returnType = char *

    # Names and types of the arguments of the target function
    arg.type = gfp_t
    arg.name = flags

    arg.type = const char *
    arg.name = fmt

    # Variable arguments indicator
    ellipsis = true
    
    # Variable arguments-specific definitions
    last_arg = fmt
    original_code = ret_val = kvasprintf(flags, fmt, args);

    # Calculate length of the allocated string
    prologue = size_t len = vsnprintf(NULL, 0, fmt, args);

    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = len

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = ret_val = NULL;

# End of the group of definitions for kstrdup().
</pre><p>
    </p><p>
Note the usage of kvasprintf() function in <code class="code">original_code</code> parameter. This function is equivalent to the target functions but takes <span class="type">va_list</span> argument as reference to variadic arguments. For compute length of resulted string in <code class="code">prologue</code>, vsnprintf() function is used with zero length of the destination buffer.
    </p><p>
It is possible for different replacement functions to share the same indicator function (and, therefore, share the scenario). This is more than simply using the same indicator functions, this is using a single instance of an indicator. These functions may use some data private for each indicator instance. In case of sharing, the data will also be shared.
    </p><p>
Sharing of the indicator functions can be useful, for example, for the target functions that are known to use a common mechanism internally (e.g. memory allocator), and you want to simulate a failure of this mechanism.
    </p><p>
If, say, function <code class="function">g</code> should share the fault simulation scenario with <code class="function">f</code>, you should define parameter <code class="varname">fpoint.reuse_point</code> in the group of function <code class="function">g</code> with value <code class="code">f</code>. In this case, the group for function <code class="function">f</code> should precede the group for function <code class="function">g</code>. Example of sharing a fault simulation scenario for <code class="function">__kmalloc</code> and <code class="function">krealloc</code>:
</p><pre class="programlisting">
    ...
[group]
    # Name and return type of the target function
    function.name = __kmalloc
    returnType = void *

    # Names and types of the arguments of the target function
    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # Fault Simulation
    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = ret_val = NULL;
    
# End of the group of definitions for __kmalloc().

[group]
    # Name and return type of the target function
    function.name = krealloc
    returnType = void *

    # Names and types of the arguments of the target function
    arg.type = const void *
    arg.name = p

    arg.type = size_t
    arg.name = size

    arg.type = gfp_t
    arg.name = flags
    
    # Fault Simulation
    <span class="emphasis"><em>fpoint.reuse_point = __kmalloc</em></span>

    fpoint.param.type = size_t
    fpoint.param.name = size

    fpoint.param.type = gfp_t
    fpoint.param.name = flags

    fpoint.fault_code = ret_val = NULL;

# End of the group of definitions for krealloc().
</pre><p>
Note that in the group for <code class="function">krealloc</code> function, we use the same names and types of the variables intended to be passed to the indicator function, as for <code class="function">__kmalloc</code>.
    </p><p>
If a fault simulation point is reused, it may be convenient to assign a name to this point that is different from the name of the target function the point was defined for:
	</p><pre class="programlisting">
    ...
[group]
    function.name = __kmalloc
    ...
    <span class="emphasis"><em>fpoint.rename = kmalloc</em></span>
    ...
# End of the group of definitions for __kmalloc().

[group]
    function.name = krealloc
    ...
    <span class="emphasis"><em>fpoint.reuse_point = kmalloc</em></span>
    ...
# End of the group of definitions for krealloc().
</pre><p>
Note, that when reusing a fault simulation point defined with <code class="varname">fpoint.rename</code> parameter, the name specified there is used (<code class="code">kmalloc</code>) rather than the name of the target function the point was defined for (<code class="code">__kmalloc</code>).
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. In the future, this step may be implemented in the <code class="filename">makefile</code> itself.
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom_fsim_scenarios"></a>5.5. Writing Custom Scenarios for Fault Simulation</h3></div></div></div><p>
The fault simulation scenarios described in <a class="xref" href="kedr_manual_using_kedr.html#fault_sim">Section 4.5, “Fault Simulation”</a> are configurable and are probably enough for many cases. If they are not, a kernel module implementing a custom <a class="link" href="kedr_manual_glossary.html#fault_simulation_indicator">fault simulation indicator</a> can be developed. This section describes how do this using <span class="command"><strong>kedr_gen</strong></span> tool provided by KEDR to generate source files from the templates. Common abilities of <span class="command"><strong>kedr_gen</strong></span> are described in detail in <a class="xref" href="kedr_manual_extend.html#using_gen">Section 5.1, “Using Code Generator to Create Custom Modules”</a>
    </p><p>
The whole infrastructure needed to build the module based on the definition file and the templates is located in <code class="filename">custom_indicator_fsim</code> subdirectory in the directory where the examples provided with KEDR are installed (<code class="filename">/usr/local/share/kedr/examples/</code> by default). Here are its contents:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">indicator.data</code></span></dt><dd>'definition' file to create the module that will implement the fault simulation indicator</dd><dt><span class="term"><code class="filename">makefile</code></span></dt><dd>file for common build infrastructure for <span class="command"><strong>make</strong></span> utility</dd><dt><span class="term"><code class="filename">Kbuild</code></span></dt><dd>file for building kernel module from C sources</dd><dt><span class="term"><code class="filename">calculator.c</code>, <code class="filename">calculator.h</code>, <code class="filename">control_file.c</code>, <code class="filename">control_file.h</code></span></dt><dd>additional source and header files that implement some of the indicator's functionality. These files are used for building the module.</dd></dl></div><p>
To use all this in development of your module, copy the contents of that directory to a directory of your choice.
    </p><p>
The first and the main step is to rewrite file <code class="filename">indicator.data</code> to reflect the definitions of your indicator module.
    </p><p>
Unlike a payload module for <a class="link" href="kedr_manual_extend.html#custom_callm_payloads">call monitoring</a> or <a class="link" href="kedr_manual_extend.html#custom_fsim_payloads">fault simulation</a> that can process several target functions in a single module, each fault simulation indicator should be implemented in a separate module. So, groups are not used in the definition file for the indicator module, only the global set of parameters is taken into account.
    </p><p>
The following parameters should be defined in that file:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">module.author</span></dt><dd>author of the module</dd><dt><span class="term">module.license</span></dt><dd>license for the module</dd><dt><span class="term">indicator.name</span></dt><dd>name of the indicator, provided by the module. This is the very name that should be used when one applies the indicator to some target function (to be exact, to a <a class="link" href="kedr_manual_glossary.html#fault_simulation_indicator">fault simulation point</a>).</dd><dt><span class="term">indicator.parameter.type</span></dt><dd>(multi-valued) types of the values that the indicator function accepts. This is an important part of the indicator and will be described later in detail. This parameter may be assigned no value at all - in this case, the indicator function will accept no parameters. </dd><dt><span class="term">indicator.parameter.name</span></dt><dd>(multi-valued) names of the values that the indicator function accepts.</dd><dt><span class="term">expression.variable.name</span></dt><dd>(multi-valued) names of variables that can be used in an expression to set a particular scenario for the indicator (see also <a class="xref" href="kedr_manual_using_kedr.html#fault_sim">Section 4.5, “Fault Simulation”</a>). The names themselves are by no means bound to the names of variables used in the indicator. The order of values is not important for this parameter. This parameter may even be left undefined as there are other ways to declare expression variables.</dd><dt><span class="term">expression.variable.value</span></dt><dd>(multi-valued) values of the corresponding expression variables that will be used during the evaluation of the expression (that is, when the indicator function is called). Typically, these values refer to the parameters of the indicator function.</dd><dt><span class="term">expression.variable.pname</span></dt><dd>(multi-valued) names of the parameters of the indicator function that can be used in an expression to set a particular scenario for the indicator. <code class="code"><code class="varname">expression.variable.pname</code> = <code class="literal">var_a</code></code> is equivalent to <code class="code"><code class="varname">expression.variable.name</code> = <code class="literal">var_a</code></code> followed by <code class="code"><code class="varname">expression.variable.value</code> = <code class="literal">var_a</code></code>. This parameter may even be left undefined as there are other ways to declare expression variables.</dd></dl></div><p>
    </p><p>
The main characteristic of a fault simulation indicator is a set of scenarios it can implement. Apart from <code class="varname">pid</code> parameter that can be used for each generated indicator and simply restricts the <span class="quote">“<span class="quote">area</span>”</span> of fault simulation, <code class="varname">expression</code> is the only indicator's parameter, which may affect the fault simulation scenario. An expression that uses only constant integers as arguments may implement simple  scenarios like <span class="pcite"><span class="quote">“<span class="quote">always simulate failure</span>”</span></span> or <span class="pcite"><span class="quote">“<span class="quote">never simulate failure</span>”</span></span>. But if the expression can use variables which may have different values each time the expression is evaluated, the set of supported scenarios increases dramatically.
    </p><p>
One type of variable that can be used in the expression is the parameter of the target function. E.g., expression <code class="code">(<code class="varname">size</code> &gt; 100)</code>, where <code class="varname">size</code> corresponds to the target function parameter, implements the scenario <span class="pcite"><span class="quote">“<span class="quote">simulate failure when <code class="varname">size</code> is greater than <code class="literal">100</code></span>”</span></span>. The only way for the indicator to implement such usage of a target function's parameter is to declare this parameter as parameter of indicator function. So, the corresponding replacement function should pass this parameter to the indicator function whenever it should choose whether it needs to simulate a failure. This behaviour of the indicator is achieved by the following definitions (assume <code class="varname">size</code> parameter of the target function has type <code class="literal">size_t</code>):
</p><pre class="programlisting">
indicator.parameter.type = size_t
indicator.parameter.name = size
</pre><p>
    </p><p>
This fragment only defines that the indicator function itself accepts parameter <code class="varname">size</code>. To permit using this parameter in the expression, the following definition should be added:
    </p><pre class="programlisting">
expression.variable.pname = size
</pre><p>
Parameters <code class="varname">expression.variable.name</code> and <code class="varname">expression.variable.value</code> may be useful for such cases:
</p><pre class="programlisting">
...
indicator.parameter.type = const char *
indicator.parameter.name = str
...
# Expression may use variables only with integer values, so we cannot use 
# a string parameter in it.
# But we can use the length of this string as parameter 'len'
expression.variable.name = len
expression.variable.value = strlen(str)
...
</pre><p>
</p><pre class="programlisting">
...
indicator.parameter.type = size_t
# Cannot use 'strlen' as name of the parameter, because strlen() is 
# the kernel function.
indicator.parameter.name = len
...
# But here 'strlen' is available - this is not a name of C variable.
expression.variable.name = strlen
# We only need to bind expression variable to its value.
expression.variable.value = len
...
</pre><p>
    </p><p>
However if we declare that the indicator function accepts parameter <code class="varname">size</code> of type <span class="type">size_t</span>, we make this indicator not applicable for those target functions that do not accept a parameter of that type. Or to be more exact, the indicator is not applicable for (cannot be used from) the replacement functions that do not provide a parameter of this type to indicator function. This limitation holds even if this parameter is not really used in the current scenario.
    </p><p>
Although it is acceptable for the indicator to use the variables in expression, which are not derived from the indicator's parameters like 
</p><pre class="programlisting">
expression.variable.name = prob50
expression.variable.value = random() % 2
</pre><p>
it is not recommended, because there is a more efficient way to do this. The thing is that, the variables of this kind are evaluated every time the indicator function is called, no matter if this variable is used in the expression or not. This evaluation may take relatively long time in some cases. There is another type of variables which is applicable in such cases - <em class="firstterm">runtime variables</em>. Declaration of such variables has the following format:
</p><pre class="programlisting">
expression.rvariable.name = prob50
expression.rvariable.code =&gt;&gt;
    return random() % 2;
&lt;&lt;
</pre><p>
<code class="varname">expression.rvariable.code</code> parameter provides the code of the function which will be used whenever value of variable is <span class="emphasis"><em>really</em></span> needed. The costs of such optimisation are a function call used instead of the inlined code when the value of the variable is needed, and inability to use local variables of the indicator function (and parameters of this function) to prepared the value of the runtime variable.
    </p><p>
To simplify writing expressions and to make them more readable, named constants can be declared and then used there. There are two ways to do this:
</p><pre class="programlisting">
expression.constant.name = constant_100
expression.constant.value = 100
</pre><p>
This makes the constant with name <code class="varname">constant_100</code> and value 100 available for usage in the expressions.
</p><pre class="programlisting">
expression.constant.cname = GFP_ATOMIC
</pre><p>
This makes the constant with name <code class="varname">GFP_ATOMIC</code> which evaluates to GFP_ATOMIC available for usage in the expressions. Expression <code class="code">flags == GFP_ATOMIC</code> is clearer and easier to read than <code class="code">flags == 32</code>, isn't it?
    </p><p>
Additionally, the following parameter can be defined:
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">global</span></dt><dd>code (may be multiline) that will be inserted at the global scope and its definitions will be visible everywhere in the source file of the indicator. Usually, this code contains <code class="code">#include</code> directives for the header files containing types definitions of parameters of the indicator and declarations of the functions used to obtain the values of the parameters.</dd></dl></div><p>
Example of indicator for <code class="function">kstrdup</code> function:
</p><pre class="programlisting">
# This module implements indicator for kmalloc-like functions.

module.author = Andrey Tsyvarev
module.license = GPL

global =&gt;&gt;
#include &lt;linux/gfp.h&gt;      /* gfp_flags constants */
#include &lt;linux/types.h&gt;    /* size_t */
&lt;&lt;

indicator.name = kmalloc

indicator.parameter.type = size_t
indicator.parameter.name = size

indicator.parameter.type = gfp_t
indicator.parameter.name = flags

expression.constant.c_name = GFP_NOWAIT
expression.constant.c_name = GFP_KERNEL
expression.constant.c_name = GFP_USER
expression.constant.c_name = GFP_ATOMIC

expression.variable.pname = size
expression.variable.pname = flags
</pre><p>
    </p><p>
After writing <code class="filename">payload.data</code> file, you can change the value of module_name variable in the <code class="filename">makefile</code> and <code class="filename">Kbuild</code> according to the one you use as value of <span class="quote">“<span class="quote">module.name</span>”</span> parameter. 
    </p><p>
The last step is to run <span class="command"><strong>make</strong></span> utility. This will invoke the code generator tool (<span class="command"><strong>kedr_gen</strong></span>) to create the sources for your payload module, then the module will be built.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="custom_analysis"></a>5.6. Implementing Custom Types of Analysis</h3></div></div></div><p>
KEDR framework also allows to implement custom analysis tools that process the information about the function calls made by the target module.
</p><p>
This section shows how to create a custom analysis system on top of KEDR. The system we are going to use as an example is rather simple: it maintains a set of counters accessible from user space that provide some information about the actions of the target module.
</p><p>
This analysis system will use neither call monitoring nor fault simulation facilities of KEDR. It will only rely on KEDR core and on the <a class="link" href="kedr_manual_reference.html#payload_api">API</a> it provides. Other types of analysis could be implemented in a way similar to this example.
</p><p>
In general, a custom analysis system based on KEDR can be created in the following steps.
</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Determine which information about the actions of the target module should be processed by your analysis system. Decide whether it is enough to process (and may be alter to some extent) the function calls to collect this information. If so, KEDR could be of help here.</p></li><li class="listitem"><p>Determine the calls to which functions your system needs to intercept to collect the necessary data or alter the behaviour of the target module in a required way. Note that it is only ordinary functions that count here rather than macros or inlines.</p></li><li class="listitem"><p>Prepare a data file describing the signatures of the target functions of interest. This file is needed for KEDR to generate <a class="link" href="kedr_manual_glossary.html#trampoline">trampoline</a> functions. A <a class="link" href="kedr_manual_reference.html#functions_support.stub">skeleton of such data file</a> described in this manual and the examples we provide with KEDR can be helpful here.</p></li><li class="listitem"><p>Generate the auxiliary source file containing the trampolines from the data file written at the previous step. This can be done using KEDR code generator as described in <a class="xref" href="kedr_manual_reference.html#functions_support.generate">Section 6.2.4, “Generating the Source Code of the Trampolines”</a>.</p></li><li class="listitem"><p>Prepare the source code of the payload module for KEDR that will process the intercepted functions. The examples we provide with KEDR as well as the <a class="link" href="kedr_manual_reference.html#payload_api.stub">skeleton of a payload module</a> described in this manual can be used as a starting point here.</p></li><li class="listitem"><p>Build the payload module from the source files created at the previous steps. This is done in almost the same way as for any other kernel module.</p></li></ol></div><p>
Once the above steps are completed, KEDR utilities can be used to load your payload module along with the KEDR core. You can now load the target module and your system will start analyzing it.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
The source code of the analysis system developed in this example is available in </p><p><code class="filename">&lt;kedr_install_dir&gt;/share/kedr/examples/counters/</code>.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.basics"></a>5.6.1. Choosing the Counters and the Functions to Process</h4></div></div></div><p>
Suppose the following counters are going to be supported by our analysis system:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>total number of memory allocation attempts;</p></li><li class="listitem"><p>number of memory allocation attempts that have failed;</p></li><li class="listitem"><p>size of the largest memory block requested to be allocated;</p></li><li class="listitem"><p>total number of mutex lock operations;</p></li><li class="listitem"><p>mutex balance, i.e. the difference between the total numbers of lock and unlock operations.</p></li></ul></div><p>
To make the counters accessible from the user space, we can, for example, provide a file in <code class="filename">kedr_counters_example</code> directory in debugfs for each one of them.
</p><p>
Once we have decided which data concerning a target kernel module our system will be collecting and processing, we need to determine which function calls made by the module the system should intercept.
</p><p>
Consider the first three counters. All of them are related to memory allocation. To collect necessary data when the target module operates, we can  use call interception facilities provided by KEDR. When the target module calls some function that allocates memory, the corresponding function provided by our analysis system will also be called and update counters. 
</p><p>
There is a number of memory allocation functions available for kernel modules. Assume for simplicity that we choose to process only the calls to the following ones:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">void * __kmalloc(size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void * krealloc(const void *p, size_t size, gfp_t flags)</code></p></li><li class="listitem"><p><code class="code">void * kmem_cache_alloc(struct kmem_cache *mc, gfp_t flags)</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
It should not be very hard to extend this example to support other functions that allocate memory like <code class="code">vmalloc()</code>, <code class="code">kstrdup()</code>, etc.
</p></div><p>
To collect data necessary to provide the remaining two counters, our system needs to process the calls to the operations with mutexes:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="code">void mutex_lock(struct mutex *lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_interruptible(struct mutex *lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_lock_killable(struct mutex *lock)</code></p></li><li class="listitem"><p><code class="code">int mutex_trylock(struct mutex *lock)</code></p></li><li class="listitem"><p><code class="code">void mutex_unlock(struct mutex *lock)</code></p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that the functions may be different for different variants and versions of the Linux kernel. There is no stable binary interface in the Linux kernel anyway. Please choose memory allocation operations and mutex-related functions appropriate for your kernel.
</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.define_trampolines"></a>5.6.2. Describing the Targets</h4></div></div></div><p>
At this step, we need to create a data file that describes the target functions of interest. It will be used to generate the source code of the trampoline functions for these target functions. You don't need to worry about how the trampolines should operate, they will be generated automatically at the next step. Just describe the target functions properly in the data file and the tools provided by KEDR will do the remaining tedious work. The file can be based on the skeleton given in <a class="xref" href="kedr_manual_reference.html#functions_support.stub">Section 6.2.3, “A Stub of the Data File Describing the Targets”</a>.
Here are the portions of the file corresponding to the memory allocation functions we have chosen above:
</p><pre class="programlisting">
header=&gt;&gt;
#include &lt;linux/slab.h&gt;
...
&lt;&lt;

[group]
    function.name = __kmalloc
    returnType = void *
    
    arg.type = size_t
    arg.name = size
    
    arg.type = gfp_t
    arg.name = flags

[group]
    function.name = krealloc
    returnType = void *
    
    arg.type = void *
    arg.name = p
    
    arg.type = size_t
    arg.name = size
    
    arg.type = gfp_t
    arg.name = flags

[group]
    function.name = kmem_cache_alloc
    returnType = void *
    
    arg.type = struct kmem_cache *
    arg.name = mc
    
    arg.type = gfp_t
    arg.name = flags

...
</pre><p>
</p><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.generate_trampolines"></a>5.6.3. Generating the Trampolines</h4></div></div></div><p>
Assuming that the data file you have written in the previous section is named  <code class="filename">functions_support.data</code>, generation of the source file containing the definition of trampoline functions cay be performed as follows:
</p><pre class="programlisting">
&lt;kedr_install_dir&gt;/lib/kedr/kedr_gen \
    &lt;kedr_install_dir&gt;/share/kedr/templates/function_support.c \
    functions_support.data &gt; functions_support.c
</pre><p>
This will generate file <code class="filename">functions_support.c</code> with the appropriate definitions.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.payload"></a>5.6.4. Creating the Payload Module</h4></div></div></div><p>
To implement our analysis system, we need to create <a class="link" href="kedr_manual_glossary.html#payload_module">a payload module</a> for KEDR. As a starting point, we can use, for example, the skeleton of a module given in <a class="xref" href="kedr_manual_reference.html#payload_api.stub">Section 6.1.12, “A Stub of a Payload Module”</a>. Because our payload does not need to change the behaviour of the target functions, we use <a class="link" href="kedr_manual_glossary.html#post_handler">post handlers</a> for all of these except <code class="function">mutex_unlock</code>. For <code class="function">mutex_unlock</code>, we use <a class="link" href="kedr_manual_glossary.html#pre_handler">pre handler</a> (see <a class="xref" href="kedr_manual_extend.html#happens_before_parameter">Section 5.3, “<span class="quote">“<span class="quote">trace.happensBefore</span>”</span> Parameter for Call Monitoring”</a>).
</p><p>
The instance of <code class="code">struct kedr_payload</code> could be filled as follows (this structure should be used when registering and unregistering the payload module with KEDR core):
</p><pre class="programlisting">
/* Post handler pairs */
statuc kedr_post_pair post_pairs[] = {
    { (void *)&amp;__kmalloc, (void *)&amp;post_kmalloc},
    { (void *)&amp;krealloc, (void *)&amp;post_krealloc},
    { (void *)&amp;kmem_cahche_alloc, (void *)&amp;post_kmem_cache_alloc},
    { (void *)&amp;mutex_lock_interruptible, (void *)&amp;post_mutex_lock_interruptible},
    { (void *)&amp;mutex_lock_killable, (void *)&amp;post_mutex_lock_killable},
    { (void *)&amp;mutex_trylock, (void *)&amp;post_mutex_trylock},
    { NULL,}
};

/* Pre handler pairs */
statuc kedr_pre_pair pre_pairs[] = {
    { (void *)&amp;mutex_unlock, (void *)&amp;pre_mutex_unlock},
    { NULL,}
};



static struct kedr_payload counters_payload = {
    .mod                    = THIS_MODULE,
    .post_pairs             = post_pairs,
    .pre_pairs              = pre_pairs,
    .replace_pairs          = NULL,
    .target_load_callback   = NULL,
    .target_unload_callback = NULL
};
</pre><p>
The initial value of each counter is 0. Post handlers actually update the counters. They do this with special locks held to avoid some of the concurrency issues. For example, the post handler for <code class="code">__kmalloc()</code> looks like this:
</p><pre class="programlisting">
static void
post___kmalloc(size_t size, gfp_t flags, void *ret_val,
    struct kedr_function_call_info *call_info)
{
    unsigned long irq_flags;
    
    spin_lock_irqsave(&amp;spinlock_alloc_total, irq_flags);
    ++cnt_alloc_total;
    spin_unlock_irqrestore(&amp;spinlock_alloc_total, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_failed, irq_flags);
    if (ret_val == NULL) ++cnt_alloc_failed;
    spin_unlock_irqrestore(&amp;spinlock_alloc_failed, irq_flags);
    
    spin_lock_irqsave(&amp;spinlock_alloc_max_size, irq_flags);
    if (size &gt; cnt_alloc_max_size) cnt_alloc_max_size = size;
    spin_unlock_irqrestore(&amp;spinlock_alloc_max_size, irq_flags);
}
</pre><p>
This handler updates the variables corresponding to the relevant counters, <code class="varname">cnt_alloc_total</code>, <code class="varname">cnt_alloc_failed</code> and <code class="varname">cnt_alloc_max_size</code>, according to arguments of target functions and its return value.
</p><p>
The technical details concerning the creation of files for the counters in debugfs, are not described here. If you are interested in these details, see the source code of <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.build"></a>5.6.5. Building the Payload Module</h4></div></div></div><p>
The payload module that we have prepared can be built much in the same way as any other kernel module. Still, there is a couple of things to take into account.
</p><p>
First, the module uses header files provided by KEDR, so the top include directory of KEDR should be specified in <code class="code">-I</code> compiler option. The directory is usually <code class="filename">&lt;kedr_install_dir&gt;/include/</code>.
</p><p>
Second, each payload module uses functions exported by KEDR core and therefore needs the appropriate .symvers file. Before building the module, you should copy <code class="filename">kedr_base.symvers</code> file provided by KEDR to the directory of the payload module and rename it to <code class="filename">Module.symvers</code>. <code class="filename">kedr_base.symvers</code> is usually located in <code class="filename">/lib/modules/`uname -r`/symvers/</code> or in <code class="filename">&lt;kedr_install_dir&gt;/lib/modules/`uname -r`/symvers/</code> in case of a non-global installation of KEDR.
</p><p>
You can look at <code class="filename">Kbuild</code> and <code class="filename">makefile</code> files to see how the payload is built in <span class="quote">“<span class="quote">Counters</span>”</span> example.
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="custom_analysis.use"></a>5.6.6. Using the Payload Module</h4></div></div></div><p>
Now that the payload module for our analysis system is built, we can use it to see how the values of the counters change as the target module operates. You can choose any kernel module as a target if you know how to properly load it and to make it operate.
</p><p>
Our analysis system makes the counters available via the files in debugfs. So if debugfs is not mounted (usually its directory is <code class="filename">/sys/kernel/debug/</code>), mount it first to a directory of your choice. For example,
</p><pre class="programlisting">
mount debugfs -t debugfs some_dir/debugfs
</pre><p>
Now it is time to load KEDR core and <code class="filename">kedr_counters.ko</code> payload module that we have built before. The easiest way is 
probably to create a configuration file, say, <code class="filename">my.conf</code>, with the following contents:
</p><pre class="programlisting">
payload path_to_example_directory/kedr_counters.ko
</pre><p>
and use <span class="command"><strong>kedr start</strong></span> with that file:
</p><pre class="programlisting">
kedr start &lt;name_of_target_module&gt; my.conf
</pre><p>
See <a class="xref" href="kedr_manual_using_kedr.html#kedr_control">Section 4.1, “Controlling KEDR”</a> for a detailed information about the configuration files, <span class="command"><strong>kedr start</strong></span>, etc.
</p><p>
Load target module and do something with it. While it is working (and also after it is unloaded), you can check how the counters are shown in the 
files in <code class="filename">kedr_counters_example</code> subdirectory in debugfs.
</p><pre class="programlisting">
tester@lab-x86:&gt; cd /sys/kernel/debug/kedr_counters_example/
tester@lab-x86:&gt; ls
alloc_failed  alloc_max_size  alloc_total  mutex_balance  mutex_locks

tester@lab-x86:&gt; cat alloc_max_size 
Maximum size of a memory chunk requested: 48
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
Note that if you unload the target module and then load it again while the analysis system (KEDR core modules and <code class="filename">kedr_counters.ko</code> payload module) is loaded, the counters will not be reset. If you need them to reset in such situations, you can implement it yourself using target load/unload callbacks (see <a class="xref" href="kedr_manual_reference.html#payload_api.payload">Section 6.1.6, “struct kedr_payload”</a>).
</p></div></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="kedr_manual_using_kedr.html">Prev</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="kedr_manual_reference.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Using KEDR </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. KEDR Reference</td></tr></table></div></body></html>
