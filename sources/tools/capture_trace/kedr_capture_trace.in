#!/bin/sh

############################################################################
# Usage:
#		capture_trace start [-d <debugfs-mount-dir>] [<file>]
#       capture_trace stop
#       capture_trace status
#		capture_trace session [-d <debugfs-mount-dir>] [<file>]
# 
# 'start' command starts listening to the trace in non-blocking mope,
# capture the messages output there by the payload modules and by the controller,
# and store them in the file specified by <file>.
# If file exists, trace will be appended to it.
# If file is not specified, trace is output into STDOUT.
#
# <debugfs-mount-dir> is used to determine, where debugfs is mounted.
# If it is not given, it is assumed to "/sys/kernel/debug".
#
# 'stop' command stops capturing.
#
# 'status' command output, whether capturing is running now.
#
# 'session' command similar to start, but listen trace in blocking mode,
# until target session is finished. If file specified and exist, also verify its content
# to determine current state of the target session.
#
# A message occupies a single line in the trace.
# Currently, the messages have the following format (the number of spaces
# may vary, of course):
# TASK-PID    [CPU#]    TIMESTAMP:  EVENT: DATA
# 
# Example:
# rmmod-2274  [000] 16770.039434: called_kfree: arguments: (dd5eb000)
############################################################################

if test $# -eq 0 ; then
    printf "'start', 'stop', 'status' or 'session' command should be specified.\n"
	exit 0
fi

command="$1"
shift

PID_FILE=@KEDR_PREFIX_TEMP_SESSION@/capture_trace.pid

if test -f "${PID_FILE}"; then
    LISTENER_PID=$(cat "${PID_FILE}")
    # Check if $PID_FILE indeed contains a pid (a weak check).
    echo ${LISTENER_PID} | grep '^[0-9][0-9]*$' > /dev/null
    if test $? -ne 0; then
    	printf "Invalid pid of a listener process: \"${LISTENER_PID}\". Remove temporary file.\n" >2&

    # Remove the pid file as it is probably corrupted somehow.
    	rm -f "${PID_FILE}"
        LISTENER_PID=
    fi
else
    LISTENER_PID=
fi

# Common part of 'start' and 'session' commands:
# Parse options, and verify it. Also create file, if it specified and not exist.
if test "${command}" = "start" -o "${command}" = "session"; then
	#Default value
	DEBUGFS_MOUNT_POINT="/sys/kernel/debug"
    while getopts ":d:" option; do
		case $option in
		'd')
			DEBUGFS_MOUNT_POINT="$OPTARG";;
		*)
			printf "Usage: \n\n\t$0 start [-d <debugfs-mount-dir>] [<path_where_to_store_trace>]\n" >&2
			exit 1;;
		esac
	done
	shift $(($OPTIND - 1))

    if test "${LISTENER_PID}"; then
    	# temporary file exists
    	printf "It seems that some other process is now listening to the trace "
    	printf "or the previous attempt to listen to it aborted unexpectedly.\n" 
    	printf "Please execute\n    $(dirname $0)/kedr_capture_trace stop\n"
    	printf "before."
    	exit 1
    fi

    if test ! -d ${DEBUGFS_MOUNT_POINT}; then
        printf "debugfs mount point ${DEBUGFS_MOUNT_POINT} is not exist.\n"
        printf "Please specify correct directory, where debugfs is mounted, by the -d option.\n"
        exit 1
    fi
	trace_pipe="${DEBUGFS_MOUNT_POINT}/tracing/trace_pipe"
	if test ! -e "${trace_pipe}"; then
        printf "Tracing file "${trace_pipe}" is not exist.\n"
        printf "Probably, debugfs is not mounted into "${DEBUGFS_MOUNT_POINT}", or kernel tracing system is not initialized.\n"
        exit 1
	fi

    if test $# -ne 0; then
		OUT_FILE="$1"
	fi
fi


case ${command} in
start)
    # Start listening to the trace pipe and capturing the events
    if test $OUT_FILE; then
	    if test -e "${OUT_FILE}"; then
	        if test ! -w "${OUT_FILE}"; then
	            printf "Output file '%s' cannot be written\n" "${OUT_FILE}"
	            exit 1
	        fi
	    else
	        # create empty file
	        printf "" > "${OUT_FILE}"
	        if test $? -ne 0; then
	            printf "Cannot create output file '%s'\n" "${OUT_FILE}"
	            exit 1
	        fi
	    fi
		cat "${trace_pipe}" >> "${OUT_FILE}" &
	else
		cat "${trace_pipe}" &
	fi
    LISTENER_PID=$!
    # $! is the pid of the last backgroud process launched from this shell.

    # Check if the listener process is actually running.
    ps -e | grep $! > /dev/null
    if test $? -ne 0; then
    	printf "Failed to start listening to the trace pipe\n" >&2
    	exit 1
    fi
    echo ${LISTENER_PID} > "${PID_FILE}"
    printf "Capturing started.\n" >&2
    ;;
stop)
    if test ! "${LISTENER_PID}"; then
    	printf "Nothing to stop: no process is listening to the trace pipe now.\n" >&2
    	exit 1
    fi
    # Check if this pid is actually the id of a listener process.
    ALL_PS_OUT=$(ps -ef) 
    LISTENER_PRESENT=$(echo "${ALL_PS_OUT}" | grep "${LISTENER_PID}.*cat.*/trace_pipe" | wc -l)

    if test ${LISTENER_PRESENT} -eq 1; then
    	kill ${LISTENER_PID}
    fi
    # If there are no listeners, do nothing, just remove .pid file.

    rm -f ${PID_FILE}
    printf "Capturing stopped.\n" >&2
    ;;
status)
    if test "${LISTENER_PID}"; then
        printf "Capturing of the trace is running now.\n" >&2
    else
        printf "Capturing of the trace is not running now.\n" >&2
    fi
    ;;
session)
	end_session_regexp="target_session_ends"
	if test $OUT_FILE; then
		if test -f "${OUT_FILE}"; then
		    # Verify, whether session already ended
			start_session_regexp="target_session_starts"

		    awk_script="
		        BEGIN {result=\"no\"}
		        /${start_session_regexp}/ {result=\"no\"; next}
		        /${end_session_regexp}/ {result=\"yes\"; next}
		        END {print result}"

		    is_trace_already_complete=`awk "${awk_script}" "${OUT_FILE}"`
		    if test "${is_trace_already_complete}" = "yes"; then
		        exit 0
		    fi
		else
		    printf "" > "${OUT_FILE}"
		    if test $? -ne 0; then
		        printf "Cannot create output file '%s'\n" "${OUT_FILE}" >&2
		        exit 1
		    fi
		fi

		sed -e "/$end_session_regexp/ q" < "${trace_pipe}" >> "${OUT_FILE}"
	else
		sed -e "/$end_session_regexp/ q" < "${trace_pipe}"
	fi
	;;
*)
    printf "Incorrect command \"${command}\". Should be 'start' ,'stop', 'status' or 'session'." >&2
esac

exit 0
