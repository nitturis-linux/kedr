[group]
	# Name and return type of the target function
	function.name = krealloc
	returnType = void *

	# Names and types of the arguments of the target function
	arg.type = const void *
	arg.name = p

	arg.type = size_t
	arg.name = size

	arg.type = gfp_t
	arg.name = flags
	
	# The body of the replacement function
	handler.body =>>
	void *ret_val;
	
	if (size == 0 || !ZERO_OR_NULL_PTR(p)) {
		/* kfree */
		if (!ZERO_OR_NULL_PTR(p) && !klc_find_and_remove_alloc(p)) 
			klc_add_bad_free(p, stack_depth);
/* [NB] If size != 0 and p != NULL and later the allocation fails, we will
 * need to add a fake allocation event for 'p' to the storage because 'p'
 * is not actually freed by krealloc() in this case.
 */
	}
	
	ret_val = krealloc(p, size, flags);

	if (size != 0) {
		if (p == NULL) { 
			/* kmalloc */
			if (ret_val != NULL)
				klc_add_alloc(ret_val, size, stack_depth);
		} else {
			/* kfree + kmalloc if everything succeeds */
			klc_add_alloc(((ret_val != NULL) ? ret_val : p), 
							size, stack_depth);
			/* If the allocation failed, we return information about 'p'
			 * to the storage. A minor issue is that stack trace will 
			 * now point to this call to krealloc rather than to the call 
			 * when 'p' was allocated. Should not be much of a problem.
			 */
		}
	}
	return ret_val;
	<<

# End of the group of definitions for krealloc().

#######################################################################
