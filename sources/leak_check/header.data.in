module.name = @kmodule_name@
module.author = Eugene A. Shatokhin

header =>>
/* This payload module checks the target for memory leaks.
 * kedr_leak_check does not use trace events or the like, it performs
 * analysis itself and simply outputs the results to the files in 
 * debugfs - see the contents of 'kedr_leak_check' directory there.
 *
 * For each possible memory leak (and for each free-like call without 
 * matching allocation call) the system stores the address of the memory
 * block and a portion of the call stack for the allocation / deallocation
 * call.
 *
 * Module parameters:
 *  stack_depth - (unsigned integer, not greater than 16) - maximum number
 *  of stack frames to store and output. Default: 12.
 *
 * Notes:
 * kedr_leak_check can be more convenient to look for memory leaks than 
 * plain call monitoring with analysis of the trace. The trace may become
 * huge if the target module actively allocates and frees memory.
 *********************************************************************/
 
/* ========================================================================
 * Copyright (C) 2012, KEDR development team
 * Copyright (C) 2010-2011, Institute for System Programming 
 *                          of the Russian Academy of Sciences (ISPRAS)
 * Authors: 
 *      Eugene A. Shatokhin <spectre@ispras.ru>
 *      Andrey V. Tsyvarev  <tsyvarev@ispras.ru>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published
 * by the Free Software Foundation.
 ======================================================================== */

#include <linux/slab.h>
#include <linux/gfp.h>
#include <linux/mm.h>
#include <linux/topology.h>  /* NUMA-related stuff */
#include <linux/uaccess.h>   /* user space access functions */
#include <linux/string.h>    /* *dup_user() */
#include <linux/err.h>       /* ERR_PTR, etc. */
#include <linux/vmalloc.h>   /* vmalloc() family */
#include <linux/rcupdate.h>  /* RCU */
#include <linux/pagemap.h>   /* add_to_page_cache_* */
#include <linux/fs.h>        /* POSIX ACLs, etc. */
#include <linux/posix_acl.h> /* POSIX ACLs */
#include <linux/parser.h>    /* match_strdup */

/* If call_rcu() is used, it can be necessary to check if the pointer 
 * passed to it is really an address of a callback function. If the 
 * address is less than 4096, it can be an instruction to call_rcu() to
 * call kfree or a similar function on the containing structure. 
 *
 * N.B. We do not rely on __is_kfree_rcu_offset() to check the address
 * because this function is probably more likely to be changed in the 
 * future (to make it possible to use kmem_cache_free(), for example).*/
#define KEDR_RCU_ADDRESS_LIMIT	4096

/* This is needed because the current system of data files, templates and 
 * code generation tools does not allow specifying the type of a function
 * pointer directly in the signatures of the functions. */
typedef void (*kedr_rcu_callback_type)(struct rcu_head *);
<<
