Заметки по архитектуре системы KEDR
-----------------------------------

Здесь собраны некоторые идеи, которые могут быть, а могут и не быть 
реализованы в системе KEDR.
=======================================================================

1. Распределение компонентов системы по модулям ядра

1.1
Удобно Loading Detector и Call Instrumentation Facilities держать вместе в 
одном модуле ядра ("instrumentation-модуль"). 

При загрузке этого модуля ему передаётся параметр - имя анализируемого 
(target) модуля, того, момент загрузки которого надо отследить и который 
надо инструментировать.

1.2
Call Monitor, Base Checker, Fault Simulator (т.н. "payload-модули", 
"полезная нагрузка") лучше оформить как отдельные ("сменные") модули ядра. 
В каждый момент времени может быть загружен только один из них. А может 
быть так, что и никто из них не загружен.

От каждого payload-модуля требуется предоставить instrumentation-модулю 
таблицу замены адресов функций, которую тот будет использовать. Для этого в 
каждом payload-модуле достаточно экспортировать функцию с заранее 
оговорённой сигнатурой. Эта функция должна как-то выдать 
указатель/указатели на соотв. таблицу замен и кол-во элементов в ней (в 
таблице указано какой адрес вызова на какой заменять).

Условное название функции - kedr_get_replacement_table.

Когда instrumentation-модуль получает управление при загрузке 
target-модуля, то проверяет сначала, доступна ли в данный момент функция 
kedr_get_replacement_table (см. <linux/kallsyms.h>, kallsyms_lookup_name и 
иже с ней). 

Если недоступна, значит, ни один payload-модуль сейчас не загружен. Это не 
ошибка. Instrumentation модуль может вывести об этом сообщение в журнал и 
успокоиться - до момента следующей загрузки данного target модуля.

Если kedr_get_replacement_table доступна, т.е. кем-то экспортируется, 
значит, какой-то payload module загружен. Instrumentation module получает  
адрес этой функции и, зная, её сигнатуру, вызывает её, получая таблицу 
замен. Перед этим ещё неплохо бы увеличить reference count для этой 
функции, чтобы предотвратить преждевременную выгрузку payload module. 
Вообще, после того, как payload module найден, его стоит (принудительно) 
держать в памяти до того, как target module или instrumentation module не 
будет выгружен.

[NB] Вероятно, вызов kedr_get_replacement_table нельзя вставить в код 
instrumentation module как есть заранее, т.к. на момент его загрузки эта 
функция в ядре модет и не быть доступна: мало ли, вдруг payload module нет 
ещё. 

При такой схеме работы instrumentation module не зависит от того, что 
конкретно делает payload module и какие конкретно функции ему нужно 
перехватывать. Для одних типов проверок нужно отслеживать одни вызовы, для 
других - другие.

Less coupling + reusable parts => good extendable system 

Кстати, это позволит решать вопрос с copy_from_user / _copy_from_user, не 
затрагивая при этои instrumentation module. Например, это можно делать на 
стадии конфигурации и сборки соотв. payload module (плюс, вероятно, #ifdef 
HAVE_COPY_FROM_USER ...).

1.3
Самая важная часть каждого payload module - набор replacement фунций и, 
если есть, набор соотв. trace events для вывода информации из этих функций.

1.4
В instrumentation module стоит при обработке загрузки target module 
сохранить указатель на соотв. struct module* (NULL, если в данный момент  
target модуль ещё не загружен или уже выгружен). Вероятно, стоит ещё 
экспортировать функцию, которая выдаёт этот указатель (условно назовём её 
kedr_target_module_ptr() ). 

Это может пригодиться payload-модулям (например, для проверки module state, 
чтобы выяснить, выполняется init или уже основная часть модуля).
=======================================================================

2. Fault simulation

2.1
Нужен API для приложений пользовательского режима для загрузки (и смены) 
сценария в fault simulation в runtime. Как конкретно этот сценарий будет 
передан в соотв. payload module - это проблема реализации API. Будет ли 
использоваться запись в соотв. устройство, или ioctl для этого устройства, 
или netlink, или что-то ещё - для пользователя это неважно и ему не стоит 
рассчитывать, что будет использован какой-то конкретный механизм передачи 
данных.

Возможность изменения сценария в runtime полезна для тестов, в который 
сначала соотв. запросами (напр., из user space) target module приводится в 
нужное состояние, а затем уже нужно применять fault simulation, чтобы 
проверить соотв. пути в коде target module.

2.2
Вероятно, стоит предусмотреть задание для каждой из интересующих функций 
своего сценария fault simulation.

2.3
Стоит предусмотреть, как минимум, такие виды сценариев: 
- fail all calls
- fail all calls after init

Полезно иметь возможность задавать и другие сценарии.

2.4
Технически, в качестве "сценария" для данной функции можно задавать имя 
некоторой функции-индикатора, которая принимает заранее оговорённые 
параметры и возвращает что-то вроде true/false (не ноль / ноль ?).

Эта функция вызывается с нужными параметрами в соотв. replacement-функции в 
payload module. Если вернёт true - нужно симулировать failure соотв. 
целевой функции, если true - просто вызвать целевую функцию с нужными 
параметрами и не вмешиваться.

[??]"Сценарий" fault simulation - набор имён функций-индикаторов для 
интересующих целевых функций.

[NB] При передаче такого "сценария" fault simulation в соотв. payload 
module тому стоит прежде всего получить и сохранить адреса этих функций, 
чтобы не искать их потом каждый раз. Вызывать потом нужно именно по 
адресам: имена-то всё равно заранее неизвестны и т.д.

2.5
Некоторые стандартные функции-индикаторы (напр., для сценариев, указанных в 
2.3) можно экспортировать и из самого payload module. Разработчик тестов 
может подготовить и другие функции-индикаторы и разместить их в каком-то 
отдельном модуле, который будет загружаться перед запуском тестов. Сами 
тесты при этом, вероятно, будут работать из user space.

=======================================================================

3. Механизм сбора данных, replacement-функции

3.1
Исходный код replacement-функции для стандартных типов payload module (Call 
Monitor, Fault Simulator, Base Checker), вероятно, стоит генерировать 
автоматически по их более наглядному описанию. 

Для Call Monitor и др. типов payload-модулей, использующих 

Идеи чем-то похожи на то, что есть в T2C: разработчик системы (тестов, в 
случае T2C) задаёт логику её работы на понятном ему языке, а полный 
исходный код соотв. системы создаётся автоматически по спец. шаблонам. 
Детали реализации скрыты от разработчика системы в этих шаблонах и соотв. 
API. 

Разработчику ни к чему разбираться, как именно надо объявить trace events 
или вызвать функцию-индикатор при fault simulation (см. 2.4). Он 
концентрируется на коде, реализующем логику работы системы.

[NB] Такой подход, кстати, может нам сильно упростить перенос приложений, 
разработанных на базе KEDR, на новые версии KEDR. Шаблоны изменятся, а 
логику, возможно, если и придётся менять, но не слишком сильно (аналогия с 
переносом тестовых наборов с T2C v1 на T2C v2).

3.2
Один из примеров replacement-функции для payload module типа "Call Monitor" 
(см. пример "call_repl_with_events"):

-----------
long 
repl_copy_from_user(void* to, const void __user * from, unsigned long n)
{
	long result = copy_from_user(to, from, n);
	
	/* Here is our tracepoint for this function */
	trace_called_copy_from_user(to, from, n, result);
	
	return result;
}
-----------

Т.е. примерная структура подобных функций м.б. такой (в формате, наподобие 
T2C/MiST templates):

----- <$repl_function$> ------
<$ret_type$>
repl_<$target_func_name$>(<$target_param_spec : join(,)$>)
{
# Здесь сохраним возвращаемое значение целевой функции. 
# Для простоты, не рассм. тут случай, когда она ничего не возвращает.
    <$ret_type$> result;

# Тут вставляется заданный разработчиком кусок кода - как есть.
# Может пригодиться для получения значений каких-то системных 
# параметров и пр.
    <$prologue_code$> 

# Вызываем целевую функцию, сохраняем возвращаемое значение.
    result = <$target_func_name$>(<$target_param : join(,)$>);
    
# Тут вставляется заданный разработчиком кусок кода - как есть.
# Может пригодиться для какой-то предварительной обработки результатов 
# вызова целевой функции и пр. Полученные данные потом, вероятно, будут 
# переданы в соотв. trace event.
    <$epilogue_code$> 

# Trace event - выдача результатов для послед. анализа в use space.
    trace_called_<$target_func_name$>(<$trace_event_param : join(,)$>);

# Конец
    return result;
}
-----------
----- <$target_param_spec$> ------
<$target_param_type$> <$target_param$>
-----------

Параметры: ret_type, target_func_name, target_param_type, target_param, 
trace_event_param, prologue_code, epilogue_code.

Эти параметры поступают от пользователя, из пользовательского представления 
логики сбора информации. Это представление может быть просто набором 
записей след. вида (а может и как-то по-другому выглядеть, главное, чтобы 
наглядно для пользователя это было):

---------------------------------------
target_func_name =  copy_from_user

ret_type =          long

target_param_type = void*
target_param =      to

target_param_type = const void __user * 
target_param =      from

target_param_type = unsigned long
target_param =      n

prologue_code =>>
/* no-op */
<<

epilogue_code =>>
/* no-op */
<<

trace_event_param = to
trace_event_param = from
trace_event_param = n
trace_event_param = result
trace_event_param = whatever_else
---------------------------------------

[NB] Параметры trace event не обязаны совпадать с параметрами целевой 
функции. В trace event можно передавать что угодно.

Каким-то подобным образом и в других типах payload module можно всё 
организовать.

[NB] MiST Engine для template-based generation здесь не пригодится ли???
=======================================================================

4. API для пользовательского режима

4.1
API для пользовательского режима можно реализовать, например, в библиотеке 
(.so) и соотв. command line tool. Библиотека - для использования в 
программах на С/С++, command line tool - для использования в скриптовых 
языках (shell, perl, ...) и пр.

4.2
В KEDR API инкапсулирован механизм работы с модулями KEDR в ядре, механизм 
получения данных, собранных этими модулями и пр. 

Как именно происходит обмен данными и управление системой KEDR (передача 
сценариев fault simulation и т.д.) - вопрос реализации API, от пользователя 
это скрыто.

4.3
Нужен API для проверки наличия значений параметров, выведенных соотв. 
replacement-функциями. Есть что-то новое в трассе или нет + может, 
подождать надо (a la poll()?) и т.п.

Нужен API для получения значения данного параметра по его имени из соотв. 
record, взятой из трассы. Это всё будет использоваться в тестах в 
пользовательском режиме. 

Напр., для случая, описанного в 3.x, м.б., что-то такое в соотв. тестах:

long ret        = GET_PARAM_BY_NAME(long, "result");
void* dest_addr = GET_PARAM_BY_NAME(void*, "to");

И т.п.
=======================================================================

99. Разное

Debugfs можно монтировать туда, куда нам удобнее. Неважно, что при этом эта 
файловая система ещё куда-то м.б. смонтирована (/debug/, /sys/kernel/debug/ 
или куда угодно).
=======================================================================
